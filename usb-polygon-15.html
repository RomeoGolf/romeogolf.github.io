<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-15: начало работы над записью</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">16</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/nishchebrod.html">
              нищеброд
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pokhodnoe.html">
              походное
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/samodelki.html">
              самоделки
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Ср 11 Апрель 2018</h4>
    <article>
      <h1>USB-polygon-15: начало работы над записью</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Зачем запись?</a></li>
<li><a href="#_2">С чего начать?</a></li>
<li><a href="#_3">Изготовление файла из массива в ОЗУ</a></li>
<li><a href="#_4">Использование полученного файла</a></li>
<li><a href="#windows-7">Запись в Windows 7</a></li>
<li><a href="#debian-8">Запись в Debian 8</a></li>
<li><a href="#_5">Данные в команде записи</a></li>
<li><a href="#_6">Итого</a></li>
</ul>
</div>
<h2 id="_1">Зачем запись?</h2>
<p>Текущее состояние проекта таково, что отладочная плата успешно имитирует флэшку с <abbr title="Файловая система">ФС</abbr> FAT32 и несколькими файлами, которые читаются в <abbr title="Операционная система">ОС</abbr> Windows и Linux (проверено в Win XP, 7, в Debian 8, а также в Android 4.2).</p>
<p>Причем, файл, который видит <abbr title="Операционная система">ОС</abbr>, не обязательно должен лежать в памяти устройства. Он может подготавливаться &laquo;на лету&raquo; при обращении на чтение к определенным адресам устройства. Это можно использовать, допустим, для приема данных от неких внешних устройств, формируя файл из массива-буфера принятых данных. Можно также рассматривать чтение определенного файла, то есть, обращение на чтение к определенным адресам устройства, как команду выполнить определенное действие (если подключить к устройству некий исполнительный механизм, например).</p>
<p>Аналогично, и запись можно использовать не только в целях сохранения записываемой информации. Хотя на борту применяемого контроллера есть некоторый объем пользовательской flash-памяти, ее слишком мало, чтобы превратить плату в настоящую флэшку. Но операцию записи можно трактовать как команду, к тому же сопровождаемую некоторым блоком данных. Опять же, &laquo;записываемые&raquo; данные можно выдать по какому-либо протоколу из поддерживаемых контроллером аппаратно или эмулируемых программно, например, UART, SPI. I2C, да мало ли что еще, хоть бы и тупо параллельным кодом через один из портов.</p>
<h2 id="_2">С чего начать?</h2>
<p>На текущий момент реакция на запись очень простая: устройство на операции записи отвечает подтверждением успешного завершения, игнорируя то, что ему передают.</p>
<p>При этом, современные <abbr title="Операционная система">ОС</abbr> предпочитают на чтение с флэшкой работать с собственным кэшем. В результате если, скажем, в проводнике закинуть новый файл на эту &laquo;флэшку&raquo;, и при этом файл будет размером меньше, чем &laquo;оставшееся свободное&raquo; место, то файл на &laquo;флэшке&raquo; как бы появится, и измененные вручную файлы сохранят изменения до разрыва связи <abbr title="Персональный компьютер">ПК</abbr> с устройством.</p>
<p>Хорошо бы узнать, что при этом делает <abbr title="Операционная система">ОС</abbr>. В упомянутом уже документе &laquo;FAT32 File System Specification&raquo; от Microsoft (fatgen103.pdf) подробно описаны разного рода структуры данных, которые должны находиться по определенным адресам устройства с <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>. Однако, не удалось найти документа, в котором бы регламентировалась работа с этими структурами. А жаль. Потому что основываясь на организации процесса записи можно идентифицировать поступающий поток данных, как принадлежащий тому или иному файлу &mdash; задача, которая перед нормальными флэшками не возникает.</p>
<p>Допустим, запись нового файла поймать должно быть не трудно &mdash; должно быть обращение к адресам, расположенным дальше окончания последнего файла в таблице. А при перезаписи существующего я вижу минимум два варианта действий.</p>
<p>В одном случае драйвер <abbr title="Файловая система">ФС</abbr> может определить, что новое содержимое не больше старого (в кластерах, по крайней мере) и перезаписать его на прежнее место. Если же данных в файле стало значительно больше, можно начать писать на старое место, а вот для непомещающегося &laquo;хвоста&raquo; поискать место в свободной зоне. Тогда принадлежность данных файлу можно определить по адресу обращения на запись.</p>
<p>В другом случае драйвер может тупо начать запись изменившегося файла сразу в свободной зоне одним куском, а старое место пометить, как неиспользуемое. Тогда данные, принадлежащие имеющемуся файлу, будет не отличить по адресу от данных вновь создаваемого файла.</p>
<p>Причем, драйвер может сначала записать метаданные в соответствующие поля root-сектора, а потом начать писать данные самого файла, а может наоборот &mdash; начать с данных файла, а закончить метаданными. Это вызывает сомнения в возможности определения принадлежности данных определенному файлу по адресу записи в зоне root-сектора, ибо может быть поздно идентифицировать: всё уже передано на запись.</p>
<p>Для исследования этого вопроса понадобится еще один файл и кое-какие изменения, связанные с его введением.</p>
<h2 id="_3">Изготовление файла из массива в <abbr title="Оперативное Запоминающее Устройство, оперативная память">ОЗУ</abbr></h2>
<p>Файл будет связан с массивом, находящимся в <abbr title="Оперативное Запоминающее Устройство, оперативная память">ОЗУ</abbr>. В этот массив можно будет записывать всякого рода данные в процессе имитации FAT32 и надеяться, что анализ этих данных как-нибудь поможет.</p>
<p>Для начала хочу добавить переменную-флаг, разрешающую определенные действия. Управляться она должна с кнопок устройства. Может пригодиться для того, чтобы не замусоривать файл-массив служебной информацией, например, данными о записи, когда я еще ничего записывать не начал. А может, и не пригодится&hellip; Но заодно поправлю кривоватую работу с имеющимися глобальными переменными.</p>
<p>Ввожу новый файл <code>common.h</code> следующего содержания:</p>
<div class="highlight"><pre><span class="cp">#ifndef _COMMON_H_</span>
<span class="cp">#define _COMMON_H_</span>
    <span class="cm">/* variables */</span>
        <span class="k">extern</span> <span class="kt">uint8_t</span> <span class="n">data_PC</span><span class="p">;</span>
        <span class="k">extern</span> <span class="kt">uint8_t</span> <span class="n">data_device</span><span class="p">;</span>
        <span class="k">extern</span> <span class="kt">uint8_t</span> <span class="n">canDo</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// _COMMON_H_</span>
</pre></div>


<p>Здесь я объявляю уже используемые переменные <code>data_PC</code> и <code>data_device</code>, а также ввожу новую &mdash; упомянутый флаг &mdash; <code>canDo</code>.</p>
<p>В файле <code>Lib/fake_fs.c</code> добавляю <code>#include "../common.h"</code>, а из файла <code>Lib/fake_fs.c</code> удаляю строки</p>
<div class="highlight"><pre>    <span class="cm">/* variables */</span>
        <span class="k">extern</span> <span class="kt">uint8_t</span> <span class="n">data_PC</span><span class="p">;</span>
        <span class="k">extern</span> <span class="kt">uint8_t</span> <span class="n">data_device</span><span class="p">;</span>
</pre></div>


<p>В файле <code>MassStorage.h</code> удаляю строки</p>
<div class="highlight"><pre>    <span class="kt">uint8_t</span> <span class="n">data_PC</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">data_device</span><span class="p">;</span>
</pre></div>


<p>В файле <code>MassStorage.c</code> также добавляю <code>#include "common.h"</code>, а также определяю эти переменные:</p>
<div class="highlight"><pre><span class="kt">uint8_t</span> <span class="n">data_PC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="n">data_device</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="n">canDo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>Теперь надо добавить переключение флага <code>canDo</code>. В блоке обработки действий по срабатыванию таймера перед строкой <code>bt_old = bt_now;</code> добавляю</p>
<div class="highlight"><pre>                <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">canDo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">canDo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;}</span>
</pre></div>


<p>А в блоке <code>switch (mode_out)</code> в <code>case 1</code> закрою комментарием <code>PORTD = bt_now;</code>, зато добавлю <code>PORTD = canDo;</code>, чтобы иметь возможность убедиться, что флаг разрешения некоторой операции действительно включается второй снизу кнопкой и выключается нижней.</p>
<p>Теперь буду делать файл. Сперва заготовка. В <code>MassStorage.c</code> среди определений переменных добавлю <code>uint8_t data[128] = { 0 };</code>, в <code>common.c</code> дописываю <code>extern uint8_t data[128];</code>. В результате готова структура данных, которая будет файлом.</p>
<p>Надо внедрить эту заготовку в файловую систему, это уже в файле <code>LIB/fake_fs.c</code>. В таблице файлов после записи, соответствующей файлу &laquo;USERDATA&raquo;, добавляю новую запись:</p>
<div class="highlight"><pre>    <span class="p">{</span><span class="s">&quot;DATA    BIN&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_DATA</span><span class="p">,</span> <span class="n">readData</span><span class="p">},</span>
</pre></div>


<p>Соответственно, в подходящем месте (где уже лежат подобные штуки) надо обозначить размер файла и объявить функцию чтения:</p>
<div class="highlight"><pre><span class="cp">#define SIZE_OF_DATA    128</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readData</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>


<p>А потом определить эту функцию:</p>
<div class="highlight"><pre><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readData</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SIZE_OF_DATA</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_DATA</span><span class="p">)</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SIZE_OF_DATA</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Функция похожа на те, которые позволяли читать текстовые константы из памяти программ, но читает из <abbr title="Оперативное Запоминающее Устройство, оперативная память">ОЗУ</abbr> (из заданного массива) двоичные данные. Теперь можно сформировать, допустим, массив адресов, которые устройство получает в командах записи, и потом прочитать этот массив в виде файла <code>data.bin</code>. Массив, правда, небольшой, но уж сколько есть&hellip; Оперативка на данный момент занята уже наполовину, то есть, массив можно еще увеличить, но пока не буду, погляжу по обстоятельствам.</p>
<h2 id="_4">Использование полученного файла</h2>
<p>Для начала хочу посмотреть, какие адреса передаются в устройство вместе с командами записи. В файле <code>fake_fs.c</code> есть функция, вызываемая при обработке записи: <code>WriteBlocks</code>. В ней, в свою очередь, вызывается функция <code>process_data</code>, которой в параметрах передается текущая пачка из 16 байтов, адрес сектора (<code>BlockAddress</code>) и смещение пачки в секторе (<code>BytesInBlockDiv16</code>). Сейчас эта функция не делает ничего полезного, а только перебрасывает первый байт принимаемых данных в глобальную переменную <code>data_PC</code>, это было нужно для демонстрации взаимного обмена &laquo;<abbr title="Персональный компьютер">ПК</abbr> &ndash; устройство&raquo;. Оставлю эти четыре строчки, а ниже добавлю следующее:</p>
<div class="highlight"><pre>    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">BlockAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
            <span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">BlockAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
            <span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">BlockAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
            <span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">BlockAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>То есть, при получении запроса на чтение первого байта (<code>BytesInBlockDiv16 == 0</code>) какого-либо сектора в массив <code>data</code> записывается адрес этого сектора. И так до тех про, пока данные помещаются в массив.</p>
<h2 id="windows-7">Запись в Windows 7</h2>
<p>Откомпилировал, прошил, запустил. Дальше пробую записывать файл на устройство, изменять существующий на устройстве файл и удалять, а после &mdash; читать файл <code>DATA.BIN</code>. Разумеется, с перезапуском устройства перед каждой пробой.</p>
<p>Для анализа пригодится табличка с распределением &laquo;данных&raquo; по адресам:</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="left">Данные</th>
<th align="center">Размер<br>(в секторах)</th>
<th align="center">Сектор начала (dec)</th>
<th align="center">Занимаемые сектора (hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr><br>(boot sector)</td>
<td align="center">1</td>
<td align="center">62</td>
<td align="center">0x3E</td>
</tr>
<tr>
<td align="left">FAT1</td>
<td align="center">8</td>
<td align="center">63</td>
<td align="center">0x3F .. 0x46</td>
</tr>
<tr>
<td align="left">FAT2</td>
<td align="center">8</td>
<td align="center">71</td>
<td align="center">0x47 .. 0x4E</td>
</tr>
<tr>
<td align="left">root directory<br>(корневой каталог)</td>
<td align="center">8</td>
<td align="center">79</td>
<td align="center">0x4F .. 0x56</td>
</tr>
<tr>
<td align="left">KEY_FILE.TXT</td>
<td align="center">8</td>
<td align="center">87</td>
<td align="center">0x57 .. 0x5E</td>
</tr>
<tr>
<td align="left">README.TXT</td>
<td align="center">8</td>
<td align="center">95</td>
<td align="center">0x5F .. 0x66</td>
</tr>
<tr>
<td align="left">TESTFILE.TXT</td>
<td align="center">2048</td>
<td align="center">103</td>
<td align="center">0x67 .. 0x866</td>
</tr>
<tr>
<td align="left">USERDATA.TXT</td>
<td align="center">8</td>
<td align="center">2151</td>
<td align="center">0x867 .. 0x86E</td>
</tr>
<tr>
<td align="left">DATA.BIN</td>
<td align="center">8</td>
<td align="center">2159</td>
<td align="center">0x86F .. 0x876</td>
</tr>
<tr>
<td align="left">Чистое<br>пространство</td>
<td align="center">&mdash;</td>
<td align="center">2167</td>
<td align="center">0x877 &hellip;</td>
</tr>
</tbody>
</table>
<p>И вот что прочиталось из массива <code>data</code> в результате таких записей-стираний:</p>
<p>Если ничего не записывать, то в файле <code>DATA.BIN</code> остаются нули.</p>
<p>Запись пустого файла:</p>
<div class="highlight"><pre>00000000: 3e 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  &gt;...O...P...Q...
00000010: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000020: 56 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  V...O...P...Q...
00000030: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000040: 56 00 00 00 3f 00 00 00 47 00 00 00 3e 00 00 00  V...?...G...&gt;...
00000050: 3f 00 00 00 47 00 00 00 00 00 00 00 00 00 00 00  ?...G...........
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Видно, что сперва <abbr title="Операционная система">ОС</abbr> что-то пишет в <abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr>, потом в корневой каталог (зачем-то два раза), а потом в первые сектора обеих <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> (не знаю, зачем). Дальше имеющихся данных не пишет ничего, что логично: пустой файл занимает место только в каталоге.</p>
<p>Запись короткого текстового файла (с содержимым &laquo;12345&raquo;, хоть это и не принципиально):</p>
<div class="highlight"><pre>00000000: 3e 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  &gt;...O...P...Q...
00000010: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000020: 56 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  V...O...P...Q...
00000030: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000040: 56 00 00 00 3f 00 00 00 40 00 00 00 41 00 00 00  V...?...@...A...
00000050: 47 00 00 00 48 00 00 00 49 00 00 00 4f 00 00 00  G...H...I...O...
00000060: 50 00 00 00 51 00 00 00 52 00 00 00 53 00 00 00  P...Q...R...S...
00000070: 54 00 00 00 55 00 00 00 56 00 00 00 4f 00 00 00  T...U...V...O...
</pre></div>


<p>Опять же, операция начинается с записи в <abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr>, потом дважды в корневой каталог. Потом что-то пишется по три сектора в обе <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>, потом дважды в корневой каталог, а дальше &mdash; не знаю, массив кончился.</p>
<p>Замена текста в &laquo;блокноте&raquo; в файле <code>KEY_FILE.TXT</code> (на &laquo;dummy text&raquo;) с последующей записью и выходом:</p>
<div class="highlight"><pre>00000000: 3e 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  &gt;...O...P...Q...
00000010: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000020: 56 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  V...O...P...Q...
00000030: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000040: 56 00 00 00 57 00 00 00 00 00 00 00 00 00 00 00  V...W...........
00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Выполняется запись в <abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr>, дважды &mdash; в корневой каталог, затем один раз один сектор в области изменяемого файла.</p>
<p>Удаление этого же файла:</p>
<div class="highlight"><pre>00000000: 3e 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  &gt;...O...P...Q...
00000010: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000020: 56 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  V...O...P...Q...
00000030: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000040: 56 00 00 00 3f 00 00 00 47 00 00 00 3e 00 00 00  V...?...G...&gt;...
00000050: 3f 00 00 00 47 00 00 00 00 00 00 00 00 00 00 00  ?...G...........
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Начало &mdash; запись в <abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr> и дважды в корневой каталог &mdash; уже стало традиционным. Потом идет запись по одному сектору в каждую <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>, в <abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr> и снова по одному сектору в каждую <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>. В области данных файла ничего не пишется, что, впрочем, неудивительно.</p>
<p>Для примера еще редактирование файла <code>README.TXT</code>:</p>
<div class="highlight"><pre>00000000: 3e 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  &gt;...O...P...Q...
00000010: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000020: 56 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  V...O...P...Q...
00000030: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000040: 56 00 00 00 5f 00 00 00 00 00 00 00 00 00 00 00  V..._...........
00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Полностью идентично редактированию <code>KEY_FILE.TXT</code>, только последний адрес для записи соответствует первому сектору кластера файла <code>README.TXT</code>.</p>
<p>И редактирование <code>USERDATA.TXT</code>:</p>
<div class="highlight"><pre>00000000: 3e 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  &gt;...O...P...Q...
00000010: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000020: 56 00 00 00 4f 00 00 00 50 00 00 00 51 00 00 00  V...O...P...Q...
00000030: 52 00 00 00 53 00 00 00 54 00 00 00 55 00 00 00  R...S...T...U...
00000040: 56 00 00 00 67 08 00 00 00 00 00 00 00 00 00 00  V...g...........
00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Аналогично: отличается лишь последний адрес, соответствующий первому сектору кластера файла <code>USERDATA.TXT</code>.</p>
<p>На первый взгляд можно использовать редактирование имеющегося файла:  перехватывать данные, выдаваемые по адресу в области расположения файлов, и по этому самому адресу определять принадлежность определенному файлу.</p>
<h2 id="debian-8">Запись в Debian 8</h2>
<p>Теперь повторю эти операции &mdash; запись файла на устройство и изменение существующего с последующим чтением файла <code>DATA.BIN</code> &mdash; в Linux.</p>
<p>Если с &laquo;флэшкой&raquo; ничего не делать, а сразу после того, как она автоопределится в системе, считать <code>DATA.BIN</code>, то в нем, в отличие от Windows, будет записан первый байт: <code>0x3E</code>, то есть, система что-то сразу пишет в <abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr>.</p>
<p>Попробовал перебросить на устройство файл и получил тот же результат. Ну, я в курсе, что в Windows по умолчанию включена &laquo;безопасная запись&raquo;, при которой в конце записи на флэшку буфер записи сразу весь сбрасывается, а в Linux по умолчанию это дело, наоборот, отключено. Поэтому после записи даю еще и команду <code>sync</code>.</p>
<p>Вот что дает запись на устройство пустого файла:</p>
<div class="highlight"><pre>0000000: 3e 00 00 00 4f 00 00 00 4f 00 00 00 00 00 00 00  &gt;...O...O.......
0000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Всего лишь двойную запись в первый сектор корневого каталога. А вот запись короткого &mdash; &laquo;12345&raquo; &mdash; текстового файла:</p>
<div class="highlight"><pre>0000000: 3e 00 00 00 49 00 00 00 4f 00 00 00 41 00 00 00  &gt;...I...O...A...
0000010: 77 08 00 00 4f 00 00 00 00 00 00 00 00 00 00 00  w...O...........
0000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Непонятная запись в третий сектор кластера FAT2 (где лежит элемент, соответствующий первому кластеру свободной области), затем в начало корневого каталога, потом запись в тот же сектор FAT1, что и FAT2, следом запись в начало чистой области и еще раз в корневой каталог.</p>
<p>А вот реакция на редактирование файла <code>KEY_FILE.TXT</code>, то есть, замену его содержимого на &laquo;dummy text&raquo; в редакторе gedit (птому что он в Debian по умолчанию) с сохранением ихменений и выходом:</p>
<div class="highlight"><pre>0000000: 3e 00 00 00 77 08 00 00 4f 00 00 00 49 00 00 00  &gt;...w...O...I...
0000010: 41 00 00 00 47 00 00 00 4f 00 00 00 3f 00 00 00  A...G...O...?...
0000020: 4f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  O...............
0000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Сначала идет запись в начало чистой области! И только потом документирование этого дела в <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> 1 и 2, а также в корневом каталоге. Отзыв на редактирование <code>README.TXT</code> абсолютно аналогичен, байт в байт. Чуть-чуть отличается редактирование файла <code>USERDATA.TXT</code>:</p>
<div class="highlight"><pre>0000000: 3e 00 00 00 77 08 00 00 4f 00 00 00 49 00 00 00  &gt;...w...O...I...
0000010: 41 00 00 00 41 00 00 00 49 00 00 00 4f 00 00 00  A...A...I...O...
0000020: 4f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  O...............
0000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Не знаю, чем вызвано это отличие и не очень хочу сейчас исследовать этот момент, главное в том, что сперва измененный файл пишется в чистую область, и только потом появляются адреса и данные с информацией о том, что это за файл был уже записан и поезд ушел.</p>
<p>К слову, попробовал отредактировать <code>KEY_FILE.TXT</code> и сохранить, потом прочитать <code>DATA.BIN</code> без команды <code>sync</code>, эффект тот же, что и с командой <code>sync</code>, а вот <code>USERDATA.TXT</code> без <code>sync</code> дает эффект чуть короче, почему-то:</p>
<div class="highlight"><pre>0000000: 3e 00 00 00 77 08 00 00 4f 00 00 00 49 00 00 00  &gt;...w...O...I...
0000010: 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  A...............
0000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Впрочем, это уже не важно. Важно то, что в Linux не обойтись информацией о принадлежности данных какому-либо файлу, содержащейся только в командах записи.</p>
<p>К слову, текстовый вывод бинарного файла добывался командой</p>
<div class="highlight"><pre>xxd -g1 /media/vfat/DATA.BIN
</pre></div>


<p>в Linux и ею же, но с другим путем к &laquo;флэшке&raquo; в Cygwin</p>
<h2 id="_5">Данные в команде записи</h2>
<p>Жаль, что задача по результатам &laquo;исследований&raquo; несколько усложнилась. Но хотелось бы все же посмотреть, а что же пишется-то?</p>
<p>Однозначно можно сказать одно: в обеих системах данные, которые записываются непосредственно в файл, идут по адресам, начиная с области файлов, то есть, больше или равно адреса файла <code>KEY_FILE.TXT</code>, который идет первым в файловой таблице.</p>
<p>Вношу небольшие изменения в функцию обработки &laquo;записанных&raquo; данных <code>process_data</code>:</p>
<div class="highlight"><pre>    <span class="cm">/*</span>
<span class="cm">    if (BytesInBlockDiv16 == 0) {</span>
<span class="cm">        if (ind &lt; 128) {</span>
<span class="cm">            data[ind++] = (BlockAddress &gt;&gt; 0) &amp; 0xFF;</span>
<span class="cm">            data[ind++] = (BlockAddress &gt;&gt; 8) &amp; 0xFF;</span>
<span class="cm">            data[ind++] = (BlockAddress &gt;&gt; 16) &amp; 0xFF;</span>
<span class="cm">            data[ind++] = (BlockAddress &gt;&gt; 24) &amp; 0xFF;</span>
<span class="cm">        }</span>
<span class="cm">    }</span>
<span class="cm">    */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">BlockAddress</span> <span class="o">&gt;=</span> <span class="mh">0x57</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>То есть, закрыл вывод адресов секторов, зато вставил вывод непосредственно данных, подряд. Откомпилировал, прошил, запустил. На устройстве открыл файл <code>KEY_FILE.TXT</code> и заменил его содержимое следующим текстом:</p>
<div class="highlight"><pre>this is the dummy text
lorem ipsum et cetera
</pre></div>


<p>Затем посмотрел, что получилось в файле <code>DATA.BIN</code>:</p>
<div class="highlight"><pre>00000000: 74 68 69 73 20 69 73 20 74 68 65 20 64 75 6d 6d  this is the dumm
00000010: 79 20 74 65 78 74 0d 0a 6c 6f 72 65 6d 20 69 70  y text..lorem ip
00000020: 73 75 6d 20 65 74 20 63 65 74 65 72 61 00 00 00  sum et cetera...
00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Таким образом, получили в команде записи именно те данные, какие и записывали. Очень хорошо. Только надо учитывать, что запись не останавливается с концом файла, а продолжается нулями до конца сектора.</p>
<h2 id="_6">Итого</h2>
<p>Во-первых, запись на устройство с фиктивной <abbr title="Файловая система">ФС</abbr> FAT32 вполне возможна.</p>
<p>Во-вторых, разные <abbr title="Операционная система">ОС</abbr> при записи данных на флэшку поступают по-разному.</p>
<p>Таким образом, если требуется использовать запись для преобразования некоторым образом &laquo;записываемых&raquo; данных, то в простейшем случае можно перехватывать байтв, которые пишутся в область файлов, что лежит дальше корневого каталога.</p>
<p>Если требуется идентификация данных &mdash; определение их принадлежности определенному файлу &mdash; то здесь начинаются трудности. В Windows 7 эту задачу можно решить, перехватывая попытки перезаписи данных по адресам имеющихся файлов, но это не пройдет в Linux и не факт, что пройдет в других Windows.</p>
<p>Можно решить задачу идентификации данных, если предварительно читать специальный файл (обрабатывая эту операцию чтения и получая данные о назначении массива, который пойдет с командой записи), а потом писать куда угодно. Например, получить handle файла при помощи функции <code>CreateFile()</code>, затем сперва прочитать его первый сектор с помощью <code>ReadFile()</code>, затем посредством <code>WriteFile()</code> зпаписать, используя все тот же handle.</p>
<p>Попробовал исследовать операции чтения, которые выполняются непосредственно перед записью существующего файла, но это, как и ожидалось, не результативно. Если открыть файл (<code>CreateFile()</code>) и только записывать в него, то операции чтения в этот момент не выполняются, а операции записи сами по себе не информативны с точки зрения назначения данных, по крайней мере, в Linux.</p>
<p>Еще можно принять записываемые данные и адреса обращения к служебным сектрам в некоторый буфер, а уже потом анализировать назначение этих данных и использовать соответствующим образом. Это увеличит скорость &laquo;записи&raquo;, однако потребует немало памяти под буфер. В моем случае это очень маленький объем, сейчас осталось около 230 байтов оперативки, с учетом масива <code>data</code> &mdash; около 350. Так что ничего полезного не получится, порции будут маловаты.</p>
<p>Далее попробую использовать вариант с последовательными чтением-записью.</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "usb-polygon-15.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>