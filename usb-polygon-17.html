<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-17: Подключение экрана от Nokia 3410</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">22</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/nishchebrod.html">
              нищеброд
                <span class="badge">5</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pokhodnoe.html">
              походное
                <span class="badge">5</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/samodelki.html">
              самоделки
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Чт 03 Май 2018</h4>
    <article>
      <h1>USB-polygon-17: Подключение экрана от Nokia 3410</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Введение</a></li>
<li><a href="#_2">Подключение экрана к устройству</a></li>
<li><a href="#_3">Инициализация экрана, вывод изображения</a><ul>
<li><a href="#_4">Теория</a><ul>
<li><a href="#_5">Набор команд</a></li>
<li><a href="#_6">Адресация и набор команд</a></li>
<li><a href="#_7">Инициализация</a></li>
</ul>
</li>
<li><a href="#_8">Практика</a></li>
</ul>
</li>
<li><a href="#spi">Доработка под аппаратный SPI</a></li>
<li><a href="#_9">Передача файла экрану</a></li>
<li><a href="#_10">Заключение</a></li>
</ul>
</div>
<h2 id="_1">Введение</h2>
<p>К настоящему моменту описываемое в цикле статей устройство определяется операционными системами под видом флэшки с FAT32 на борту, якобы содержит некоторый набор файлов, поддерживает операции чтения и записи.</p>
<p>При этом центральный элемент устройства &mdash; AT90USB162 &mdash; имеет аппаратные возможности передачи информации по некоторым протоколам, например, SPI. Значит, есть возможность &laquo;записать&raquo; файл на устройство таким образом, что данные уйдут на передачу по выбранному порту.</p>
<p>В качестве приемника данных выбран экран от мобильного телефона Nokia 3410. Во-первых, потому что он есть. Во-вторых, потому что он должен принимать данные по SPI, так как укомплектован соответствующим контроллером. В-третьих, потому что мне интересно попробовать вывести произвольную информацию на <abbr title="жидкокристаллический">ЖК</abbr>-дисплей. В-четвертых, потому что мне хочется использовать <abbr title="жидкокристаллический">ЖК</abbr>-дисплей в некоей самоделке, а для этого надо отладить работу с ним.</p>
<h2 id="_2">Подключение экрана к устройству</h2>
<p>Надо сказать, что сперва я пытался подключить экран от Nokia 1100, но получилось только зажечь светодиоды подсветки. Телефон был взят у друзей, сломанный напрочь, поэтому, возможно, его экран и в самом деле неработоспособен, а не я накосячил. По крайней мере, при попытках его подключения ни один пиксел даже не пискнул, а при некоторых ошибках с 3410 экран хотя бы местами помигивал полосочками.</p>
<p>Перед подключением порылся в интернетах в поисках распиновки и системы команд контроллера. И вот самое полезное, что нашел:</p>
<ol>
<li>Страничка <a href="http://serdisplib.sourceforge.net/ser/pcd8544.html">pcd8544-based displays</a>, на которой я узнал, что используемый дисплеем контроллер называется pcd8544, а значит, можно найти хоть какую-то документацию на него, типа datasheet в pdf. Кроме того, там приведена распиновка экрана, смонтированного в рамке и замечательно расписаны особенности подключения, правда, с упором на подключение к LPT-порту <abbr title="Персональный компьютер">ПК</abbr>.</li>
<li><a href="http://www.aterlux.ru/article/pcd8544">Страничка на сайте Д. Погребняка</a>, на которой кроме описания подключения к контроллеру (и без того несложного) есть примеры кода для общения контроллера с экраном. Когда у меня с первого раза не получилось, я сверил свой код с приведенным на этой страничке и понял, что дело не в программе &mdash; код практически совпадал.</li>
<li>Ныне недоступная <a href="http://mp3vkarmane.nm.ru/lcd.html">страничка</a>, найденная на <a href="http://www.rlocman.ru/shem/shem-cache.html?di=18881">РадиоЛоцмане</a>, где я нашел подтверждение собственным практическим изысканиям, например, несоответствию числа точек по горизонтали и вертикали ранее найденным сайтам и описанию контроллера.</li>
</ol>
<p>Стало быть, если повернуть рамку с экраном разъемом к себе, то слева направо контакты будут такие:</p>
<ol>
<li>VDD &mdash; питание, 2,7..3,3 В</li>
<li>SCLK &mdash; синхронизация данных</li>
<li>SI &mdash; вход данных (в datasheet &mdash; SDIN)</li>
<li>D/C &mdash; данные/команда (&laquo;1&raquo; &ndash; данные)</li>
<li>CS &mdash; разрешение приема данных (выбор кристалла, в datasheet &mdash; SCE)</li>
<li>GND &mdash; корпус, земля, общий</li>
<li>Vout &mdash; контрастность, подключается к общему через конденсатор</li>
<li>RES &mdash; сброс, активен нулем, для работы должен быть в &laquo;1&raquo;</li>
</ol>
<p>Припаял к ним провода МГТФ. С имеющимся в наличии плоским шлейфом не сложилось: очень уж легкоплавкая изоляция у него, а паяльник у меня так себе. Получилось так:</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/17/connect_marked.jpg" title="Распайка экрана"><img alt="Распайка экрана" src="http://romeogolf.github.io/images/usb-polygon/17/preview/connect_marked_small.jpg" title="Распайка экрана"></a></p>
<p>Через отверстия в панели клавиатуры привязал жгут проводов нитками, и дополнительно (чтобы не шатались вправо-влево) подклеил синей (это важно!) изолентой к задней стороне экрана.</p>
<p>Информационные выводы подключил к порту B, так как на этом порту есть выводы, альтернативное назначение которых &mdash; аппаратный SPI: 2 контакт подсоединил к площадке разряда 1, 3 контакт &mdash; к площадке 2, 5 контакт &mdash; к площадке 0, то есть SCLK, MOSI и SS SPI-порта соответственно (если, конечно, активировать SPI-интерфейс). 4 контакт (D/C) прицепил к площадке 5, 8 контакт (сброс) &mdash; к площадке 4.</p>
<p>6 контакт (GND) пошел напрямую на корпус, который на устройстве занимает практически всю поверхность той стороны, где светодиоды.</p>
<p>7 контакт (Vout) посадил на корпус через электролит, какой нашел. А нашел как раз подходящий: 4,7 мкФ, 6,3 В.</p>
<p>1 контакт &mdash; питание &mdash; поначалу подпаял к площадке &laquo;+3,3&raquo;, но оказалось, что напрасно. В datasheet на микроконтроллер я не нашел допустимой нагрузки на выход встроенного стабилизатора 3,3 В. Там лишь сказано, что этот стабилизатор может использоваться для питания внешних устройств и даже самого контроллера:</p>
<blockquote>
<p>The AT90USB82/162 product includes an internal 5V to 3.3V regulator that allows to supply the USB pad (see Figure 7-1.) and, depending on the application, external components or even the microcontroller itself</p>
</blockquote>
<p>Опять же, в datasheet на pcd8544 указано, что его потребление меньше миллиампера, однако я нигде не нашел потребления экрана с контроллером в сборе.</p>
<p>В общем, в результате подключения таким образом я видел лишь отдельные подмигивания некоторыми пикселами и горизонтальными полосками пикселов на экране после подачи питания или нажатия кнопки сброса, несмотря на то, что код инициализации и вывода изображения на экран практически соответствовал коду, который, по заявлениям его авторов, вполне рабочий.</p>
<p>Предположив, что дело все-таки в питании, я стрельнул у товарища лишний стабилизатор LM317 (точнее, какую-то ненужную и поломанную платку под разбор) и запитал экран от площадки &laquo;+5&raquo; (она подключена прямо к выводу питания USB) через этот самый стабилизатор. Подключал с учетом цоколевки LM317:</p>
<p><img alt="Цоколевка LM317" src="http://romeogolf.github.io/images/usb-polygon/17/lm-2.png" title="Цоколевка LM317"></p>
<p>по такой типовой схеме:</p>
<p><img alt="Схема LM317" src="http://romeogolf.github.io/images/usb-polygon/17/lm-1.png" title="Схема LM317"></p>
<p>с небольшими изменениями. Верхний резистор R1 нашел почти нужный &mdash; 220 Ом, нижний R2 рассчитал (с учетом опорного напряжения 1,2 В &mdash; в соответствии с datasheet) и взял ближайший к расчетному из имеющихся &mdash; 332 Ома. Получил на выходе примерно 3,2 В. Емкость на выходе C2 поставил 4,7 мкФ, а по входу C1 нахально не стал ставить совсем, предполагая, что USB-питание и так вполне стабильное. То есть, когда (если) буду разводить плату для подключения экрана &mdash; обязательно поставлю, а пока обойдусь.</p>
<p>И теперь все более-менее заработало. А выглядит это так:</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/17/all.jpg" title="Подключение экрана"><img alt="Подключение экрана" src="http://romeogolf.github.io/images/usb-polygon/17/preview/all_small.jpg" title="Подключение экрана"></a></p>
<h2 id="_3">Инициализация экрана, вывод изображения</h2>
<h3 id="_4">Теория</h3>
<p>Основной источник информации о контроллере экрана и способах управления им &mdash; &laquo;DATA SHEET PCD8544 48 x 84 pixels matrix LCD controller/driver&raquo;, хотя он немножко врет. В моем случае, для экрана от Nokia 3410, размер экрана (как выяснилось опытным путем и было подтверждено третьим источником) &mdash; 96 &times; 65 точек, а не 84 &times; 48.</p>
<p>Из описания PCD8544 ясно, что обмен с ним происходит по последовательному интерфейсу, практически идентичному SPI slave в режиме 0, только в одном направлении. Правда, в описании нигде не встречается буквосочетание &laquo;SPI&raquo;. Ну и ладно, главное, что данные идут по 8 разрядов, старшим вперед, защелкиваются по фронту сигнала синхронизации, воспринимаются в случае, если сигнал выбора CS в нуле.</p>
<p>Если сигнал D/C в нуле, то переданный экрану байт интерпретируется, как команда, иначе &mdash; записывается в &laquo;видеопамять&raquo;, в ОЗУ, из которого берутся данные для отображения на экране.</p>
<h4 id="_5">Набор команд</h4>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">Команда</th>
<th align="center">D/C</th>
<th>Данные, 8 разрядов: DB7 .. DB0</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">NOP</td>
<td align="center">0</td>
<td>0 0 0 0 0 0 0 0</td>
<td>нет операции</td>
</tr>
<tr>
<td align="center">Набор команд</td>
<td align="center">0</td>
<td>0 0 1 0 0 PD V H</td>
<td>управляет потреблением, адресацией и расширенным набором команд</td>
</tr>
<tr>
<td align="center">Запись данных</td>
<td align="center">1</td>
<td>D<sub>7</sub> D<sub>6</sub> D<sub>5</sub> D<sub>4</sub> D<sub>3</sub> D<sub>2</sub> D<sub>1</sub> D<sub>0</sub></td>
<td>записывает данные в память экрана</td>
</tr>
<tr>
<td align="center">H = 0</td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">Резерв</td>
<td align="center">0</td>
<td>0 0 0 0 0 1 X X</td>
<td>не используется</td>
</tr>
<tr>
<td align="center">Управление экраном</td>
<td align="center">0</td>
<td>0 0 0 0 1 D 0 E</td>
<td>устанавливает конфигурацию экрана</td>
</tr>
<tr>
<td align="center">Резерв</td>
<td align="center">0</td>
<td>0 0 0 1 X X X X</td>
<td>не используется</td>
</tr>
<tr>
<td align="center">Установка Y-адреса</td>
<td align="center">0</td>
<td>0 1 0 0 0 Y<sub>2</sub> Y<sub>1</sub> Y<sub>0</sub></td>
<td>устанавливает позицию по Y</td>
</tr>
<tr>
<td align="center">Установка X-адреса</td>
<td align="center">0</td>
<td>1 X<sub>6</sub> X<sub>5</sub> X<sub>4</sub> X<sub>3</sub> X<sub>2</sub> X<sub>1</sub> X<sub>0</sub></td>
<td>устанавливает позицию по X</td>
</tr>
<tr>
<td align="center">H = 1</td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">Резерв</td>
<td align="center">0</td>
<td>0 0 0 0 0 0 0 1</td>
<td>не используется</td>
</tr>
<tr>
<td align="center">Резерв</td>
<td align="center">0</td>
<td>0 0 0 0 0 0 1 X</td>
<td>не используется</td>
</tr>
<tr>
<td align="center">Управление температурой</td>
<td align="center">0</td>
<td>0 0 0 0 0 1 TC<sub>1</sub> TC<sub>0</sub></td>
<td>устанавливает температурный коэффициент (TCx)</td>
</tr>
<tr>
<td align="center">Резерв</td>
<td align="center">0</td>
<td>0 0 0 0 1 X X X</td>
<td>не используется</td>
</tr>
<tr>
<td align="center">Система смещения</td>
<td align="center">0</td>
<td>0 0 0 1 0 BS<sub>2</sub> BS<sub>1</sub> BS<sub>0</sub></td>
<td>устанавливает смещение (BSx)</td>
</tr>
<tr>
<td align="center">Резерв</td>
<td align="center">0</td>
<td>0 1 X X X X X X</td>
<td>не используется</td>
</tr>
<tr>
<td align="center">Установка Vop</td>
<td align="center">0</td>
<td>1 V<sub>OP6</sub> V<sub>OP5</sub> V<sub>OP4</sub> V<sub>OP3</sub> V<sub>OP2</sub> V<sub>OP1</sub> V<sub>OP0</sub></td>
<td>записывает Vop в регистр</td>
</tr>
</tbody>
</table>
<p>Описание используемых символов:</p>
<p>Биты PD, V и H:</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th>Бит</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>PD</td>
<td>кристалл активен</td>
<td>кристалл в режиме пониженного потребления</td>
</tr>
<tr>
<td>V</td>
<td>горизонтальная адресация</td>
<td>вертикальная адресация</td>
</tr>
<tr>
<td>H</td>
<td>использовать основной набор команд</td>
<td>использовать расширенный набор команд</td>
</tr>
</tbody>
</table>
<p>Подробнее об адресации и наборах команд чуть ниже.</p>
<p>Биты D и E:</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">Значение</th>
<th align="center">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">00</td>
<td align="center">экран пуст</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">нормальный режим</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">все сегменты экрана включены</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">инверсный видеорежим</td>
</tr>
</tbody>
</table>
<p>Режимы &laquo;00&raquo;  и &laquo;01&raquo; действительно очищают экран или зажигают все пикселы экрана. Вот только проделывают это данные режимы с самим экраном, а не с видеопамятью. То есть, после возвращения в нормальный или инверсный режимы мы получим то же изображение, что и до входа в режимы выключения/включения. Поэтому использовать режим &laquo;00&raquo; для стирания экрана не получится. Чтобы стереть изображение, нужно сформировать картинку в видеопамяти, содержащую одни нули, то есть, пройти по всем адресам (можно с автоматическим приращением адреса) и записать нули. Инверсный режим, как нетрудно догадаться или проверить, выводит данные белым по черному.</p>
<p>Биты TC1 и TC0:</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">Значение</th>
<th align="center">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">00</td>
<td align="center">V<sub>LCD</sub> температурный коэффициент 0</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">V<sub>LCD</sub> температурный коэффициент 1</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">V<sub>LCD</sub> температурный коэффициент 2</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">V<sub>LCD</sub> температурный коэффициент 3</td>
</tr>
</tbody>
</table>
<h4 id="_6">Адресация и набор команд</h4>
<p>Экран имеет размер 96 точек по горизонтали и 65 по вертикали. Этот массив разделен на банки &mdash; горизонтальные полосы по 8 точек высотой.</p>
<p>Строго говоря, на банки разделено ОЗУ экрана, причем, каждый разряд каждой ячейки памяти соответствует некоторому пикселу на экране. Поэтому, говоря о банках памяти в данном случае не будет большой ошибкой сказать и о банках экрана.</p>
<p>Таких банков, как несложно подсчитать, 8,125. Конечно, дробного числа банков быть не может. Банков 9, но самый нижний банк имеет не 8 полосок, а только одну.</p>
<p>Таким образом, за один раз на экран можно вывести 8 точек &mdash; ни больше, ни меньше, в виде вертикальной полоски. Чтобы изменить состояние одной точки, нужно знать состояние остальных точек в данной горизонтальной позиции данного вертикального банка, чтобы вывести их заново в прежнем виде.</p>
<p>Младший разряд байта данных отвечает за самую верхнюю точку вертикальной полоски, старший &mdash; за нижнюю. В девятом банке можно пользоваться только младшим битом: остальных пикселов там нет.</p>
<p>Стало быть, нужно сперва в режиме команд задать номер банка и номер позиции в нем (требуется две команды), затем вывести байт в режиме данных. Но для вывода порции байтов не нужно задавать адрес каждый раз, одна из координат будет увеличиваться автоматически в зависимости от режима адресации.</p>
<p>Команда, которая задает набор команд &mdash; расширенный или обычный &mdash; также задает режим энергопотребления и режим адресации. Режим пониженного потребления пока неинтересен. Режим адресации определяет, какая координата будет наращиваться автоматически при вводе новых данных. При режиме горизонтальной адресации следующий байт будет выводиться в этом же горизонтальном банке на одну позицию правее. При достижении последней позиции в банке байт будет выведен в первую позицию следующего банка. Этот вариант мне кажется удобнее вертикальной адресации, следовательно, команда включения расширенного набора команд будет <code>0x21</code>, а обычного &mdash; <code>0x20</code>.</p>
<p>В обычном режиме можно задать позицию выводимых на экран данных и режим экрана, в расширенном &mdash; прочие параметры.</p>
<h4 id="_7">Инициализация</h4>
<p>Datasheet предупреждает, что неправильный сброс может повредить контроллер, а импульс сброса &laquo;Reset&raquo; нужно использовать обязательно. В результате обнуляются все внутренние регистры, кроме видеопамяти.</p>
<p>С параметрами импульса Reset в документе как-то напутано. Обозначения в таблице на странице 20 в строчках, ссылающихся на рисунок 16, не стыкуются с этим самым рисунком 16. Но, насколько я понял, при включении Reset может быть в единице (но может и сразу в нуле), максимум через 30 мс должен опуститься в ноль на минимум 100 нс.</p>
<p>После сброса контроллер экрана находится в режиме пониженного потребления, с горизонтальной адресацией, адрес выдаваемых байтов &mdash; верхний левый угол (банк 0, Х тоже 0), в общем, все по нулям, кроме бита PD.</p>
<p>Из-за зависимости вязкости жидких кристаллов от температуры управляющее напряжение V<sub>LCD</sub> должно увеличиваться при низких температурах для достижения оптимального контраста. Это делается при помощи битов TC<sub>1</sub> и TC<sub>0</sub>. Прямого указания в документе не нашел, но похоже, в контроллере есть термодатчик, который устанавливает напряжение в зависимости от заданного V<sub>LCD</sub>, температурного коэффициента и температуры. Предположение о наличии термодатчика косвенно подтверждается наличием такого в экране от Nokia 1100, где его показания даже можно прочитать (там SPI двунаправленный).</p>
<p>Однако заморачиваться с температурным коэффициентом я не хочу: это может быть важно при использовании экрана при разных температурах, а я из комнаты выносить не собираюсь, хватит и нулевого значения.</p>
<p>Теперь о системе смещения. Ячейки <abbr title="жидкокристаллический">ЖК</abbr>-экрана должны управляться переменным напряжением, постоянное может их испортить. Для этого в матричной структуре ячеек на каждую подведены, скажем так, провода рядов и колонок, напряжение на которых меняется от кадра к кадру. Значения напряжений выбираются из определенного набора &mdash; шесть штук с определенным соотношением между ними:</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">Обозначение</th>
<th align="center">Напряжение смещения</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">V1</td>
<td align="center">V<sub>LCD</sub></td>
</tr>
<tr>
<td align="center">V2</td>
<td align="center">(n + 3) / (n + 4)</td>
</tr>
<tr>
<td align="center">V3</td>
<td align="center">(n + 2) / (n + 4)</td>
</tr>
<tr>
<td align="center">V4</td>
<td align="center">2 / (n + 4)</td>
</tr>
<tr>
<td align="center">V5</td>
<td align="center">1 / (n + 4)</td>
</tr>
<tr>
<td align="center">V6</td>
<td align="center">V<sub>SS</sub></td>
</tr>
</tbody>
</table>
<p>Здесь n выбирается исходя из скорости переключения:</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">BS<sub>1</sub></th>
<th align="center">BS<sub>2</sub></th>
<th align="center">BS<sub>3</sub></th>
<th align="center">n</th>
<th align="center">Рекомендуемая<br>скорость<br>переключения</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">7</td>
<td align="center">1 : 100</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">6</td>
<td align="center">1 : 80</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">1 : 65</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">1 : 48</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">1 : 40 / 1 : 34</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1 : 24</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1 : 18 / 1 : 16</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1 : 10 / 1 : 9 / 1 : 8</td>
</tr>
</tbody>
</table>
<p>В datasheet  есть и формула пересчета n исходя из скорости переключения, но она вполне соответствует данной таблице. А скорость переключения в datasheet указана 1 : 48, и при этом рядов пикселов тоже 48. Что-то мне подсказывает, что это неспроста. С учетом того, что у Nokia 3410 65 рядов, сильно подозреваю, что и mux rate тоже должно быть 1 : 65, тогда n = 5, а не 4, как рекомендовано в документе. Тогда команда для установки напряжения смещения будет <code>0x12</code>.</p>
<p>Раздел об установке значения V<sub>OP</sub> вообще ввел в легкий ступор обилием параметров, которые неизвестно где брать.</p>
<p>Там рассказывается, что действующее напряжение V<sub>LCD</sub> устанавливается программно в зависимости от выбранного материала жидких кристаллов. Устанавливается при помощи V<sub>OP</sub> по формуле</p>
<p>V<sub>LCD</sub> = a + (V<sub>OP</sub> &middot; b),</p>
<p>где a = 3,06; b = 0,06. Допустим, но какое следует выставить V<sub>OP</sub>? Далее приведена формула для скорости переключения 1:48 (формула 2 в разделе 8.9), в результате которой получается, что</p>
<p>V<sub>LCD</sub> = 6,06 &middot; V<sub>th</sub>,</p>
<p>где V<sub>th</sub> &mdash; пороговое напряжение используемого материала жидких кристаллов. Где его взять &mdash; неизвестно. Тогда я предположил, что в datasheet данные как-то между собой связаны, а в используемом ниже примере V<sub>OP</sub> установлено в значение &laquo;16&raquo;. Тогда V<sub>LCD</sub> получается равным 4,02. Отсюда V<sub>th</sub> получилось 0,(6633). Предполагая, что материалы в <abbr title="жидкокристаллический">ЖК</abbr>-экранах, где используется этот контроллер, сильно не отличаются (то есть, это пороговое напряжение можно использовать), а также предполагая скорость переключения Nokia 3410 равным 1:65, я пересчитываю V<sub>OP</sub> и получаю 28,8. Округляю до 29. Тогда команду установки V<sub>OP</sub> можно записать как <code>0x80 | 29</code>.</p>
<p>Забегая вперед отмечу, что попробовал свои расчетные параметры, параметры из примера в datasheet и параметры с упомянутой выше <a href="http://www.aterlux.ru/article/pcd8544#__h2_7">странички на сайте Д. Погребняка</a>, но принципиальной разницы не заметил. По крайней мере, в комнатных условиях. Возможно, при перепаде температур и попытке высокоскоростной (насколько это возможно) смены кадров какие-то отличия могут проявиться.</p>
<h3 id="_8">Практика</h3>
<p>Была у меня совсем неудачная попытка подключить экран от Nokia 1100, и остались от этой попытки кое-какие наработки. Тот экран отличался 9-битным SPI, то есть, признак D/C передавался не отдельным проводом, а старшим разрядом в посылке данных. Таким образом, было 2 варианта вывода данных: или реализовать SPI полностью программно, или отключить аппаратный SPI, сформировать старший бит и моргнуть синхроимпульсом, включить аппаратный SPI и передать оставшиеся 8 битов. Для начала решил попробовать чисто программное решение, от которого осталась функция <code>out9bit(uint8_t DC, uint8_t data8)</code>. Из нее я сделал такую:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">out8bit</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">data8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>         <span class="c1">// cs -&gt; 0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>     <span class="c1">// sclk -&gt; 0</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data8</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// data -&gt; 1</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// data -&gt; 0</span>
        <span class="p">}</span>
        <span class="n">data8</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>      <span class="c1">// sclk -&gt; 1</span>
    <span class="p">}</span>
    <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>          <span class="c1">// cs -&gt; 1</span>
<span class="p">}</span>
</pre></div>


<p>То есть, включаю CS нулем, опускаю SCLK в ноль, поднимаю или опускаю разряд данных в зависимости от старшего разряда передаваемых данных, сдвигаю данные влево для подготовки передачи следующего бита и поднимаю SCLK. Операции от падения до подъема SCLK повторяю, пока не передам байт, потом поднимаю CS.</p>
<p>Еще добавил функцию очистки экрана:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">scrClear</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// d/c -&gt; 0</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x40</span><span class="p">);</span> <span class="c1">// Y = 0</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span> <span class="c1">// X = 0</span>

    <span class="cm">/* 96 * 65 ? 768 -&gt; 864 */</span>
    <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">// d/c -&gt; 1</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">96</span> <span class="o">*</span> <span class="mi">9</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span>
    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// d/c -&gt; 0</span>
<span class="p">}</span>
</pre></div>


<p>Сперва здесь включается режим команд и задаются начальные координаты, потом включается режим данных и выводятся нулевые байты по всей поверхности экрана.</p>
<p>Пояснение по цифрам: экран имеет размер 96х65. Это значит, что по оси x 96 позиций, а по оси y 8 позиций по байту и еще одна позиция с одним пикселом, младшим в байте, итого &mdash; 9 позиций, стало быть, для очистки надо записать 96 &times; 9 = 864 нуля.</p>
<p>Затем добавил в текст программы после инициализации переменных в функции <code>main()</code> перед <code>SetupHardware()</code> сброс экрана:</p>
<div class="highlight"><pre><span></span>    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">_delay_ms</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
</pre></div>


<p>Первая строчка вообще-то не нужна, порт и так инициализирован нулями, но&hellip; Опять же, задержка реализована плохонькой библиотечной функцией, надо бы это не так сделать. И указание номеров разрядов надо бы сделать константами, а не цифрами в коде. Но это попозже переделаю, пока проверить работоспособность надо.</p>
<p>Дальше инициализация экрана:</p>
<div class="highlight"><pre><span></span>    <span class="c1">// screen init</span>
    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// d/c -&gt; 0</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x21</span><span class="p">);</span>      <span class="c1">// расширенный режим команд</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x12</span><span class="p">);</span>      <span class="c1">// установка напряжения смещения</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x80</span> <span class="o">|</span> <span class="mi">29</span><span class="p">);</span> <span class="c1">// установка напряжения LCD</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>      <span class="c1">// обычный режим команд</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x0c</span><span class="p">);</span>      <span class="c1">// нормальный режим отображения</span>

    <span class="n">scrClear</span><span class="p">();</span>
</pre></div>


<p>Включаю режим команды, потом выдаю серию этих самых команд: включаю расширенный набор команд (0х21), задаю напряжение смещения (0х80 + 56), задаю режим температурной коррекции (0х04), устанавливаю схему смещения напряжения (0х13), возвращаю стандартный набор команд (0х20), и включаю вывод графической информации на дисплей (0х0с). Затем чищу экран, потому что иначе он будет покрыт случайной россыпью точек.</p>
<p>Теперь вывожу линию во второй сверху полоске пикселов:</p>
<div class="highlight"><pre><span></span>    <span class="c1">// line on the top</span>
    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// d/c -&gt; 0</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x40</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
    <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>      <span class="c1">// d/c -&gt; 1</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">96</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x02</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<p>Переключаю в режим команд, устанавливаю координаты в левый верхний угол и вывожу 96 точек подряд, заодно проверяя реальную ширину экрана.</p>
<p>Затем вывожу еще одну полоску внизу экрана, вторую снизу, это старший разряд седьмого банка, а младший разряд восьмого банка будет самой нижней полоской.</p>
<div class="highlight"><pre><span></span>    <span class="c1">// line on the bottom</span>
    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// d/c -&gt; 0</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x47</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
    <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>      <span class="c1">// d/c -&gt; 1</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">96</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<p>Теперь примерно посередине экрана хочу нарисовать свой логотип. Для этого сначала на листочке в клеточку рисую его карандашом и прикидываю, сколько вертикальных восьмипиксельных линий это займет, и какие биты в байтах установить:</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/17/logo-sketch.jpg" title="Эскиз лого"><img alt="Эскиз лого" src="http://romeogolf.github.io/images/usb-polygon/17/preview/logo-sketch-small.jpg" title="Эскиз лого"></a></p>
<p>Затем устанавливаю позицию начала рисунка (предварительно включив режим команд). Полторы строчки &mdash; используются два банка &mdash; по оси y начнем с банка 3. 17 точек в ширину, а ширина экрана 96, значит по оси x начнем с позиции [(96 / 2) &ndash; (17 / 2)], округленно 40, или 0х28. Потом ставлю режим вывода данных и выдаю верхнюю строчку. Затем устанавливаю координаты второй строчки (смещая банк на единицу) и выдаю вторую строчку. Получается такой код:</p>
<div class="highlight"><pre><span></span>    <span class="c1">// position set</span>
    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// d/c -&gt; 0</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x43</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x80</span> <span class="o">|</span> <span class="mh">0x28</span><span class="p">);</span>

    <span class="c1">// data out</span>
    <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>      <span class="c1">// d/c -&gt; 1</span>

    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x40</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x88</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x44</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x22</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x31</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0xc3</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x0c</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0xc0</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span>

    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>     <span class="c1">// d/c -&gt; 0</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x44</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x80</span> <span class="o">|</span> <span class="mh">0x28</span><span class="p">);</span>
    <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>      <span class="c1">// d/c -&gt; 1</span>

    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x06</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x05</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x06</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x05</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x05</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x06</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x05</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x07</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x07</span><span class="p">);</span>
    <span class="n">out8bit</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span>

    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// d/c -&gt; 0</span>
</pre></div>


<p>Программа с дописанным кодом компилируется и прошивается. Но неожиданно при запуске ничего на экране не происходит. Хоть через FLIP, хоть через dfu-programmer. Кнопка Reset тоже не помогает. Однако выручает перезапуск питания: выдергиваю разъем и вставляю снова, и вот что вижу на экране:</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/17/logo.jpg" title="Лого"><img alt="Лого" src="http://romeogolf.github.io/images/usb-polygon/17/preview/logo_small.jpg" title="Лого"></a></p>
<h2 id="spi">Доработка под аппаратный SPI</h2>
<p>Экран завелся.</p>
<p>Честно говоря, заводился он не настолько уж сразу. Сперва помаялся с питанием экрана.</p>
<p>До сих пор остается загадкой, почему сброс после программирования не запускает картинку на экране.</p>
<p>Пока разбирался с отсутствием изображения, добавил задержку в формирование импульса SCLK, из-за чего стирание стало занимать секунд десять. Стирание тоже сделал не сразу и любовался картинкой на замусоренном поле.</p>
<p>Потом рассчитывал, сколько пустых байтов нужно записать для стирания, чтобы и экран почистить, и слишком много времени на это не тратить.</p>
<p>Потом я ошибался в количестве и порядке пикселов для картинки.</p>
<p>Пока искал ошибки, подозревал, что неправильно подключал заголовочные файлы, и именованные константы обнулены. Бред, конечно, компилятор бы предупредил, но&hellip; В общем, заменил кучу констант на хардкод, цифрами.</p>
<p>Но теперь работает.</p>
<p>Однако хотелось бы упростить обмен по SPI &mdash; зря, что ли, он реализован в контроллере аппаратно? Сразу переходить на аппаратный вариант немножко страшновато &mdash; не хочется ломать то, что работает, поэтому ввожу флажок включенности SPI, для чего объявляю переменную</p>
<div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="n">isSpiOn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>выше объявления функции <code>out8bit()</code>, а саму эту функцию изменяю таким образом:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">out8bit</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">data8</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isSpiOn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>     <span class="c1">// cs -&gt; 0</span>
        <span class="n">SPDR</span> <span class="o">=</span> <span class="n">data8</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">SPSR</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SPIF</span><span class="p">)))</span> <span class="p">;</span> <span class="c1">// wait for transmit</span>
        <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>          <span class="c1">// cs -&gt; 1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>     <span class="c1">// cs -&gt; 0</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>     <span class="c1">// sclk -&gt; 0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data8</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>      <span class="c1">// data -&gt; 1</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// data -&gt; 0</span>
            <span class="p">}</span>
            <span class="n">data8</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>          <span class="c1">// sclk -&gt; 1</span>
        <span class="p">}</span>
        <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>          <span class="c1">// cs -&gt; 1</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>При установленном флажке включенности SPI функция записывает байт в буфер SPI и ждет, когда он выдастся как-нибудь сам, а при снятом флажке работает, как раньше.</p>
<p>Теперь после объявления переменных в функции <code>main()</code> надо включить SPI и установить флажок следующим образом:</p>
<div class="highlight"><pre><span></span>    <span class="cm">/* Enable SPI, Master, set clock rate fck/2 (4 MHz) */</span>
    <span class="n">SPCR</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SPE</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MSTR</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">SPR1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">SPR0</span><span class="p">);</span>
    <span class="n">SPSR</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SPI2X</span><span class="p">);</span>
    <span class="n">isSpiOn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>Биты <code>SPR0</code>, <code>SPR1</code>, <code>SPI2X</code> задают частоту обмена, равную половине тактовой, так как тактовая частота на используемом устройстве &mdash; 8 МГц, а максимально разрешенная для экрана &mdash; 4 МГц.</p>
<p>Больше ничего менять не надо. Компилируется, прошивается и работает без изменений. При желании можно поиграться со скоростями SPI, задавая их при инициализации</p>
<h2 id="_9">Передача файла экрану</h2>
<p>Результат, конечно, радует, но ничего выдающегося в этом нет. Как нет и ничего специфичного для USB-polygon. Интересно добавить возможность отображения на экране некоторых данных, задаваемых с <abbr title="Персональный компьютер">ПК</abbr>, который при этом думает, что пересылает файлы на флэшку.</p>
<p>Передавать данные из файла на экран скопом, как есть, пожалуй, не получится. Надо разделить их на собственно данные и команды, раз уж так реализован вывод на экран. Иначе трудно будет сделать позиционирование при выводе очередного элемента. Кроме того, можно при помощи команд с <abbr title="Персональный компьютер">ПК</abbr> попросить устройство выполнить некоторую типовую операцию (например, стирание экрана), состоящую из нескольких команд, а не передавать эти несколько команд поштучно.</p>
<p>Я решил, что буду заполнять файл парами байтов. Младший в паре будет командой, старший &mdash; данными. Скажем, команда <code>1</code> соответствует требованию выставить режим команд для передачи байтов, команда <code>2</code> &mdash; выставить режим данных для передачи байтов, команда <code>3</code> &mdash; прекратить обработку файла и дальнейшие данные игнорировать (включая и непосредственно следующий байт), команда <code>4</code> &mdash; выполнить операцию очистки экрана, при этом следующий байт игнорируется. Остальные команды (включая <code>0</code>) &mdash; ничего не делать, использовать для байта данных предыдущую команду. То есть, можно выдать серию байтов для отображения, а команду <code>2</code> выставить только перед первым из них, остальные предварять нулевым байтом-командой.</p>
<p>Оставляем файл <code>MassStorage.c</code>, тут уже все сделано. Открываем <code>Lib/fake_fs.c</code>. В нем расширим тип-перечисление операций при записи:</p>
<div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">WriteType</span> <span class="p">{</span><span class="n">None</span><span class="p">,</span> <span class="n">ToFile</span><span class="p">,</span> <span class="n">ToLed</span><span class="p">,</span> <span class="n">ToSpi</span><span class="p">};</span>
</pre></div>


<p>Еще объявляю переменную, разрешающую пересылку по SPI данных, полученных из &laquo;записываемого&raquo; файла:</p>
<div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="n">canSpiFromFile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>Это нужно для ограничения данных для передачи: файл будет передаваться кусками, кратными сектору, а данных для передачи может быть иное количество. Поэтому в конце файла надо поставить метку-команду, запрещающую передачу, чтобы остаток файла &mdash; хвост &mdash; не передавался, когда очередные 16-байтовые порции хвоста придут в устройство.</p>
<p>Затем я решил не плодить лишние сущности (кроме типа записи, в которую я добавил новый тип, а мог тоже заменить): то, что связано с выводом байтов файла на светодиодную линейку, использовалось только для демонстрации и отладки, больше использоваться не будет, поэтому заменяю &laquo;LED&raquo; на &laquo;SPI&raquo;, а именно:</p>
<p>вместо</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">strToLED</span><span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span> <span class="s">&quot;Write to LED    &quot;</span><span class="p">;</span>
</pre></div>


<p>пишу</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">strToSpi</span><span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span> <span class="s">&quot;Write to SPI    &quot;</span><span class="p">;</span>
</pre></div>


<p>Вместо</p>
<div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readToLed</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>


<p>записываю</p>
<div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readToSpi</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>


<p>И в таблице файлов строку</p>
<div class="highlight"><pre><span></span>    <span class="p">{</span><span class="s">&quot;TO_LED  TXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_COMMAND</span><span class="p">,</span> <span class="n">readToLed</span><span class="p">},</span>
</pre></div>


<p>заменяю на</p>
<div class="highlight"><pre><span></span>    <span class="p">{</span><span class="s">&quot;TO_SPI  TXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_COMMAND</span><span class="p">,</span> <span class="n">readToSpi</span><span class="p">},</span>
</pre></div>


<p>Далее вместо определения функции <code>readToLed()</code> пишу несколько измененную</p>
<div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readToSpi</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">writeType</span> <span class="o">=</span> <span class="n">ToSpi</span><span class="p">;</span>
    <span class="n">memcpy_P</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">PGM_P</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">strToSpi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">canSpiFromFile</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>И, наконец, в функции <code>process_data()</code> в переключателе <code>switch</code> добавляю новый вариант:</p>
<div class="highlight"><pre><span></span>    <span class="k">case</span> <span class="nl">ToSpi</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">BlockAddress</span> <span class="o">&gt;=</span> <span class="n">FILES_AREA</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">canSpiFromFile</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">switch</span> <span class="p">(</span><span class="n">data_buf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                        <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
                            <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>     <span class="c1">// d/c -&gt; 0</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
                            <span class="n">PORTB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>      <span class="c1">// d/c -&gt; 1</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
                            <span class="n">canSpiFromFile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
                            <span class="n">scrClear</span><span class="p">();</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="k">default</span><span class="o">:</span>
                            <span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">canSpiFromFile</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">out8bit</span><span class="p">(</span><span class="n">data_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
</pre></div>


<p>Небольшое отступление: казалось бы, <code>if (canSpiFromFile) {</code> &mdash; перестраховка, ведь в самом начале <code>for</code> есть условие <code>if (!canSpiFromFile) {</code>, ан нет, так и задумано. Ведь в текущей паре байтов первый (командный) может оказаться равным &laquo;3&raquo;, тогда надо запрет обработки байта данных применить немедленно.</p>
<p>Чтобы это заработало, надо еще в файл <code>common.h</code> добавить строчки</p>
<div class="highlight"><pre><span></span>        <span class="k">extern</span> <span class="kt">void</span> <span class="nf">out8bit</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">data8</span><span class="p">);</span>
        <span class="k">extern</span> <span class="kt">void</span> <span class="nf">scrClear</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>


<p>В общем-то и все. Модифицированный код компилируется и прошивается, только результат работы пока не виден.</p>
<p id="file">Формирую для пробы файл с данными в HEX-редакторе:</p>
<div class="highlight"><pre><span></span>00000000: 04 00 01 43 01 98 02 3f 00 09 00 09 00 36 00 00  ...C...?.....6..
00000010: 00 1e 00 21 00 21 00 1e 00 00 00 3f 00 02 00 04  ...!.!.....?....
00000020: 00 08 00 04 00 02 00 3f 00 00 00 3f 00 25 00 25  .......?...?.%.%
00000030: 00 21 00 00 00 1e 00 21 00 21 00 1e 00 00 00 00  .!.....!.!......
00000040: 00 1e 00 21 00 29 00 1a 00 00 00 1e 00 21 00 21  ...!.).......!.!
00000050: 00 1e 00 00 00 3f 00 20 00 20 00 20 00 00 00 3f  .....?. . . ...?
00000060: 00 05 00 05 00 01 03 00 00                       .........
</pre></div>


<p>Первая пара байтов содержит команду <code>4</code> стирания экрана. Две следующие пары устанавливают координаты выдачи надписи. Потом идет пара байтов, первый их которых &mdash; команда <code>2</code>, выдавать данные на экран, а второй &mdash; первый байт для выдачи. Следующие пары байтов почти до конца содержат команду <code>0</code> и остальные данные, а в конце идет команда <code>3</code> (прекратить обработку), второй байт пары с нулевым значением и нулевой хвостовой байт просто так. Дальше, после тройки в командном байте, можно писать сколько угодно чего угодно. Называю получившийся файл &laquo;to_spi.bin&raquo;.</p>
<p>Снова подключаю перепрошитое обновленной версией программы устройство к <abbr title="Персональный компьютер">ПК</abbr>. На экране <abbr title="Персональный компьютер">ПК</abbr> появляется окошко &laquo;Автозапуск&raquo;, предлагающий открыть флэшку, а на экране, подключенном к устройству, уже знакомая картина:</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/17/logo_2.jpg" title="Лого"><img alt="Лого" src="http://romeogolf.github.io/images/usb-polygon/17/preview/logo_2_small.jpg" title="Лого"></a></p>
<p>Открываю &laquo;флэшку&raquo;, вижу там файл <code>TO_SPI.TXT</code>. Его открытие на чтение будет для устройства командой пересылать любую записываемую в дальнейшем информацию на экран. Открываю файл (блокнотом по умолчанию) и вижу надпись &laquo;Write to SPI    &raquo;. Закрываю блокнот. Перетаскиваю файл &laquo;to_spi.bin&raquo; мышью в окно &laquo;флэшки&raquo;, и изображение на экране устройства изменяется:</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/17/text.jpg" title="Текст"><img alt="Текст" src="http://romeogolf.github.io/images/usb-polygon/17/preview/text_small.jpg" title="Текст"></a></p>
<p>Замечательно! Подтверждена возможность передачи файла по линии связи, а заодно и использовать передаваемые в файле данные для управления самим устройством.</p>
<h2 id="_10">Заключение</h2>
<p>Проверена работа измененного проекта в <abbr title="операционная система">ОС</abbr> Linux, а конкретно в Debian 8. Все работает точно так же, как и в Windows 7, кроме небольшой детали: чтобы начальная картинка сменилась надписью, после записи файла &laquo;to_spi.bin&raquo; нужно или подождать некоторое время, или дать команду <code>sync</code>, потому что в Linux запись на флэшку по умолчанию идет не сразу, а через буфер, и данные сбрасываются на носитель в подходящий по мнению <abbr title="операционная система">ОС</abbr> момент или по команде.</p>
<p>Теперь стоит &laquo;причесать&raquo; код. Избавиться от жестко заданных чисел, переведя их в константы. Для этого в файл <code>common.h</code> добавлю определения констант</p>
<div class="highlight"><pre><span></span>    <span class="c1">// разряды порта B - SPI и управление экраном</span>
    <span class="cp">#define BIT_DC   (1 &lt;&lt; 5)</span>
    <span class="cp">#define BIT_RES  (1 &lt;&lt; 4)</span>
    <span class="cp">#define BIT_SCLK (1 &lt;&lt; 1)</span>
    <span class="cp">#define BIT_MOSI (1 &lt;&lt; 2)</span>
    <span class="cp">#define BIT_SS   (1 &lt;&lt; 0)</span>

    <span class="c1">// разряды порта С - кнопки</span>
    <span class="cp">#define BT_1   (1 &lt;&lt; 4)</span>
    <span class="cp">#define BT_2   (1 &lt;&lt; 5)</span>
    <span class="cp">#define BT_3   (1 &lt;&lt; 2)</span>
    <span class="cp">#define BT_4   (1 &lt;&lt; 6)</span>
    <span class="cp">#define BT_5   (1 &lt;&lt; 7)</span>
</pre></div>


<p>И по тексту файлов <code>MassStorage.c</code> и <code>fake_fs.c</code> заменю <code>PORTB &amp;= ~(1 &lt;&lt; 5);</code> на <code>PORTB &amp;= ~BIT_DC;</code> (аналогично остальные разряды порта С), а <code>if ((bt_now &amp; 0x30) == 0) {</code> на <code>if ((bt_now &amp; (BT_1 | BT_2)) == 0) {</code> (аналогично остальные кнопки).</p>
<p>Для интересу перед перекомпиляцией сохранил файлы .hex и .bin, после команды <code>make</code> сравнил новые со старыми. Как и ожидалось, изменений нет.</p>
<p>Хорошо бы еще немного оптимизировать, удалить лишнее. И попробовать использовать устройство для связи с еще какими-нибудь штучками. На очереди SD-карта памяти (по SPI-интерфейсу, хочется попробовать совместить на одной шине дисплей и память) и энкодер, с которым все теоретически несложно, но практически еще не сделано.</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "usb-polygon-17.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>