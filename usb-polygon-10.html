<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-10: Таблица памяти для имитации ФС</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">11</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Сб 03 Июнь 2017</h4>
    <article>
      <h1>USB-polygon-10: Таблица памяти для имитации ФС</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Структура памяти</a></li>
<li><a href="#_2">Главная загрузочная запись</a><ul>
<li><a href="#mbr">Общая структура MBR</a></li>
<li><a href="#_3">Запись раздела</a></li>
<li><a href="#mbr_1">MBR для имитации</a></li>
</ul>
</li>
<li><a href="#_4">Загрузочная запись раздела</a></li>
<li><a href="#fat">Таблица FAT</a></li>
<li><a href="#root">Файловая запись root</a></li>
<li><a href="#_5">Прочие файловые записи</a></li>
<li><a href="#const">Важные константы</a></li>
</ul>
</div>
<h2 id="_1">Структура памяти</h2>
<p>При имитации файловой системы (<abbr title="файловая система">ФС</abbr>) необходимо отвечать операционной системе на команды чтения и записи. Для этого необходимо знать, что находилось бы по конкретным адресам памяти, если бы память на самом деле была. Следует составить таблицу соответствия данных адресам, эту таблицу будет реализовывать имитирующая программа, отдавая правильные ответы на запрошенные адреса в операциях чтения. Операции записи же поначалу будем игнорировать, делая вид, что все удачно записалось, позже посмотрим, нельзя ли использовать и запись тоже.</p>
<p>Нужна таблица памяти. И даже не одна. Логично представить структуру фиктивной памяти в нескольких таблицах. Первая будет показывать область памяти, не зависящую от используемой <abbr title="файловая система">ФС</abbr> и необходимую любому носителю информации в той или иной форме: <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr>, master boot record &mdash; главная загрузочная запись (или учет сапога хозяина, если хотите). Вторая таблица нужна для описания <abbr title="(Partition Boot Record) Загрузочная запись раздела">PBR</abbr>, partition boot record, на первый взгляд не имеющей непосредственного отношения к <abbr title="файловая система">ФС</abbr>, но уже являющийся ее частью. Третья таблица будет описывать таблицу размещения файлов, <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> (file allocation table). Затем должна следовать запись, описывающая корневой каталог. В оставшейся памяти будет размещаться собственно информация носителя &mdash; папки и файлы. Эту зону можно тоже условно представить в виде примерной таблицы, хотя ее наполнение уже не является жестко фиксированным, в отличие от предыдущих.</p>
<p>Будет использоваться адресация <abbr title="(Logical Block Addressing) Система адресации данных в виде последовательно расположенных блоков данных">LBA</abbr> и термин &laquo;сектор&raquo;, обозначающий в данном контексте не сектор физического диска, а логический блок, имеющий размер те же традиционные 512 байтов, что и сектор.</p>
<h2 id="_2">Главная загрузочная запись</h2>
<p><abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> &mdash; запись, которая обязана присутствовать на любом носителе информации, если есть необходимость работать с ним стандартными способами. Есть оговорки. Во-первых, устройство хранения информации (микросхема, карта памяти, USB-носитель) может работать и в &laquo;сыром&raquo; режиме, без файловой системы с постраничной записью и посекторным чтением более-менее стандартными способами &mdash; функциями <abbr title="операционная система">ОС</abbr> вроде ReadFile(). Но это потребует изрядной порции дополнительной работы для обращения к носителю. Во-вторых, сегодня <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> &mdash; не единственный вариант, например, GPT &mdash; GUID Partition Table. Но в целях имитации флэш-памяти это все неважно, интересует именно <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr>.</p>
<h3 id="mbr">Общая структура <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr></h3>
<p>Таблица 1. Структура классической <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr></p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">Адрес</th>
<th>Описание</th>
<th align="center">Размер, байтов</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">000h</td>
<td>Код загрузчика</td>
<td align="center">446</td>
</tr>
<tr>
<td align="center">1BEh</td>
<td>1. Запись раздела</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">1CEh</td>
<td>2. Запись раздела</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">1DEh</td>
<td>3. Запись раздела</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">1EEh</td>
<td>4. Запись раздела</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">1FEh</td>
<td>Сигнатура <abbr title="(Base Input-Output System) Базовая система ввода-вывода">BIOS</abbr> (55h AAh)</td>
<td align="center">2</td>
</tr>
</tbody>
</table>
<p>Код загрузчика (первая строчка таблицы) &mdash; в сущности, программа, которую должен выполнить процессор, если в параметрах <abbr title="(Base Input-Output System) Базовая система ввода-вывода">BIOS</abbr> указано загружаться с данного устройства. Ему, процессору, предоставляют это устройство для чтения команд и выставляют счетчик команд в ноль. Если он &mdash; процессор &mdash; находит там команды, то начинает их выполнять. В эти 446 байтов можно попытаться запихать весь загрузчик, то есть программу, заставляющую загрузить <abbr title="операционная система">ОС</abbr> в оперативную память и передающую ей управление. Если загрузчик достаточно сложный (типа GRUB или из последних версий Windows), то в этот кусочек памяти он не поместится, придется разместить там предзагрузчик, который загрузит основной загрузчик и передаст управление ему. Существуют также другие варианты <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr>, отличающиеся составом первых 446 байтов, где для кода загрузки отведено меньше места, зато добавлена всяческая дополнительная служебная информация.</p>
<p>Однако, все это имеет смысл для носителей информации, которые могут использоваться в качестве загрузочных. К имитируемой флэшке это не относится, поэтому там будут нули.</p>
<p>И это очень хорошо. Нет необходимости хранить в памяти все необходимые записи целиком, из-за чего терялся бы смысл имитации, проще было бы разместить реальные записи в реальной памяти. А так можно не тратить память на хранение нулей, а просто отвечать нулями на адреса от 0 до 1BDh, и такой пустой участок не единственный.</p>
<p>Далее идут записи раздела: набор полей данных, описывающих первичные разделы на носителе информации, четыре штуки. И завершает запись <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> фиксированная двухбайтовая константа, служащая для сигнализации окончания структуры и для проверки ее правильности.</p>
<h3 id="_3">Запись раздела</h3>
<p>Таблица 2. Структура записи раздела</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">Адрес</th>
<th>Описание</th>
<th align="center">Размер, байтов</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">00h</td>
<td>Статус раздела:<br>0 - неактивный<br>80h - активный</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">01h</td>
<td>Головка, на которой начинается раздел</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">02h</td>
<td>Дорожка, на которой начинается раздел (биты 16-6)<br>сектор, на котором начинается раздел (биты 5-0)</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">04h</td>
<td>Тип раздела:<br>1h - FAT12<br>4h - FAT16&lt;32Мб<br>6h - FAT16&gt;32Мб<br>Bh - FAT32</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">05h</td>
<td>Головка, на которой заканчивается раздел</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">06h</td>
<td>Дорожка, на которой заканчивается раздел (биты 16-6)<br>сектор, на котором заканчивается раздел (биты 5-0)</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">08h</td>
<td>Расстояние между сектором <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> и первым сектором раздела, в секторах</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">0Ch</td>
<td>Общее число секторов в разделе</td>
<td align="center">4</td>
</tr>
</tbody>
</table>
<p>Адрес в таблице 2 относительный, то есть, от начала записи раздела.</p>
<p>Таких структур первичных разделов может быть 4. Первичный раздел может содержать ряд расширенных разделов. Но, опять же, в рамках проекта USB-polygon это не важно. Здесь вполне достаточно одного раздела, а это значит, что записи разделов 2, 3 и 4 будут заполнены нулями и сэкономят место при имитации.</p>
<h3 id="mbr_1"><abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> для имитации</h3>
<p>Теперь можно заполнить таблицу с данными, которые должны выдаваться по определенным адресам, передаваемым от компьютера при попытке прочитать главную загрузочную запись.</p>
<p id="table3">Таблица 3. Итоговая <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr></p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">Адр.</th>
<th>Описание</th>
<th align="center">Разм.</th>
<th align="center">r:c</th>
<th>hex</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">000h</td>
<td>Код загрузчика</td>
<td align="center">446</td>
<td align="center">00:00 .. 27:13</td>
<td>0&hellip;</td>
</tr>
<tr>
<td align="center">1BEh</td>
<td>Начало раздела 1.<br>Статус раздела:<br>0 - неактивный<br>80h - активный</td>
<td align="center">1</td>
<td align="center">27:14</td>
<td>00</td>
</tr>
<tr>
<td align="center">1BFh</td>
<td>Головка, на которой начинается раздел</td>
<td align="center">1</td>
<td align="center">27:15</td>
<td>00</td>
</tr>
<tr>
<td align="center">1C0h</td>
<td>Дорожка, на которой начинается раздел (биты 16-6)<br>сектор, на котором начинается раздел (биты 5-0)</td>
<td align="center">2</td>
<td align="center">28:00</td>
<td>00 00</td>
</tr>
<tr>
<td align="center">1C2h</td>
<td>Тип раздела:<br>1h - FAT12<br>4h - FAT16&lt;32Мб<br>6h - FAT16&gt;32Мб<br>Bh – FAT32<br>Ch – FAT32 c <abbr title="(Logical Block Addressing) Система адресации данных в виде последовательно расположенных блоков данных">LBA</abbr></td>
<td align="center">1</td>
<td align="center">28:02</td>
<td>0C</td>
</tr>
<tr>
<td align="center">1C3h</td>
<td>Головка, на которой заканчивается раздел</td>
<td align="center">1</td>
<td align="center">28:03</td>
<td>00</td>
</tr>
<tr>
<td align="center">1C4h</td>
<td>Дорожка, на которой заканчивается раздел (биты 16-6)<br>сектор, на котором заканчивается раздел (биты 5-0)</td>
<td align="center">2</td>
<td align="center">28:04</td>
<td>00</td>
</tr>
<tr>
<td align="center">1C6h</td>
<td>Расстояние между сектором <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> и первым сектором раздела, в секторах</td>
<td align="center">4</td>
<td align="center">28:06</td>
<td>3E 00 00 00 (62<sub>dec</sub>)</td>
</tr>
<tr>
<td align="center">1CAh</td>
<td>Общее число секторов в разделе</td>
<td align="center">4</td>
<td align="center">28:10</td>
<td>00 10 00 00</td>
</tr>
<tr>
<td align="center">1CEh</td>
<td>Запись раздела 2</td>
<td align="center">16</td>
<td align="center">28:14 .. 29:13</td>
<td>0&hellip;</td>
</tr>
<tr>
<td align="center">1DEh</td>
<td>Запись раздела 3</td>
<td align="center">16</td>
<td align="center">29:14 .. 30:13</td>
<td>0&hellip;</td>
</tr>
<tr>
<td align="center">1EEh</td>
<td>Запись раздела 4</td>
<td align="center">16</td>
<td align="center">30:14 .. 31:13</td>
<td>0&hellip;</td>
</tr>
<tr>
<td align="center">1FEh</td>
<td>Сигнатура <abbr title="(Base Input-Output System) Базовая система ввода-вывода">BIOS</abbr></td>
<td align="center">2</td>
<td align="center">31:14</td>
<td>55 AA</td>
</tr>
</tbody>
</table>
<p>Комментарии к таблице:</p>
<ul>
<li>Первая колонка (Адр.) &mdash; адрес в памяти устройства, при обращении к которому <abbr title="операционная система">ОС</abbr> <abbr title="Персональный компьютер">ПК</abbr> надеется получить информацию, описанную в данной строке.</li>
<li>Вторая колонка (Описание) &mdash; что должно содержаться по указанному адресу.</li>
<li>Третья колонка (Разм.) &mdash; размер поля в байтах.</li>
<li>Четвертая колонка (r:c) &mdash; row:column &mdash; представление адреса в таком виде, как если бы блок информации отображался в традиционных HEX-редакторах, в виде набора строк по 16 байтов, то есть, номер строки и номер байта в ней. Эта колонка пригодится при реальной передаче данных от самодельного устройства в ответ на запросы <abbr title="операционная система">ОС</abbr>, так как при использовании библиотеки LUFA контроллер передает информацию пачками по 16 байтов. Таким образом, в этой колонке показаны номер пачки и номер байта в пачке.</li>
<li>Пятая колонка (hex) &mdash; байты в шестнадцатеричной форме, которые должны быть переданы в данном конкретном случае.</li>
</ul>
<p>В этой и следующих таблицах в пятой колонке кроме hex-данных могут быть десятичные числа, помеченные &laquo;dec&raquo;, и строки, в которых пробелы заменены подчеркиванием &laquo;_&raquo;. При передаче строк символы заменяются их кодами, естественно. В программе на языке С же можно в качестве передаваемого байта указать как его код, так и сам символ в одинарных кавычках, конечно же.</p>
<p>Пояснения по данным:</p>
<ul>
<li>Код загрузчика отсутствует, на запрос выдавать нули. Загружаться с фейковой флэшки не планируется (хотя, мысль интересная, можно однажды попробовать&hellip;)</li>
<li>Статус первого раздела: неактивный, ноль, по той же причине &mdash; грузиться отсюда не будем.</li>
<li>Головка, дорожка и сектор начала раздела выдаются нулями, потому что адресация <abbr title="(Cylinder, Head, Sector) Система адресации сектора, основанная на использовании физических адресов геометрии диска">CHS</abbr> не используется, используется <abbr title="(Logical Block Addressing) Система адресации данных в виде последовательно расположенных блоков данных">LBA</abbr>.</li>
<li>Тип раздела: 0C, что соответствует FAT32 с адресацией <abbr title="(Logical Block Addressing) Система адресации данных в виде последовательно расположенных блоков данных">LBA</abbr>.</li>
<li>Головка, дорожка и сектор окончания раздела также выдается нулями.</li>
<li>Начало первого сектора раздела: соответствует 62 сектору.</li>
<li>Число секторов в разделе: попробуем для начала 4к секторов, а там посмотрим. Получится 2 097 152 байтов.</li>
<li>Записи разделов 2, 3 и 4 забиваем нулями.</li>
<li>Сигнатура фиксированная, может быть только 55AA.</li>
</ul>
<p>Подробнее про начало сектора: почему именно 62? Не знаю. Так получилось. Во флэшках, отформатированных в Windows, обычно 62. Во флэшках, отформатированных в FAT32 в Linux может быть другой адрес, обычно меньше. Есть подозрение, что число появилось из порядка загрузки: <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr>, найдя активный раздел (помеченный, как 80) считывает его загрузочный сектор и помещает по физическому адресу 7C00<sub>hex</sub>, что в секторах соответствует как раз 62. Что мешает взять сектор, лежащий существенно ближе, и записать его в 62 сектор оперативки? Я не знаю. Предполагаю, что это может как-то упростить операции переписывания данных: с какого адреса взяли, по такому и записали, только в другое устройство. Но это не очень важно. Можно поэкспериментировать, &laquo;двигая&raquo; этот адрес. Для реальной флэшки смещение загрузочного сектора раздела поможет сэкономить напрасно неиспользуемое место, а для фиктивной флэшки вообще ни на что не влияет. Поэтому ставлю 62, оно реально работает, а там посмотрим.</p>
<p>Теперь про общее число секторов в разделе. Вообще-то, FAT32 сама хранит информацию о своем разделе, и я читал, что Windows игнорирует эту запись в <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr>. Но пока оставлю так.</p>
<p>Итого: при запросе <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> устройству надо будет отдать всего 5 ненулевых байтов.</p>
<h2 id="_4">Загрузочная запись раздела</h2>
<p>В литературе встречаются обозначения <abbr title="(Partition Boot Record) Загрузочная запись раздела">PBR</abbr> и VBR &mdash; Partition и Volume Boot Record. Адресация здесь ведется от начала раздела, так как раздел может быть практически где угодно, проще будет потом прибавить смещение.</p>
<p>Загрузочначя запись начинает раздел. Раздел, как договаривались, будет &laquo;отформатирован&raquo; в FAT32. А файловые системы <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> состоят из 4 областей:</p>
<ul>
<li>0: Зарезервированная область</li>
<li>1: Область <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr></li>
<li>2: Область корневого каталога (для версий <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> до FAT32)</li>
<li>3: Область файлов и каталогов</li>
</ul>
<p>Загрузочная запись раздела находится в первом секторе зарезервированной области. Его иногда называют &laquo;загрузочный сектор&raquo;, &laquo;зарезервированный сектор&raquo; или &laquo;нулевой сектор&raquo;</p>
<p id="table4">Таблица 4. Загрузочная запись раздела</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">Адр.</th>
<th>Описание</th>
<th align="center">Разм.</th>
<th align="center">r:c</th>
<th>hex</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">00h</td>
<td>Указание перехода + NOP</td>
<td align="center">3</td>
<td align="center">00:00..00:02</td>
<td>EB 58 90</td>
</tr>
<tr>
<td align="center">03h</td>
<td>OEM название</td>
<td align="center">8</td>
<td align="center">00:03..00:10</td>
<td>4D 53 44 4F 53 35 2E 30 (&ldquo;MSDOS5.0&rdquo;)</td>
</tr>
<tr>
<td align="center">0Bh</td>
<td>Количество байтов в секторе на жестком диске</td>
<td align="center">2</td>
<td align="center">00:11..00:12</td>
<td>00 02 (512<sub>dec</sub>)</td>
</tr>
<tr>
<td align="center">0Dh</td>
<td>Количество секторов в кластере</td>
<td align="center">1</td>
<td align="center">00:13</td>
<td>08</td>
</tr>
<tr>
<td align="center">0Eh</td>
<td>Количество зарезервированных секторов</td>
<td align="center">2</td>
<td align="center">00:14..00:15</td>
<td>01 00</td>
</tr>
<tr>
<td align="center">10h</td>
<td>Количество копий <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>, как правило, 2</td>
<td align="center">1</td>
<td align="center">01:00</td>
<td>02</td>
</tr>
<tr>
<td align="center">11h</td>
<td>Количество возможных записей в корневом каталоге</td>
<td align="center">2</td>
<td align="center">01:01</td>
<td>00 00</td>
</tr>
<tr>
<td align="center">13h</td>
<td>Количество секторов в маленьком разделе</td>
<td align="center">2</td>
<td align="center">01:03</td>
<td>00 00</td>
</tr>
<tr>
<td align="center">15h</td>
<td>Тип носителя:<br>F8 для жестких дисков<br>F0 для дискет</td>
<td align="center">1</td>
<td align="center">01:05</td>
<td>F8</td>
</tr>
<tr>
<td align="center">16h</td>
<td>Секторов на <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> (FAT12/FAT16)</td>
<td align="center">2</td>
<td align="center">01:06</td>
<td>00 00</td>
</tr>
<tr>
<td align="center">18h</td>
<td>Секторов на дорожку</td>
<td align="center">2</td>
<td align="center">01:08</td>
<td>63<sub>dec</sub> 00</td>
</tr>
<tr>
<td align="center">1Ah</td>
<td>Число головок</td>
<td align="center">2</td>
<td align="center">01:10</td>
<td>FF 00</td>
</tr>
<tr>
<td align="center">1Ch</td>
<td>Зарезервированные сектора в начале жесткого диска</td>
<td align="center">4</td>
<td align="center">01:12..01:15</td>
<td>62<sub>dec</sub> 00 00 00</td>
</tr>
<tr>
<td align="center">20h</td>
<td>Количество секторов в большом разделе</td>
<td align="center">4</td>
<td align="center">02:00..02:03</td>
<td>00 10 00 00</td>
</tr>
<tr>
<td align="center">24h</td>
<td>Размер одной <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> в секторах (FAT32)</td>
<td align="center">4</td>
<td align="center">02:04..02:07</td>
<td>08 00 00 00</td>
</tr>
<tr>
<td align="center">28h</td>
<td>Номер главной таблицы <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr></td>
<td align="center">2</td>
<td align="center">02:08</td>
<td>00 00</td>
</tr>
<tr>
<td align="center">2Ah</td>
<td>Версия FAT32 (обычно 0)</td>
<td align="center">2</td>
<td align="center">02:10</td>
<td>00 00</td>
</tr>
<tr>
<td align="center">2Ch</td>
<td>Первый кластер корневого каталога (обычно 2)</td>
<td align="center">4</td>
<td align="center">02:12..02:15</td>
<td>02 00</td>
</tr>
<tr>
<td align="center">30h</td>
<td>Номер сектора структуры FSINFO (обычно 1)</td>
<td align="center">2</td>
<td align="center">03:00</td>
<td>00 00</td>
</tr>
<tr>
<td align="center">32h</td>
<td>Номер сектора - копии загрузочного (обычно 6)</td>
<td align="center">2</td>
<td align="center">03:02</td>
<td>00 00</td>
</tr>
<tr>
<td align="center">34h</td>
<td>Зарезервировано</td>
<td align="center">12</td>
<td align="center">03:04..03:15</td>
<td>00&hellip;</td>
</tr>
<tr>
<td align="center">40h</td>
<td>Номер дисковода для функций <abbr title="(Base Input-Output System) Базовая система ввода-вывода">BIOS</abbr></td>
<td align="center">1</td>
<td align="center">04:00</td>
<td>80</td>
</tr>
<tr>
<td align="center">41h</td>
<td>Зарезервировано</td>
<td align="center">1</td>
<td align="center">04:01</td>
<td>00</td>
</tr>
<tr>
<td align="center">42h</td>
<td>Сигнатура - 29h</td>
<td align="center">1</td>
<td align="center">04:02</td>
<td>29</td>
</tr>
<tr>
<td align="center">43h</td>
<td>ID диска</td>
<td align="center">4</td>
<td align="center">04:03..04:06</td>
<td>148<sub>dec</sub> 14<sub>dec</sub> 13<sub>dec</sub> 8<sub>dec</sub></td>
</tr>
<tr>
<td align="center">47h</td>
<td>Метка диска</td>
<td align="center">11</td>
<td align="center">04:07..05:01</td>
<td>&ldquo;NO_NAME____&rdquo;</td>
</tr>
<tr>
<td align="center">52h</td>
<td>Аббревиатура файловой системы</td>
<td align="center">8</td>
<td align="center">05:02</td>
<td>&ldquo;FAT32___&rdquo;</td>
</tr>
<tr>
<td align="center">5Ah</td>
<td>Исполняемый код</td>
<td align="center">448</td>
<td align="center">05:10 &hellip;</td>
<td>00 ..</td>
</tr>
<tr>
<td align="center">1FEh</td>
<td>Сигнатура (55h AAh)</td>
<td align="center">2</td>
<td align="center">31:14</td>
<td>55 AA</td>
</tr>
</tbody>
</table>
<p>Пояснения к таблице:</p>
<ul>
<li>Первая строка: инструкция перехода на программу загрузки. Если сектор является загрузочным, то загрузчик <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> разместит этот сектор, адрес которого найдет в таблице разделов, в положенном месте и передаст управление ему, то есть, первому его байту. Однако код загрузчика сектора начинается не здесь, а по адресу 5Ah. Вот эти три байта и перебрасывают управление туда: EBh = jmp, а 58h = смещение.</li>
<li>Вторая строка иногда именуется &laquo;идентификатор изготовителя&raquo;, &laquo;идентификатор <abbr title="операционная система">ОС</abbr> или файловой системы&raquo;,встречал даже &laquo;название и версия Windows&raquo;. Строковая идентификация того, кто это все записал. Программа WinImage пишет сюда  &laquo;WINIMAGE&raquo;. Документ &laquo;<abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>: General Overview of On-Disk Format&raquo; рекомендует строку &laquo;MSWIN4.1&raquo;, как вызывающую минимум проблем совместимости. Имеет значение для некоторых <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>-драйверов. Для Windows вроде бы не имеет значения.</li>
</ul>
<p>Далее начинается блок параметров <abbr title="(Base Input-Output System) Базовая система ввода-вывода">BIOS</abbr> (<abbr title="(Base Input-Output System) Базовая система ввода-вывода">BIOS</abbr> parameter block, BPB) &mdash; структура данных, описывающая логическую структуру хранилища данных:</p>
<ul>
<li>Байтов в секторе (логическом), как мы договаривались, 512</li>
<li>Секторов в кластере 8, то есть, кластер четырехкилобайтный, довольно-таки распространенное значение.</li>
<li>Зарезервированных секторов 1. Поле не должно быть равно 0. Для FAT32 обычно равно 32. <abbr title="операционная система">ОС</abbr> от Microsoft нормально воспринимают любое ненулевое значение.</li>
<li>Таблиц <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>, традиционно, 2 &mdash; основная и резервная. Но мы-то знаем, что на самом деле ни одной.</li>
<li>Количество элементов корневого каталога. Для FAT32 должно быть 0.</li>
<li>Всего секторов в томе. 0 означает, что диск большой, больше 32МБ, поэтому размер будет задан по смещению 20h. Для FAT32 должно быть 0.</li>
<li>Тип носителя &mdash; жесткий диск (строго говоря, фиксированный, неудаляемый носитель. Для съемных носителей значение F0h). Должно быть таким же, как первый байт таблицы <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>.</li>
<li>Логических секторов в FAT12/FAT16, для FAT32 должно быть 0.</li>
<li>Физических секторов на дорожку &mdash; 63. Поле имеет значение только для носителей, имеющих дисковую геометрию. Почему 63? Списал откуда-то&hellip;</li>
<li>Число головок &mdash; FF. Тоже непонятно, зачем тут значение&hellip;</li>
<li>Скрытых (зарезервированных) секторов перед данным разделом &mdash; 62</li>
<li>Всего логических секторов в разделе (в 32-разрядном формате) &mdash; 1000h. Включает все сектора всех четырех областей раздела. Для FAT32 не должно быть равно 0.</li>
</ul>
<p>Далее идут отличия BPB FAT32 от FAT12/FAT16:</p>
<ul>
<li>Размер одной таблицы <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> &mdash; 8 секторов или 1 кластер</li>
<li>Главная таблица <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> нулевая. Вообще-то, поле флагов. Биты 0..3 &mdash; номер активной <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>, начиная с 0. Бит 7 равный 0 означает, что <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> в процессе работы отображается на все <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>, а равный 1 означает, что только одна <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> активна, и ее номер в битах 0..3. Биты 4..6 и 8..15 зарезервированы.</li>
<li>Версия <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> &mdash; 0.0. Если не равно 0, старые версии Windows не будут монтировать диск.</li>
<li>Начало корневого каталога &mdash; 2 кластер, так как 0 и 1 имеют особое значение в таблице <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>, ближе нельзя, дальше бессмысленно.</li>
<li>Номер сектора структуры FSINFO в зарезервированной зоне тома FAT32, обычно 1. Структура содержит данные о количестве свободных кластеров и указатель на следующий свободный кластер, используется алгоритмом выделения свободных секторов диска.</li>
<li>Резервный сектор. Если не 0, то указывает на номер сектора тома, в котором копия загрузочной записи. Обычно 6, другие значения не рекомендуются.</li>
<li>Зарезервировано для будущего использования, должно быть установлено в 0.</li>
<li>Номер физического диска &mdash; 80: первый диск в системе</li>
<li>Зарезервировано.</li>
<li>Сигнатура расширенного загрузчика, предопределенная константа. Показывает, что следующие три поля имеют место быть.</li>
<li>ID диска &mdash; идентификатор, поддерживающий отслеживание томов съемных носителей. Обычно генерируется путем комбинации текущих даты и времени в 32-р. формате, поэтому иногда это поле называют &laquo;дата и время создания диска&raquo;.</li>
<li>Метка диска. Не очень-то нужно, потому что есть в записи корневого каталога.</li>
<li>Аббревиатура файловой системы &mdash; &laquo;FAT32&raquo;, дополнено пробелами.</li>
</ul>
<p>Конец зоны BPB. Далее:</p>
<ul>
<li>Код загрузчика &mdash; заполняется нулями, загрузчика нет.</li>
<li>Сигнатура загрузочного сектора &mdash; предопределенная константа.</li>
</ul>
<p><strong>UPD <strong>(03.07.2017)</strong>:</strong>
Замечание относительно позиций по смещению 30h (Номер сектора структуры FSINFO) и по смещению 32h (Номер сектора - копии загрузочного).</p>
<p>В документе  &laquo;FAT32 File System Specification&raquo; от Microsoft (fatgen103.pdf) первое поле &mdash; номер сектора структуры FSINFO в зарезервированной зоне тома FAT32 &mdash; обычно 1, а второе не просто обычно 6, но еще и значения, отличные от 6, не рекомендуются.</p>
<p>Я поставил рекомендуемые значения в программе для контроллера платы USB-polygon, и она замечательно работала под Windows 7 и XP. Однако в Debian 8 автоопределение флэшки для этой платы не сработало. <code>fdisk -l</code> выдает следующее:</p>
<div class="highlight"><pre>Disk /dev/sdg: <span class="m">8</span> MiB, <span class="m">8388608</span> bytes, <span class="m">16384</span> sectors
Units: sectors of <span class="m">1</span> * <span class="nv">512</span> <span class="o">=</span> <span class="m">512</span> bytes
Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: <span class="m">512</span> bytes / <span class="m">512</span> bytes
I/O size <span class="o">(</span>minimum/optimal<span class="o">)</span>: <span class="m">512</span> bytes / <span class="m">512</span> bytes
Disklabel <span class="nb">type</span>: dos
Disk identifier: 0x00000000

Device     Boot Start   End Sectors Size Id Type
/dev/sdg1          <span class="m">62</span>  <span class="m">4157</span>    <span class="m">4096</span>   2M  c W95 FAT32 <span class="o">(</span>LBA<span class="o">)</span>
</pre></div>


<p>А при попытке монтирования вручную получаю ошибку:</p>
<div class="highlight"><pre>mount: wrong fs <span class="nb">type</span>, bad option, bad superblock on /dev/sdg1,
       missing codepage or helper program, or other error
</pre></div>


<p>А ранние варианты этой программы под Linux вполне определялись в виде флэшки. Существенная разница была именно в этих полях: сначала я их занулял, а потом уже послушался умных документов и поставил рекомендуемые значения. А зря. Если ставлю значения, должен был и добавить в указанные сектора соответствующую информацию. А ее там нет. Винда это дело проглотила, а Линукс &mdash; отказался.</p>
<p>Так что в моем (сильно упрощенном) случае правильнее держать в этих полях нулевое значение, тогда работает в Windows 7, XP, Debian 8, Android 4 &mdash; проверено лично.</p>
<h2 id="fat">Таблица <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr></h2>
<p>Важная структура данных, в честь которой и называется файловая система. Ну, здесь просто: список кластеров, занятых папками и файлами.</p>
<p>Причем, это односвязный список: каждый элемент является либо ссылкой на следующий элемент, либо признаком окончания цепочки элементов. Причем, для этого списка нет разницы между файлами и каталогами. Список состоит из 32-разрядных целых. Элемент, заполненный единицами (FFFFFFFFh), говорит о том, что он последний в цепи. Если он же и первый, значит, соответствующий ему файл (или каталог) занимает один кластер.</p>
<p>Строго говоря, в 32-разрядных элементах записаны 28-разрядные значения, старшие 4 бита зарезервированы и должны быть установлены в ноль, а точнее, должны сохранять предыдущее значение, для чего записываться с использованием маски. Но эти тонкости нужны для реализации программ чтения/записи структур <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>, например, драйверов <abbr title="файловая система">ФС</abbr>, а нам пока не важно. Поэтому маркер конца цепочки &mdash; элемент, заполненный единицами &mdash; на самом деле 0FFFFFFFh.</p>
<p>В FAT32 (в отличие от предыдущих версий <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>) корневой каталог равноправен с прочими папками и файлами. Указатель на него лежит в BPB, в загрузочной записи раздела. Обычно это 2, так как кластеры 0 и 1 имеют особое назначение. Теоретически корневой каталог можно разместить и дальше второй позиции, где-нибудь в середине таблицы (тогда физически он должен быть записан где-нибудь в середине памяти раздела), но в этом нет практического смысла.</p>
<p>Значит, кластер 2 соответствует корневому каталогу. В целях имитации <abbr title="файловая система">ФС</abbr> делать корневой каталог большего размера нет смысла: сильно много не наимитируешь. Поэтому элемент номер 2 будет 0FFFFFFFh. В области данных будет лежать кластер, соответствующий этому элементу, и там будет информация о том, где искать файлы, расположенные в корневом каталоге (а возможно, и вложенные папки второго уровня). То есть, будут ссылки на первые кластеры, а последующую цепочку драйвер <abbr title="файловая система">ФС</abbr> должен найти в таблице <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>: по ссылке найти первый кластер, и если он не заполнен единицами, то указывает на следующий элемент. Добравшись до последнего, драйвер будет знать, сколько в файле кластеров и где они лежат.</p>
<p>Есть значения для элементов файловой таблицы, сигнализирующие о том, что соответствующий кластер поврежден или зарзервирован, но в нашем случае реальных кластеров нет, повреждать и резервировать нечего, и такие значения не рассматриваются.</p>
<p>В целях имитации, когда точно известны параметры фейковых файлов, можно разместить их в фейковой же файловой таблице строго последовательно. Вразброс же файлы размещаются в результате фрагментации: когда записывается файл большего размера, чем первый свободный участок, и часть его пишется в ближайшее найденное пустое место, часть &mdash; в следующее пустое место. А у нас &mdash; все подряд. Допустим, в корне будет имитироваться файл, занимающий три кластера, тогда в файловой таблице элемент №3 будет содержать число 4 (запишется 04 00 00 00 00 00 00 00, младшим байтом вперед), элемент №4 будет содержать 5, а в элементе №5 будет записано 0FFFFFFFh. Дальше должны быть нули, сигнализирующие о том, что кластеры свободны.</p>
<p>Элементы файловой таблицы с номерами 0 и 1 имеют особое значение. Младший байт нулевого должен содержать тип носителя из BPB, в нашем случае &mdash; F8h. Остальные байты нулевого равны FFh. Второй элемент заполняется FFh целиком и может использоваться в FAT32 для указания необходимости проверки тома: верхние два бита обнуляются, а перед завершением работы с носителем туда снова записываютмя единицы. Если в свежезапущенном томе обнаружены в этом месте нули, значит он некорректно завершил работу, например, был внезапно обесточен или выдернут.</p>
<p>Стало быть, для примера начало файловой таблицы должно выглядеть, как в таблице 5, в предположении, что корневой каталог короткий (умещается в одном кластере, что естественно при малом количестве файлов), первый файл занимает три кластера, второй файл занимает один кластер, больше файлов и папок нет.</p>
<p>Таблица 5. Описатель файла в каталоге</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th>#</th>
<th>Назначение<br>элемента</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Элемент <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>[0]</td>
<td align="center">F8</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">0F</td>
</tr>
<tr>
<td>1</td>
<td>Элемент <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>[1]</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">0F</td>
</tr>
<tr>
<td>2</td>
<td>Корневой каталог</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">0F</td>
</tr>
<tr>
<td>3</td>
<td>Начало длинного файла</td>
<td align="center">04</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
<tr>
<td>4</td>
<td>Продолжение длинного файла</td>
<td align="center">05</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
<tr>
<td>5</td>
<td>Окончание длинного файла</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">0F</td>
</tr>
<tr>
<td>6</td>
<td>Короткий файл</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">FF</td>
<td align="center">0F</td>
</tr>
<tr>
<td>7</td>
<td>Начало зоны пустых кластеров</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
</tbody>
</table>
<p>Восемь столбцов &mdash; с третьего по десятый &mdash; соответствуют восьми байтам элементов таблицы (с нулевого по седьмой).</p>
<h2 id="root">Файловая запись root</h2>
<p>Запись, соответствующая корневому каталогу. Как тут уже упоминалось, в FAT32 корневой каталог равноправен с прочими папками и файлами в том смысле, что не обязан находиться по строго определенному адресу и иметь строго определенные размеры. Найти его можно по указателю в BPB, а размер определяется на общих основаниях, по цепочке кластеров в виде односвязного списка в файловой таблице.</p>
<p>Все остальные файлы и папки ищутся рекурсивно, отталкиваясь от корневого каталога. То есть, файлы и папки первого уровня вложенности имеют указания на свое местоположение в корневом каталоге, второго уровня &mdash; в папках первого уровня, и так далее.</p>
<p>Каталог (ну, или папка, или директория) фактически является файлом. Лежит в области диска, соответствующей некоторому элементу файловой таблицы, содержит некоторые данные, занимает минимум кластер. Вот только эти данные не абы что, а набор описателей того, что принадлежит каталогу: файлы и папки. При этом, в папке должны быть описатели папок с именами &laquo;.&raquo; и &laquo;..&raquo;, указывающими на текущий и родительский каталоги соответственно. Описатель является структурой данных определенного размера, 32 байта.</p>
<p>Отсюда, кстати, следует, что пустой файл может быть записан в каталоге, но не занимать места на диске и иметь реальный размер, равный 0, однако пустой каталог не может быть совсем пустым, должен содержать минимум 2 описателя и будет занимать кластер. Значит, пустые каталоги &mdash; мусор, изрядно засоряющий носитель.</p>
<p>Запись корневого каталога все же имеет некоторые отличия от прочих папок. Она обязательно должна быть, она не имеет имени, даты и времени создания, не содержит файлы &laquo;.&raquo; и &laquo;..&raquo; в качестве первых двух подпапок, она единственная может иметь файл с установленным аттрибут VOLUME_ID, и тогда имя, записанное в соответствующем поле этой записи, будет именем тома. Адрес первого кластера (в полях &laquo;старшее слово первого кластера&raquo; и &laquo;младшее слова первого кластера&raquo;) такой записи так же должен быть равен нулю, потому что для &laquo;файла&raquo;, соответствующего метке тома, не выделяются реальные кластеры. Соответственно, размер этого &laquo;файла&raquo; тоже должен быть нулевым.</p>
<p>Тогда первый описатель &laquo;файла&raquo; в корневом каталоге должен выглядеть, как в таблице 6.</p>
<p>Таблица 6. Описатель файла-тома в каталоге</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">Адр.</th>
<th align="center">Разм.</th>
<th>Значение</th>
<th align="center">r:c</th>
<th>hex</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0h</td>
<td align="center">8</td>
<td>Имя файла, дополненное справа пробелами до 8</td>
<td align="center">00:00..00:07</td>
<td>&ldquo;LUFA____&rdquo;</td>
</tr>
<tr>
<td align="center">8h</td>
<td align="center">3</td>
<td>Расширение, дополненное справа пробелами до 3</td>
<td align="center">00:08..00:10</td>
<td>&rdquo;___&rdquo;</td>
</tr>
<tr>
<td align="center">0Bh</td>
<td align="center">1</td>
<td>0x80 - 0: резерв<br>0x40 - 0: резерв<br>0x20 - A: бит &ldquo;архивный&rdquo;<br>0x10 - D: бит &ldquo;каталог&rdquo;<br>0x08 - V: бит &ldquo;VOLUME_ID &ldquo;<br>0x04 - S: бит &ldquo;системный&rdquo;<br>0x02 - H: бит &ldquo;скрытый&rdquo;<br>0x01 - R: бит &ldquo;только для чтения&rdquo;</td>
<td align="center">00:11</td>
<td>08</td>
</tr>
<tr>
<td align="center">0Ch</td>
<td align="center">1</td>
<td>Резерв</td>
<td align="center">00:12</td>
<td>00</td>
</tr>
<tr>
<td align="center">0Dh</td>
<td align="center">1</td>
<td>Сотые доли секунды создания файла (0..199)</td>
<td align="center">00:13</td>
<td>00</td>
</tr>
<tr>
<td align="center">0Eh</td>
<td align="center">2</td>
<td>Время создания файла</td>
<td align="center">00:14</td>
<td>00</td>
</tr>
<tr>
<td align="center">10h</td>
<td align="center">2</td>
<td>Дата создания файла</td>
<td align="center">01:00</td>
<td>00</td>
</tr>
<tr>
<td align="center">12h</td>
<td align="center">2</td>
<td>Дата последнего обращения к файлу</td>
<td align="center">01:02</td>
<td>00</td>
</tr>
<tr>
<td align="center">14h</td>
<td align="center">2</td>
<td>Старшее слово первого кластера файла</td>
<td align="center">01:04</td>
<td></td>
</tr>
<tr>
<td align="center">16h</td>
<td align="center">2</td>
<td>Время последнего изменения:<br>0..4 - пары секунд 0..29<br>5..10 - минуты 0..59<br>11..15 - часы 0..23</td>
<td align="center">01:06</td>
<td>00</td>
</tr>
<tr>
<td align="center">18h</td>
<td align="center">2</td>
<td>Дата последнего изменения:<br>0..4 - день 0..31<br>5..10 - месяц 1..12<br>11..15 - год, начиная с 1980 (0..119)</td>
<td align="center">01:08</td>
<td>00</td>
</tr>
<tr>
<td align="center">1Ah</td>
<td align="center">2</td>
<td>Младшее слово первого кластера</td>
<td align="center">01:10</td>
<td>00</td>
</tr>
<tr>
<td align="center">1Ch</td>
<td align="center">4</td>
<td>Размер файла в байтах</td>
<td align="center">01:12..01:15</td>
<td>00</td>
</tr>
</tbody>
</table>
<h2 id="_5">Прочие файловые записи</h2>
<p>В кластере, соответствующем корневому каталогу, вслед за приведенным выше описателем метки тома могут располагаться описатели вложенных файлов и папок. Для целей имитации <abbr title="файловая система">ФС</abbr> папки, пожалуй, будут излишеством, а несколько файлов положить надо. В таких описателях стоит заполнить имя файла, придумать вменяемое время создания файла, указать первый кластер, равный 3 для первого файла, и размер, укладывающийся в число кластеров, занятое соответствующей цепочкой списка в файловой таблице. Для следующего файла первый кластер будет смещен от 3 на число кластеров первого, и так далее.</p>
<p>При имитации <abbr title="файловая система">ФС</abbr> это все надо будет формировать динамически, в соответствии с &laquo;файлами&raquo;, которые планируется подсовывать читающей <abbr title="операционная система">ОС</abbr>.</p>
<p>Поля файлового описателя приведены в таблице 6, повторять которую нет надобности. Можно разве что остановиться поподробнее на ее полях.</p>
<p>Имя файла предполагается короткое, в формате &laquo;8.3&raquo;, дополненное до нужной длины пробелами, непременно на латинице. Можно сделать и длиннее, и в другой кодировке, но это отдельный разговор. Для таких манипуляций потребуются дополнительные описатели, которые и подъедят ресурсы при имитации, и не являются действительно необходимыми.</p>
<p>Поле файловых атрибутов битовое, его значения понятны из названий битов, которые приведу ниже, в константах.</p>
<p>Многие файловые системы <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> не поддерживают метки времени, кроме времени записи, поэтому поля &laquo;сотые доли секунды времени создания&raquo;, &laquo;время создания&raquo;, &laquo;дата создания&raquo; и &laquo;дата последнего обращения&raquo; являются необязательными и могут быть равны 0. Однако, поля &laquo;время записи&raquo; и &laquo;дата записи&raquo; должны поддерживаться.</p>
<p>Поля даты считаются 16-разрядными словами относительно эпохи MS-DOS 01.01.1980. При этом:</p>
<ul>
<li>Биты 0..4 содержат число месяца в диапазоне от 1 до 31.</li>
<li>Биты 5..8 содержат номер месяца в диапазоне от 1 до 12.</li>
<li>Биты 9..15 содержат год от 1980-го в диапазоне от 0 до 127 (от 1980 до 2107).</li>
</ul>
<p>Поля времени считаются 16-разрядными словами с двухсекундной дискретизацией. При этом:</p>
<ul>
<li>Биты 0..4 &mdash; число пар секунд в диапазоне от 0 до 29 (от 0 до 58 секунд).</li>
<li>Биты 5..8 &mdash; минуты в диапазоне от 0 до 59.</li>
<li>Биты 9..15 &mdash; часы в диапазоне от 0 до 23.</li>
</ul>
<p>Номер первого кластера разбит на два слова, старшее и младшее, всего 32 разряда.</p>
<p>На основе написанного выше можно подготовить данные для передачи в ответ на запросы по определенным адресам, чтобы запрашивающая <abbr title="операционная система">ОС</abbr> была уверена, что обращается к реальному носителю информации.</p>
<h2 id="const">Важные константы</h2>
<p>Перед тем, как реализовывать это все в программе, хотелось бы подготовить ряд констант, которые следует определить и использовать в коде.</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th>Имя</th>
<th>Описание</th>
<th>Значение</th>
</tr>
</thead>
<tbody>
<tr>
<td>Файловые атрибуты</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ATTR_READ</td>
<td>Только для чтения</td>
<td>0x01</td>
</tr>
<tr>
<td>ATTR_HIDDEN</td>
<td>Скрытый</td>
<td>0x02</td>
</tr>
<tr>
<td>ATTR_SYSTEM</td>
<td>Системный</td>
<td>0x04</td>
</tr>
<tr>
<td>ATTR_VOL_LABEL</td>
<td>Метка тома</td>
<td>0x08</td>
</tr>
<tr>
<td>ATTR_DIR</td>
<td>Папка (каталог)</td>
<td>0x10</td>
</tr>
<tr>
<td>ATTR_ARCHIVE</td>
<td>Архивный</td>
<td>0x20</td>
</tr>
<tr>
<td>ATTR_LONG_FNAME</td>
<td>Имеет длинное имя</td>
<td>0x0F</td>
</tr>
<tr>
<td>Размеры</td>
<td></td>
<td></td>
</tr>
<tr>
<td>BYTES_PER_SECTOR</td>
<td>Байтов в секторе</td>
<td>512</td>
</tr>
<tr>
<td>BYTES_PER_SECT_SHIFT</td>
<td></td>
<td>9</td>
</tr>
<tr>
<td>SECTORS_PER_CLUSTER</td>
<td>Секторов в кластере</td>
<td>8</td>
</tr>
<tr>
<td>SECTORS_PER_CLUST_SHIFT</td>
<td></td>
<td>3</td>
</tr>
<tr>
<td>BYTES_PER_CLUSTER</td>
<td>Байтов в кластере</td>
<td>(BYTES_PER_SECTOR * SECTORS_PER_CLUSTER)</td>
</tr>
<tr>
<td>BYTES_PER_CLUST_SHIFT</td>
<td></td>
<td>(BYTES_PER_SECT_SHIFT + SECTORS_PER_CLUST_SHIFT)</td>
</tr>
<tr>
<td>Адреса, смещения</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SECTORS_PER_FAT</td>
<td>Секторов на таблицу <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr></td>
<td>8</td>
</tr>
<tr>
<td>MBR_SECTOR</td>
<td>Сектор <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr></td>
<td>0</td>
</tr>
<tr>
<td>BOOT_SECTOR</td>
<td>Загрузочный сектор раздела</td>
<td>62</td>
</tr>
<tr>
<td>FAT1_SECTOR</td>
<td>Сектор первой файловой таблицы</td>
<td>(BOOT_SECTOR + 1)</td>
</tr>
<tr>
<td>FAT2_SECTOR</td>
<td>Сектор второй файловой таблицы</td>
<td>(FAT1_SECTOR + SECTORS_PER_FAT)</td>
</tr>
<tr>
<td>ROOT_SECTOR</td>
<td>Сектор корневого каталога</td>
<td>(FAT2_SECTOR + SECTORS_PER_FAT)</td>
</tr>
<tr>
<td>ROOT_CLUSTER</td>
<td>Кластер корневого каталога</td>
<td>(SECTORS_PER_FAT * 2 / SECTORS_PER_CLUSTER)</td>
</tr>
</tbody>
</table>
<p>Константы с постфиксом _SHIFT полезны при вычислениях кратных величин. Так как число байтов в кластере кратно степени двойки, можно получить число байтов в N кластерах не умножая N на 512, а сдвинув влево на 8, на степень двойки. Это эконмит ресурсы: сдвиг проще и быстрее умножения.</p>
<p>Теперь можно попробовать реализовать имитацию этого всего в программе устройства.</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "usb-polygon-10.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>