<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-4: Обмен по USB, начало</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">14</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/nishchebrod.html">
              нищеброд
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/pokhodnoe.html">
              походное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Вт 27 Сентябрь 2016</h4>
    <article>
      <h1>USB-polygon-4: Обмен по USB, начало</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Выбор класса устройства</a></li>
<li><a href="#_2">Выбор библиотеки</a></li>
<li><a href="#_3">Подготовка</a></li>
<li><a href="#_4">&laquo;&hellip; доработать напильником&raquo;</a></li>
<li><a href="#_5">Маленькое расширение программы</a></li>
<li><a href="#_6">Что дальше?</a></li>
</ul>
</div>
<h2 id="_1">Выбор класса устройства</h2>
<p>Продолжаю разговор про самодельную отладочную плату на контроллере AT90USB162.</p>
<p>В примененном контроллере есть возможность подключения к компьютеру по USB. Прежде чем использовать эту возможность, нужно определиться с классом устройства. Операционная система будет общаться с устройством посредством драйверов и выбирать соответствующий драйвер в зависимости от класса. Так что же выбрать?</p>
<p>В той же <a href="https://en.wikipedia.org/wiki/USB#PHDC">Википедии</a> насчитывается порядка двух десятков классов USB-устройств. Для сделанной отладочной платы можно сразу исключить узкоспецифичные, например, Audio, Video, Image, Printer и прочее подобное, а также Wireless Controller, поскольку к беспроводной связи этот макет не приспособлен совсем. Тогда выбор ограничивается такими классами:</p>
<ul>
<li>00 Unspesified</li>
<li>02 Communication Device Class &amp; 0A CDC-data</li>
<li>03 Human Interface Device</li>
<li>05 Physical Interface Device</li>
<li>08 MassStorage Device Class</li>
<li>DC Diagnostic Device</li>
<li>EF Miscellaneous</li>
<li>FE Application-specific</li>
<li>FF Vendor-specific</li>
</ul>
<p>Классы Unspesified, Application-specific, Vendor-specific, Miscellaneous страшновато даже рассматривать. Явно придется делать много работы вручную &mdash; писать кучу кода для устройства, наверняка писать драйвер для операционной системы. Хотелось бы для начала что-то попроще.</p>
<p>Про Diagnostic Device и Physical Interface Device не нашел информации. То есть, составить представление, что это за штуки такие &mdash; можно, а как это сделать самому, да попроще &mdash; не нашел.</p>
<p>CDC &mdash; вроде бы неплохой класс, предназначенный для передачи приличных объемов информации в обоих направлениях. И теоретически эту информацию можно использовать не только таким способом, какой предполагает класс устройства, то есть, не только для преобразования в другие виды интерфейсов (типа COM), но и для управления самим устройством и даже для хранения на устройстве. Но все же этот класс тоже достаточно специфичен и узконаправлен. Не понравился он мне.</p>
<p>HID &mdash; ничего себе штучка для реализации устройства с небольшими объемами и скоростями циркулирующей информации. В Windows работа с ним довольно проста благодаря встроенным драйверам. Я даже попробовал как-то сделать простенькую макетку на AT89C5131 по книге Агурова. Все оказалось довольно просто, где-то за неделю (занимаясь вечерами) устройство заработало. Однако у этого класса есть несколько минусов, которые мне сильно не понравились. Во-первых, хотя драйвер такому устройству не нужен, все же нужен INF-файл. То есть, воткнуть в любой компьютер, чтобы сразу заработало, не получится. Во-вторых, скорости обмена весьма дохленькие. Для моргания светодиодиком &mdash; более чем достаточно, но я еще не знаю, во что выльется мой макет. Есть предположение, что в инструмент для настройки и отладки другого прибора с передачей приличных объемов информации, с записью промежуточных результатов работы в файл с последующим считыванием и все такое. Кроме того, после беглого обзора по форумам у меня сложилось впечатление, что в Linux работа с HID далеко не так проста, как в Windows, а как с этим делом в Android, я вообще не понял.</p>
<p>MassStorage Device &mdash; на первый взгляд самое оно. Рассчитано на большие объемы информации, удовлетворительные скорости, в современных ОС не требует драйверов для установки. Да что там, современных &mdash; где-то с Windows Me уже не требует. Тоже, конечно, не без недостатков. Во-первых, обмен может вестись только по инициативе хост-устройства, то есть, компьютера. Во-вторых, не мешало бы реализовать файловую систему, даже если она не нужна вовсе. Хотя, можно и обойтись, но придется заниматься костылевелосипедостроением. Опять же, строить файловую систему там, где она не нужна &mdash; тоже велосипедокостыли те еще. И в-третьих, забегая вперед, уже после реализации этого класса был обнаружен неприятный факт: работа с MassStorage кэшируется ОС, и изменения на устройстве, видимые под видом файлов, системой игнорируются, так как данные читаются один раз ив дальнейшем берутся не из устройства, а из кэша. Это, конечно, можно объехать на кривой козе, но придется что-то писать вручную, а что именно &mdash; я пока не знаю.</p>
<p>Есть еще казалось бы заманчивый вариант: MTP, Media Transfer Protocol. Активно используется современными смартфонами на Android. Вроде бы позволяет и обновившиеся данные в файлах перечитывать, и потоковые данные передавать/забирать. Вот только беглый обзор реализации на устройстве немного пугает, а поддержка в ОС огорчает: мне, к сожалению, надо еще пользоваться местами Windows XP, а я не смог по-человечески подключить к ней свой смартфон с четвертым андроидом. В семерке &mdash; вопросов нет, в восьмом Debian &mdash; тоже, но мне-то и XP надо. Опять же, вопрос &mdash; можно ли подключить MTP-устройство к, скажем, планшету с Android? Пока не знаю, а MassStorage &mdash; однозначно можно. Плюс к этому относительно невысокая скорость обмена большими объемами и разработчик &mdash; Microsof, что настораживает.</p>
<p>В общем, остановился на MassStorage Device, попросту говоря, флэшка.</p>
<h2 id="_2">Выбор библиотеки</h2>
<p>Несколько лет назад, как я уже упоминал, попробовал сделать простую макетку на AT89C5131. Никаких библиотек не использовал, но тогда и выбора особого не было, и с HID-устройствами работать несколько проще, и я тогда предпочитал собственные велосипеды готовым решениям даже в ущерб простоте и скорости написания кода. Сегодня я сначала посмотрю, нельзя ли подтянуть что-то готовое. Конечно, не всегда использование библиотек является оптимальным, например, если огромный монстр имеет тучу возможностей, а надо только моргнуть диодиком, или наоборот, дохленький кусочек кода для своих целей еще пилить и пилить, так что проще сразу с нуля начать. Ну, посмотрим, что есть готового.</p>
<p>Во-первых, конечно, родная атмеловская библиотека. В ней привлекает то, что она все же родная, под эти контроллеры заточенная, да еще и самим производителем. Документация опять же на сайте Atmel имеется, и на первый взгляд даже неплохая и с примерами.</p>
<p>Во-вторых, одна из самых популярных (по встречаемости на форумах и в результатах выдачи поисковиков) библиотека LUFA. Очень хорошие отзывы на форумах, широкий спектр применения, уже образовавшееся сообщество с возможностью найти ответы на возникающие вопросы, очень нетребовательная лицензя MIT (если вдруг макет перерастет во что-то значительное). Заточена под AVR-GCC, входящий в состав AVR-Toolchain, то есть, с чем я и так собирался работать.</p>
<p>В-третьих, V-USB. Библиотека с обилием примеров применения, но ее основной фишкой является программная эмуляция USB для контроллеров, не имеющих аппаратной реализации, кроме того, с ее использованием в основном встречались HID-устройства. Впрочем, достаточно и того, что это программная эмуляция. Не нужно.</p>
<p>В-четвертых, все прочие, типа Dr. Stefan Salewski&rsquo;s AT90USB1287 Stack, PJRC Teensy Stack и все такое. Не очень популярные решения разного рода, имеющие крайне мало примеров, где можно было бы подсмотреть особенности практического применения. Не вижу причин использовать что-то из них, поскольку это именно тот случай, когда допиливать может оказаться не проще, чем собрать с нуля самому.</p>
<p>Посмотрел бегло по диагонали документацию к USB-стеку Atmel и описание примеров. Потом заглянул на <a href="http://www.fourwalledcubicle.com/LUFA.php">страничку LUFA</a>, где ознакомился с кратким описанием, скачал библиотеку и документацию. И LUFA понравилась больше. Порылся немножко по форумам: там тоже решение от Atmel больше ругают, чем хвалят, а LUFA &mdash; наоборот. Ладно, выбираю LUFA.</p>
<h2 id="_3">Подготовка</h2>
<p>На упомянутой чуть выше страничке LUFA скачал саму библиотеку и документацию к ней. В архиве с библиотекой есть папка <code>LUFA</code> &mdash; собственно, библиотека, и папка <code>DEMOS</code> &mdash; это не &laquo;народ&raquo; по-гречески, это примеры применения. Примеры замечательные и на самые разные случаи жизни, для устройств, хостов и приборов, которые способны и на то, и на другое. В папке <code>lufa-LUFA-151115\Demos\Device\LowLevel\</code> можно найти и аудиоустройство, и мышь с клавиатурой, и HID, но, самое главное, там есть MassStorage. </p>
<p>Делаю отдельную папку для проекта, скажем, <code>lufa-test</code>, и копирую в нее упомянутые <code>LUFA</code> и <code>MassStorage</code>. Разумеется, библиотеку можно не копировать, на то она и библиотека, но мало ли&hellip; Вдруг захочется поковыряться немного в ее исходниках, так чтоб не запороть оригинал. А уж в <code>MassStorage</code> буду ковыряться по полной программе, для того и копирую. Это будет основная папка проекта для макета.</p>
<p>Там уже лежит Makefile, значит, можно попробовать запустить <code>make</code>, но не просто так, а в предварительно настроенном cygwin (о выборе и настройке компилятора &mdash; в предыдущем <a href="http://romeogolf.github.io/usb-polygon-3.html">выпуске</a> цикла). Сперва захожу в соответствующую папку:</p>
<div class="highlight"><pre><span class="nv">$ </span><span class="nb">cd</span> /cygdrive/k/radio/asm/lufa-test/MassStorage/
</pre></div>


<p>и командую <code>make</code>. Получаю ответ:</p>
<div class="highlight"><pre>makefile:38: ../../../../LUFA/Build/lufa_atprogram.mk: No such file or directory
make: *** Нет правила для сборки цели «../../../../LUFA/Build/lufa_atprogram.mk».  Останов.
</pre></div>


<p>Что не удивительно. Надо было все-таки сначала открыть и отредактировать Makefile под свои нужды. Для начала надо найти в нем переменную <code>LUFA_PATH</code> и оставить в ней только одну пару точек в пути: <code>../LUFA</code>.</p>
<p>Вот теперь <code>make</code> замечательно запускается, проект компилируется, в папке проекта создаются всякого рода файлы, которых не было. Даже появился MassStorage.hex, который можно прошить в устройство посредством FLIP. Вот только не стоит пока этого делать &mdash; бесполезно. </p>
<p>Первая же переменная в Makefile &mdash; <code>MCU</code> &mdash; указывает на контроллер at90usb1287, а у меня at90usb162.
Третья переменная &mdash; <code>BOARD</code> &mdash; указывает на какую-то отладочную плату. Не важно, какую, важно, что у меня &mdash; никакая, в списках не значится. </p>
<p>Однако, начало положено, есть какая-то заготовка.</p>
<h2 id="_4">&laquo;&hellip; доработать напильником&raquo;</h2>
<p>Начинаю подгонять заготовку под то, что имеется.</p>
<p>Для начала заменяю в Makefile значение <code>MCU</code> с <code>at90usb1287</code> на <code>at90usb162</code>, а значение <code>BOARD</code> &mdash; на <code>NONE</code>, чищу результаты компиляции при помощи <code>make clean</code> и снова запускаю <code>make</code>. Компиляция сваливается с ошибкой. Да не с одной, а с целой кучей:</p>
<div class="highlight"><pre>... до сих пор более-менее нормально ...

Lib/DataflashManager.c: In <span class="k">function</span> <span class="s1">&#39;DataflashManager_WriteBlocks&#39;</span>:
Lib/DataflashManager.c:52:77: warning: division by zero <span class="o">[</span>-Wdiv-by-zero<span class="o">]</span>
  uint16_t <span class="nv">CurrDFPage</span>          <span class="o">=</span> <span class="o">((</span>BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE<span class="o">)</span> / D
ATAFLASH_PAGE_SIZE<span class="o">)</span><span class="p">;</span>
                                                                             ^
Lib/DataflashManager.c:53:77: warning: division by zero <span class="o">[</span>-Wdiv-by-zero<span class="o">]</span>
  uint16_t <span class="nv">CurrDFPageByte</span>      <span class="o">=</span> <span class="o">((</span>BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE<span class="o">)</span> % D
ATAFLASH_PAGE_SIZE<span class="o">)</span><span class="p">;</span>
                                                                             ^
Lib/DataflashManager.c:68:21: error: <span class="s1">&#39;DF_CMD_BUFF1WRITE&#39;</span> undeclared <span class="o">(</span>first use i
n this <span class="k">function</span><span class="o">)</span>
  Dataflash_SendByte<span class="o">(</span>DF_CMD_BUFF1WRITE<span class="o">)</span><span class="p">;</span>
                     ^
Lib/DataflashManager.c:68:21: note: each undeclared identifier is reported only 
once <span class="k">for</span> each <span class="k">function</span> it appears in
Lib/DataflashManager.c:98:44: error: <span class="s1">&#39;DF_CMD_BUFF2TOMAINMEMWITHERASE&#39;</span> undeclared
 <span class="o">(</span>first use in this <span class="k">function</span><span class="o">)</span>
     Dataflash_SendByte<span class="o">(</span>UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_
CMD_BUFF1TOMAINMEMWITHERASE<span class="o">)</span><span class="p">;</span>
                                            ^
Lib/DataflashManager.c:98:77: error: <span class="s1">&#39;DF_CMD_BUFF1TOMAINMEMWITHERASE&#39;</span> undeclared
 <span class="o">(</span>first use in this <span class="k">function</span><span class="o">)</span>
     Dataflash_SendByte<span class="o">(</span>UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_
CMD_BUFF1TOMAINMEMWITHERASE<span class="o">)</span><span class="p">;</span>
                                                                             ^
In file included from ../LUFA/../LUFA/Drivers/USB/USB.h:382:0,
                 from Lib/../Descriptors.h:40,
                 from Lib/../MassStorage.h:45,
                 from Lib/DataflashManager.h:42,
                 from Lib/DataflashManager.c:40:
../LUFA/../LUFA/Drivers/Board/Dataflash.h:141:60: error: <span class="s1">&#39;DATAFLASH_CHIP0&#39;</span> undec
lared <span class="o">(</span>first use in this <span class="k">function</span><span class="o">)</span>
    <span class="c">#define DATAFLASH_CHIP_MASK(index)      CONCAT_EXPANDED(DATAFLASH_CHIP, inde</span>
x<span class="o">)</span>
                                                            ^
../LUFA/../LUFA/Drivers/USB/../../Common/Common.h:210:37: note: in definition of
 macro <span class="s1">&#39;CONCAT&#39;</span>
     <span class="c">#define CONCAT(x, y)            x ## y</span>
                                     ^
... и тому подобное ...
</pre></div>


<p>И при беглом просмотре похоже на то, что все ошибки связаны с DataflashManager, модулем, расположенным тут же в папке <code>Lib</code>. Модуль явно отвечает за управление флэш-памятью, это видно даже из названия, но написано и внутри в Doxygen-комментарии. А у меня на плате флэш нету и в ближайшем будущем не ожидается. Попробую тупо вырезать это дело: убираю в Makefile из значения переменной <code>SRC</code> запись &laquo;<code>Lib/DataflashManager.c</code>&raquo;, в h-файлах закрываю &laquo;<code>include "DataflashManager.h"</code>&raquo;, в MassStorage.c и SCSI.c нахожу и закрываю (символами комментария) все строки с функциями, начинающимися с <code>Dataflash</code>. Причем, естественно, не только сами строки, но всю содержащую конструкцию, типа <code>if</code>, скажем.</p>
<div class="highlight"><pre><span class="nv">$ </span>make
 <span class="o">[</span>INFO<span class="o">]</span>    : Begin compilation of project <span class="s2">&quot;MassStorage&quot;</span>...

avr-gcc.exe <span class="o">(</span>AVR_8_bit_GNU_Toolchain_3.5.2_1680<span class="o">)</span> 4.9.2
Copyright <span class="o">(</span>C<span class="o">)</span> <span class="m">2014</span> Free Software Foundation, Inc.
This is free software<span class="p">;</span> see the <span class="nb">source </span><span class="k">for</span> copying conditions.  There is NO
warranty<span class="p">;</span> not even <span class="k">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 <span class="o">[</span>GCC<span class="o">]</span>     : Compiling C file <span class="s2">&quot;SCSI.c&quot;</span>
avr-gcc -c -pipe -gdwarf-2 -g2 -mmcu<span class="o">=</span>at90usb162 -fshort-enums -fno-inline-small-
functions -fpack-struct -Wall -fno-strict-aliasing -funsigned-char -funsigned-bi
tfields -ffunction-sections -I. -I../LUFA/.. -DARCH<span class="o">=</span>ARCH_AVR8 -DBOARD<span class="o">=</span>BOARD_NONE
-DF_USB<span class="o">=</span>8000000UL -DF_CPU<span class="o">=</span>8000000UL -mrelax -fno-jump-tables -x c -Os -std<span class="o">=</span>gnu9 
<span class="m">9</span> -Wstrict-prototypes -DUSE_LUFA_CONFIG_HEADER -IConfig/  -MMD -MP -MF Lib/SCSI.
d Lib/SCSI.c -o Lib/SCSI.o
Lib/SCSI.c: In <span class="k">function</span> <span class="s1">&#39;SCSI_Command_Read_Capacity_10&#39;</span>:
Lib/SCSI.c:216:23: error: <span class="s1">&#39;LUN_MEDIA_BLOCKS&#39;</span> undeclared <span class="o">(</span>first use in this funct
ion<span class="o">)</span>
  Endpoint_Write_32_BE<span class="o">(</span>LUN_MEDIA_BLOCKS - 1<span class="o">)</span><span class="p">;</span>
                       ^
Lib/SCSI.c:216:23: note: each undeclared identifier is reported only once <span class="k">for</span> ea
ch <span class="k">function</span> it appears in
Lib/SCSI.c:219:23: error: <span class="s1">&#39;VIRTUAL_MEMORY_BLOCK_SIZE&#39;</span> undeclared <span class="o">(</span>first use in t
his <span class="k">function</span><span class="o">)</span>
  Endpoint_Write_32_BE<span class="o">(</span>VIRTUAL_MEMORY_BLOCK_SIZE<span class="o">)</span><span class="p">;</span>
                       ^
Lib/SCSI.c: In <span class="k">function</span> <span class="s1">&#39;SCSI_Command_ReadWrite_10&#39;</span>:
Lib/SCSI.c:298:22: error: <span class="s1">&#39;LUN_MEDIA_BLOCKS&#39;</span> undeclared <span class="o">(</span>first use in this funct
ion<span class="o">)</span>
  <span class="k">if</span> <span class="o">(</span>BlockAddress &gt;<span class="o">=</span> LUN_MEDIA_BLOCKS<span class="o">)</span>
                      ^
Lib/SCSI.c:320:62: error: <span class="s1">&#39;VIRTUAL_MEMORY_BLOCK_SIZE&#39;</span> undeclared <span class="o">(</span>first use in t
his <span class="k">function</span><span class="o">)</span>
  CommandBlock.DataTransferLength -<span class="o">=</span> <span class="o">((</span>uint32_t<span class="o">)</span>TotalBlocks * VIRTUAL_MEMORY_BLO
CK_SIZE<span class="o">)</span><span class="p">;</span>
                                                              ^
make: *** <span class="o">[</span>../LUFA/Build/lufa_build.mk:295: Lib/SCSI.o<span class="o">]</span> Ошибка 1
</pre></div>


<p>После компиляции стало чуть получше, то есть, ошибок поменьше, но &laquo;чуть&raquo; не считается, потому что все равно не компилируется. А это потому, что теперь неизвестны константы, объявленные в DataflashManager. Ладно, <code>include</code> возвращаю. Функции из этого модуля закрыты, компиляции модуль тоже не подлежит, но нужное из него возьмем.</p>
<p>Чищу результаты неудачной компиляции, запускаю <code>make</code> &mdash; Ура! Откомпилировано!</p>
<div class="highlight"><pre>... много-премного букв ...

avr-size --mcu<span class="o">=</span>at90usb162 --format<span class="o">=</span>avr MassStorage.elf
AVR Memory Usage
----------------
Device: at90usb162

Program:    <span class="m">4054</span> bytes <span class="o">(</span>24.7% Full<span class="o">)</span>
<span class="o">(</span>.text + .data + .bootloader<span class="o">)</span>

Data:        <span class="m">113</span> bytes <span class="o">(</span>22.1% Full<span class="o">)</span>
<span class="o">(</span>.data + .bss + .noinit<span class="o">)</span>


 <span class="o">[</span>INFO<span class="o">]</span>    : Finished building project <span class="s2">&quot;MassStorage&quot;</span>.
</pre></div>


<p>Запускаю FLIP. Не забываю на подключенной плате нажать Reset, не отпуская, нажать HWB, отпустить Reset, отпустить HWB. После чего в окне FLIP подключаюсь к плате, загружаю hex-файл и жму Run. Прошивка загружается. </p>
<p>Теперь плата отображается в Windows XP и в семерке в виде флэшки &laquo;LUFA Dataflash Disk USB Device&raquo;, ему выделяется буква диска, можно посмотреть свойства. Он пустой, без файловой системы, и Windows 7 все порывается при подключении его отформатировать.</p>
<p><img alt="new-dew-lufa" src="http://romeogolf.github.io/images/usb-polygon/04/new-dev-lufa.png" title="New device LUFA" /> 
<a href="http://romeogolf.github.io/images/usb-polygon/04/lufa-pref.png" title="LUFA preference"><img alt="lufa-pref" src="http://romeogolf.github.io/images/usb-polygon/04/preview/lufa-pref-small.png" title="LUFA preference" /></a> </p>
<p>И в диспетчере устройств плата прописалась аж в трех местах (на примере Windows XP): &laquo;Дисковые устройства&raquo;, &laquo;Контроллеры универсальной последовательной шины USB&raquo; и &laquo;Тома запоминающих устройств&raquo;.</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/04/dev-man-lufa.png" title="LUFA preference"><img alt="dev-man-lufa" src="http://romeogolf.github.io/images/usb-polygon/04/preview/dev-man-lufa-small.png" title="LUFA preference" /></a> </p>
<h2 id="_5">Маленькое расширение программы</h2>
<p>Теперь компьютер думает, что моя плата пусть хреновенькая, но все-таки флэшка. Однако, кроме как создавать видимость флэшки, плата больше ничего пока не может. А у нее ведь есть светодиодики и кнопки! Зря, что ли?</p>
<p>И вообще смешно получается &mdash; взял готовый пример и только выкидывал из него лишнее. Надо же что-то и добавить!</p>
<p>Открываю основной файл проекта &mdash; MassStorage.c. Ага, а в нем еще есть что убрать. Закрываю все строки с функциями, начинающимися на &laquo;LEDs&raquo;, потому что у меня хоть и есть светодиоды, но совсем не такие и не там. Кстати, заодно в MassStorage.h закрываю &laquo;<code>include &lt;LUFA/Drivers/Board/LEDs.h&gt;</code>&raquo;, &laquo;<code>include &lt;LUFA/Drivers/Board/Dataflash.h&gt;</code>&raquo; и &laquo;<code>include &lt;LUFA/Platform/Platform.h&gt;</code>&raquo;, потому что у меня несколько не тот BOARD, что предполагался в демонстрационном примере.</p>
<p>Но вернмся к основному сишному файлу. Главная функция, как очевидно следует из названия, <code>main</code>. В ней все, что идет перед началом бесконечного цикла &mdash; инициализация всякого рода сущностей, от программных переменных до аппаратных регистров. В самом цикле <code>for (;;)</code> будет крутиться то, что нам собственно и надо. Сейчас там вертится обработка событий USB, не требующая вот-прям-щаз-реакции, то, что не надо делать в прерываниях.</p>
<p>Инициализирую порты: порт D, на котором у меня светодиоды, и порт C, на котором кнопки. После имеющейся в заготовке строчки <code>GlobalInterruptEnable();</code> пишу:</p>
<div class="highlight"><pre>    <span class="n">PORTD</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>    <span class="c1">// начальное значение - все нули</span>
    <span class="n">DDRD</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>     <span class="c1">// все линии порта на вывод</span>
    <span class="n">PORTC</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>    <span class="c1">// без &quot;подтяжки&quot; (есть внешняя)</span>
    <span class="n">DDRC</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>     <span class="c1">// все линии порта на ввод</span>
</pre></div>


<p>И объявляю переменные:</p>
<div class="highlight"><pre>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">// тупо счетчик</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cnt_bt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// счетчик нажатий на кнопки</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mode_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// режим вывода</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bt_now</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// состояние кнопок</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bt_old</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// состояние кнопок в прошлый раз</span>
</pre></div>


<p>Дальше в цикле <code>for (;;)</code> после строчки <code>USB_USBTask();</code> можно писать всякую отсебятину:</p>
<div class="highlight"><pre>        <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>                              <span class="c1">// инкремент счетчика - чтобы что-то изменялось</span>
        <span class="n">bt_now</span> <span class="o">=</span> <span class="n">PINC</span><span class="p">;</span>                      <span class="c1">// считывание порта с кнопками</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bt_now</span> <span class="o">!=</span> <span class="n">bt_old</span><span class="p">)</span> <span class="p">{</span>             <span class="c1">// если состояние порта изменилось</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>     <span class="c1">// если нажаты сразу две верхние кнопки на разрядах 3 и 4</span>
            <span class="n">mode_out</span><span class="o">++</span><span class="p">;</span>                 <span class="c1">// циклически изменить режим отображения,</span>
            <span class="n">mode_out</span> <span class="o">=</span> <span class="n">mode_out</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>    <span class="c1">// которых всего 4 - 0, 1, 2 и 3 (2 разряда по маске)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                        <span class="c1">// в противном случае</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">cnt_bt</span><span class="o">++</span><span class="p">;}</span>  <span class="c1">// верхняя кнопка увеличивает счет нажатий</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">cnt_bt</span><span class="o">--</span><span class="p">;}</span>  <span class="c1">// а вторая сверху - уменьшает</span>
            <span class="p">}</span>
            <span class="n">bt_old</span> <span class="o">=</span> <span class="n">bt_now</span><span class="p">;</span>                <span class="c1">// и сохраняем состояние порта для следующей проверки</span>
        <span class="p">}</span>
</pre></div>


<p>А дальше вывожу в порт D, то есть, на светодиоды, некоторые данные в зависимости от режима:</p>
<div class="highlight"><pre>        <span class="k">switch</span> <span class="p">(</span><span class="n">mode_out</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mi">0</span> <span class="o">:</span> 
            <span class="n">PORTD</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>     <span class="c1">// просто счетчик</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">1</span> <span class="o">:</span> 
            <span class="n">PORTD</span> <span class="o">=</span> <span class="n">bt_now</span><span class="p">;</span>  <span class="c1">// состояние кнопок</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">2</span> <span class="o">:</span>
            <span class="n">PORTD</span> <span class="o">=</span> <span class="n">cnt_bt</span><span class="p">;</span>  <span class="c1">// счетчик нажатий</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
            <span class="n">PORTD</span> <span class="o">=</span> <span class="mh">0x55</span><span class="p">;</span>    <span class="c1">// просто константа</span>
        <span class="p">}</span>
</pre></div>


<p>Теперь если я нажму на две верхние кнопки одновременно, то могу переключать выводимые данные:</p>
<ul>
<li>В режиме счетчика светодиоды горят все. Потому что счетчик на такой частоте успевает прокручиваться с таким темпом обновления, что глазом уследить за морганием светодиода практически нереально.</li>
<li>В режиме состояния кнопок горят светодиоды, соответствующие ненажатой кнопке, потому что нажатые кнопки замыкают подтянутый вывод на корпус.</li>
<li>В режиме счетчика нажатий верхняя кнопка увеличивает значение, выдаваемое на светодиодах, а вторая сверху кнопка &mdash; уменьшает.</li>
<li>В режиме константы светодиоды горят через один, что соответствует шестнадцатиричной константе 0x55.</li>
</ul>
<p>При попытке переключения режимов, а также в режиме счетчика нажатий наглядно видна проблема дребезга контактов. Режимы скачут хаотично, счетчик изменяется не на еденицу, и на на какое-то фиксированное число, а тоже как хочет. В моем случае одна кнопка дребезжала настолько выразительно, что дребезг был заметен даже в режиме отображения текущего состояния. Это было, конечно, прикольно и наглядно, но настолько кошмарно, что я эту кнопку перепаял.</p>
<p>Самое простое, что можно здесь сделать &mdash; это добавить задержку после конструкции <code>switch</code>, например, вставить библиотечную функцию <code>_delay_ms(100);</code>. Для того, чтобы оно заработала, надо не забыть добавить <code>include &lt;util/delay.h&gt;</code> после <code>#include "MassStorage.h"</code>. Теперь после компиляции и светодиоды в режиме счетчика перемигиваются с частотой 0,1 с, и на кнопки реакция более-менее нормальная, даже немного заторможенная: если нажимать быстро, некоторые нажатия могут пропуститься. </p>
<p>Но некрасиво это. И главный цикл тормозить так грубо &mdash; очень плохо, и функция-задержка реализована так себе&hellip; В общем, пришло время попробовать таймеры.</p>
<p>Убираю <code>_delay_ms()</code>. Закрываю <code>cnt++;</code>. После объявления переменных вставляю запуск таймеров:</p>
<div class="highlight"><pre>    <span class="cm">/* запуск таймера 0 на период ~0.01 с */</span>
    <span class="n">TCCR0B</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>           <span class="cm">/* 1 тик = 0.000032 с */</span>
    <span class="n">TCNT0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>            <span class="cm">/* 256 раз ~ 0.008192 с */</span>

    <span class="cm">/* запуск таймера 1 на период 0.5 с */</span>
    <span class="n">TCCR1B</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">TCNT1</span> <span class="o">=</span> <span class="mi">65536</span> <span class="o">-</span> <span class="mi">15625</span><span class="p">;</span>
</pre></div>


<p>После <code>USB_USBTask();</code> проверяю таймер 1, и если он сработал &mdash; увеличиваю счетчик:</p>
<div class="highlight"><pre>        <span class="cm">/* проверка срабатывания таймера без прерываний */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">TIFR1</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TCNT1</span> <span class="o">=</span> <span class="mi">65536</span> <span class="o">-</span> <span class="mi">15625</span><span class="p">;</span>
            <span class="n">TIFR1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>


<p>А всю остальную конструкцию &mdash; от считывания порта с кнопками до отображения &mdash; выполняем после проверки срабатывания таймера 0, для чего сразу после проверки таймера 1 вставляю следующее:</p>
<div class="highlight"><pre>        <span class="k">if</span> <span class="p">((</span><span class="n">TIFR0</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TCNT0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">TIFR0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>и после завершающей <code>switch</code> фигурной скобки ставлю еще одну скобку, закрывающую эту проверку. Хорошо бы еще соответственно сдвинуть отступы в коде для красоты.</p>
<p>Теперь светодиоды в режиме счетчика моргают с частотой в полсекунды. А с таймером 0 можно поиграться, устанавливая разные варианты <code>TCNT0</code> и <code>TCCR0B</code>, добиваясь такого времени опроса кнопок, чтобы и дребезг не влиял, и быстрые двойные щелчки по кнопке не пропускались. </p>
<dl>
<dt>Предупреждение</dt>
<dd>Вообще-то говоря, приведенный код &mdash; ни разу не пример для подражания. И разряды таким образом прописывать/маскировать нехорошо, и константы в коде числом задавать нездорово, и стиль оформления хромает. Но макет &mdash; он и есть макет: и плата, и код. Я считаю позволительным для вещей, служащих лишь для проверки работоспособности, отступать от правил и стандартов в угоду быстроте. Тем более, что это не будет повторно использоваться или развиваться до чего-то приличного, а будет стерто и забыто.</dd>
</dl>
<p>Итак, из заготовки (в качестве которой служит демонстрационный пример библиотеки LUFA) сделан &laquo;проект&raquo;, который позволяет компьютеру увидеть в плате &laquo;флэшку&raquo;, и при этом делает еще какую-то, пусть и не очень полезную, работу. Полноценного обмена с компьютером еще нет, хотя какой-то &mdash; служебными пакетами &mdash; уже есть.</p>
<h2 id="_6">Что дальше?</h2>
<p>Раз обмен по USB как-то завелся, надо организовать обмен данными между платой и компьютером, причем, пользовательскими данными, которые нужны мне, а не компьютеру. Вижу три направления:</p>
<ol>
<li>Обмен &laquo;сырыми&raquo; данными с &laquo;железом&raquo;, пользуясь дескриптором устройства, с помощью собственной программы.</li>
<li>Организация &laquo;липовой&raquo; файловой системы на устройстве и обмен средствами операционной системы &mdash; посредством чтения/записи файлов, которых на самом деле нет, без написания программы для компьютере.</li>
<li>Организация &laquo;липовой&raquo; файловой системы и обмен данными через ReadFile/WriteFile, но уже с дескрипторами несуществующих в реальности файлов, опять же с помощью собственной программы.</li>
</ol>
<p>Забегая вперед, скажу, что первый вариант проще с точки зрения программы для устройства (она уже почти готова), но сложнее в плане написания программы для ПК. Кроме того, в нем нехорошо с кроссплатформенностью, есть проблемы даже при переносе с Windows XP на семерку, не говоря о Linux. Второй вариант хорош тем, что для ПК вообще писать не надо, но не получается перечитать обновленный файл (если данные изменились, пока устройство было подключено), потому что данные кешируются при первом же чтении. И похоже, что финишем будет вынужденный третий вариант, но посмотрим, что получится.</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "usb-polygon-4.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>