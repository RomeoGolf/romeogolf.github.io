<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-9: Подготовка к имитации ФС</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">18</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/nishchebrod.html">
              нищеброд
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pokhodnoe.html">
              походное
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/samodelki.html">
              самоделки
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Чт 25 Май 2017</h4>
    <article>
      <h1>USB-polygon-9: Подготовка к имитации ФС</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Единицы информации: секторы, блоки, кластеры&hellip;</a><ul>
<li><a href="#_2">Байт</a></li>
<li><a href="#_3">Сектор (а также цилиндр и головка)</a></li>
<li><a href="#_4">Кластер</a></li>
<li><a href="#_5">Логический блок</a></li>
<li><a href="#_6">Страница</a></li>
<li><a href="#_7">Итого</a></li>
</ul>
</li>
<li><a href="#_8">Выбор файловой системы</a></li>
<li><a href="#_9">Способ имитации</a></li>
</ul>
</div>
<h2 id="_1">Единицы информации: секторы, блоки, кластеры&hellip;</h2>
<p>Перед переходом к файловой системе сперва хотелось бы систематизировать информацию об информации, которая измеряется в чем попало, аж голова кругом. Мало того, что есть байты, слова, двойные слова, младшими вперед, старшими вперед, так это все еще рассматривается в оптовом виде кластерами, секторами, логическими блоками, страницами&hellip; Попробую разобраться.</p>
<h3 id="_2">Байт</h3>
<p>Будем считать, что тут все просто и понятно. Байт &mdash; восемь битов, минимально адресуемая единица информации.</p>
<p>На самом деле, все не так просто, поскольку исторически первый байт был 6 битов, в современных последовательных протоколах передачи информации (например, RS-232 или SPI) байт также может быть меньше или больше 8 битов, и есть современные процессорные системы, в которых минимально адресуемой единицей является тридцатидвухразрядное слово.</p>
<p>Но в рамках USB-полигона это все не важно. Байт &mdash; восемь битов, и из них складывается все остальное. Тем более, это на сегодняшний день единственная единица, при помощи которой можно сравнить объем информации в разных системах, используй они 4 бита на байт или шестьдесят четыре: КБ везде считается 1024 байта по 8 битов в каждом, вот и считай&hellip;</p>
<h3 id="_3">Сектор (а также цилиндр и головка)</h3>
<p>Еще одна минимально адресуемая единица информации. Теперь уже с точки зрения хранения на дисковых устройствах &mdash; жестких дисках, дискетах, компактах. На таких устройствах информация записывается дорожками &mdash; концентрическими окружностями, и сектор &mdash; часть дорожки. Физически сектор не привязан к байту, это все-таки геометрическая условность, поэтому он может иметь произвольный размер. Желательно, конечно, кратный степени двойки для удобства вычислений.</p>
<p>Традиционно сектор равен 512 байтов. Настолько традиционно, что в некоторых программах, работающих с секторами, размер сектора &mdash; константа. Хотя есть сектора и большего размера. Но будем придерживаться традиций, пусть будет 512 байтов, больше незачем.</p>
<p>Первый сектор диска является загрузочным. По крайней мере, должен быть. Ну, операционная система считает, что это так. И я так и не понял, почему именно первый, а не нулевой, и куда делся нулевой, если нулевой цилиндр и нулевая головка есть.</p>
<p>Цилиндр (cylinder) &mdash; совокупность всех дорожек накопителя одинакового радиуса, если в накопителе больше одного диска. Если диск один, то номер цилиндра эквивалентен номеру дорожки. Если дисков много, то блок головок, остановившийся в определенном положении, может читать данные с нескольких дорожек сразу, то есть, с цилиндра.</p>
<p>Головка (head) &mdash; считывающее устройство, привязанное к конкретному диску, фактически, номер головки равен номеру диска.</p>
<p>Таким образом, на больших многодисковых накопителях информация читалась и записывалась порциями, для адресации которых нужно было указать цилиндр, головку и сектор, по-английски сокращенно CHS. Довольно неудобно. Даже с дисковыми накопителями неудобно, и вообще не подходит для лент, флэшек или сетевых хранилищ.</p>
<p>Логичнее было дать каждому сектору свой адрес. Ну и дали, в конце концов. Назвали &laquo;LBA&raquo;, логическая блоковая адресация, но об этом чуть позже.</p>
<h3 id="_4">Кластер</h3>
<p>По-английски &laquo;куст&raquo;. Логическая единица хранения информации в файловой таблице. Понадобилась из-за ограничения размера файловых таблиц в ранних файловых системах семейства FAT: сектора дисков, которые становились все больше, уже не помещались в таблице, пришлось их кучковать, объединять в &laquo;пучки&raquo;. Размер кластера вообще совсем-пресовсем не константа. Может быть один сектор, может и больше, например, восемь, а кое-где и все 128. Зависит не только от типа файловой системы, но и от форматирования конкретного носителя.</p>
<p>Это единица деления файлов. То есть, файл на диске состоит из кластеров. Значит, если кластер равен восьми секторам по 512 байтов, то файл размером в пару байтов будет занимать на диске 4 килобайта. А файл, который на пару байтов больше четырех килобайтов, будет &laquo;весить&raquo; все восемь.</p>
<p>И тут самое время вернуться к секторам. На сегодняшний день размер сектора в 512 байтов устарел. Крайне редко можно встретить кластер, равный одному или хотя бы двум секторам, обычно минимум четыре килобайта, то есть, восемь секторов. Так, может быть, проще сделать сектор четырехкилобайтным, а кластер размером в один сектор? Ну и сделали, назвали Advanced Format. Но! Флэшек это пока не касается. Тут и объемов таких огромных пока нет, и файловые системы семейства FAT широко используются. Так что, будем помнить, что &laquo;сектор = 512 Б&raquo; &mdash; это не догма, но пользоваться будем именно полукилобайтными.</p>
<h3 id="_5">Логический блок</h3>
<p>Понятие из логической блоковой адресации. Аналог сектора, но ему уже не нужны номера головок и цилиндров. Все блоки пронумерованы по порядку, начиная с нулевого. И кластеры можно теперь составлять из них. Для дисковых накопителей есть формула пересчета логического адреса из номеров цилиндра, головки и сектора на дорожке и обратно. Для флэшки такой пересчет вообще не нужен, потому что сектора лежат себе спокойно в линейной памяти по порядку своих физических адресов.</p>
<p>Насколько я понял, встречающееся местами макроопределение <code>#define VIRTUAL_MEMORY_BLOCK_SIZE    512</code> определяет именно размер логического блока.</p>
<h3 id="_6">Страница</h3>
<p>Деление памяти на страницы характерно для флэш-памяти. Дело в том, что ячейки памяти флэшки не стираются по одной, только оптом, довольно большими блоками, которые и называются страницами. Размер страницы зависит от типа микросхемы &mdash; отличается у разных флэшек.</p>
<p>Чистая ячейка памяти флэшки содержит единичные биты. То есть, в байтовой ячейке как бы записано 0xFF. Записать можно только в чистую ячейку. Таким образом, дописывать страницу, в принципе, можно, но для изменения единственного байта где-то в середине страницы потребуется прочитать всю страницу, изменить в считанном массиве нужный байт, стереть страницу и записать подправленный массив обратно.</p>
<p>Во многих микросхемах флэш-памяти реализован буфер страничного размера, в который записываются новые данные, чтобы после заполнения записать его разом и тем самым минимизировать обращения к странице. Тем более, что операция записи (как и стирания) относительно сложная: сперва нужно подать команду записи, для чего по строго определенным адресам пишутся строго определенные данные, и так несколько (от трех до пяти) раз, что дает контроллеру памяти понять, что сейчас надо записать данные, и только потом выставляются настоящие данные по их реальному адресу для записи. Причем, есть команды страничной записи, когда команда записи дается для всей страницы, а не для каждой ячейки, и потом можно записывать байты как в ОЗУ, последовательно и без лишних команд.</p>
<p>Отсюда появляются такие макроопределения, как <code>#define DATAFLASH_PAGE_SIZE 1024</code>, для которых по-хорошему надо знать размер страницы конкретной микросхемы.</p>
<p>Правда, в контексте USB-полигона это не важно. Потому что нет микросхемы &mdash; нет и страниц, а что и сколько имитировать &mdash; без разницы.</p>
<h3 id="_7">Итого</h3>
<ul>
<li>Байт &mdash; просто единица измерения информации. Малополезна для адресации к данным на носителе, но достаточно полезна при приведении одних укрупненных единиц к другим.</li>
<li>Сектор или логический блок &mdash; минимально читаемая с носителя единица информации. То есть, даже если нужно прочитать один байт, прочитан будет все равно минимум сектор (и то в &laquo;сыром&raquo; режиме или если кластер равен одному сектору, иначе &mdash; еще больше), поэтому экономить на байтах для ускорения обмена с накопителем бесполезно. Экономить надо сразу секторами. Будем считать, что сектор равен 512 байтов.</li>
<li>Кластер &mdash; единица дробления файла. Файл не может быть меньше одного кластера. Если на носителе есть файловая система и данные читаются файлами, то кластер становится минимально читаемой единицей. Если файл содержит один байт, то все равно занимать он будет кластер, и читаться тоже будет кластер. Пусть будет 8 секторов, 4 килобайта.</li>
<li>Страница &mdash; единица измерения стираемой информации на флэшке. Стирается за один раз минимум одна страница. Используется не для доступа к информации, а больше во внутренних целях. Зависит от микросхемы.</li>
</ul>
<h2 id="_8">Выбор файловой системы</h2>
<p>Хотелось бы получить более-менее универсальное устройство, которое заработает в любой более-менее популярной современной операционной системе. То есть, в Windows начиная с XP, Android начиная хотя бы с 4 и Linux всякого рода. MacOS и iOS не рассматриваю по причине нищебродства (не имею и не предвидится).</p>
<p>Линуксовые файловые системы (Ext2..Ext4, ReiserFS, Xfs и прочие) придется отложить в сторонку &mdash; в винде с ними проблемы. Не то, чтобы совсем невозможно работать, нет, способы существуют. Но придется ставить отдельно драйвера ФС, а тогда можно было не заморачиваться с MassStorage и ставить драйвер для своего устройства.</p>
<p>Зато обыкновенные флэшки читаются сегодня без проблем упомянутыми ОС. А флэшки в большинстве своем отформатированы или в какой-нибудь FAT или NTFS.</p>
<p>NTFS &mdash; журналируемая файловая система, что напрочь отбивает охоту браться за ее имитацию. Остается FAT.</p>
<p>Выбираем из семейства: FAT, VFAT, FAT12, FAT16, FAT32, extFAT.</p>
<p>Чем ближе к историческому корню, тем проще. Первая версия FAT (для MS DOS до 2.0) имеет маленький корневой каталог, не имеет иерархии каталогов (они же папки, они же директории) &mdash; все файлы в корне. Для простых целей USB-полигона эти ограничения несущественны, а реализация FAT довольно проста и незамысловата. Но уж больно ранние версии убогенькие&hellip; Да и поддержка их может прекратиться в любой момент за практически полной ненадобностью.</p>
<p>Тогда, может быть, сразу extFAT? Относительно свеженькая, 2006 года, предназначена главным образом именно для флэшек. Однако ее заявленные преимущетва &mdash; увеличенные ограничения на размер файла, кластера, улучшение распределения свободного места, поддержка транзакций &mdash; в рамках проекта USB-полигона вообще никак не помогают, зато она проприетарная и заметно более сложная, чем даже предшествующая FAT32.</p>
<p>А вот FAT32 выглядит не такой уж страшной, если наплевать на длинные имена файлов и использование в них не латинских символов. Особенно, если еще и обойтись только чтением. На ней и остановлюсь.</p>
<h2 id="_9">Способ имитации</h2>
<p>Ну, грубо говоря, тут все довольно просто. Операционная система будет обращаться к устройству, предполагая, что это флэшка. Сперва почитает MBR &mdash; master boot record, потом PBR &mdash; partition boot record, то есть загрузочную запись раздела, потом захочет узнать подробности о файловой системе и почитает FAT &mdash; file allocation table, потом, возможо, если ее попросить, полезет в какой-нибудь файл.</p>
<p>ОС, стало быть, будет читать, а устройство, в свою очередь, будет получать команды чтения, а в них &mdash; в командах &mdash; есть адреса читаемых данных. MBR без вариантов по нулевому адресу, PBR по адресу, указанному в MBR, место FAT записано в PBR, а в FAT расписано, где какой файл начинается.</p>
<p>Получается, в ответ на запросы чтения можно сфабриковать липовые данные таким образом, что ОС получит примерно то, что ожидает, какие-то правдоподобные данные. При обращении по адресу 0 к MBR ответим, что PBR лежит по адресу А, и будем знать, что если будет обращение к А, то надо отвечать так, как будто прочиталась PBR, ну и так далее.</p>
<p>А отвечать на команды чтения устройство уже умеет, и где взять адрес данных &mdash; тоже знает.</p>
<p>Итак, необходимо будет отслеживать обращения к следующим фиктивным областям в виртуальной памяти устройства:</p>
<ul>
<li>главная загрузочная запись устройства</li>
<li>загрузочная запись раздела, хватит одной, хотя можно и четыре</li>
<li>основная таблица FAT &mdash; список кластеров, занятых папками и файлами</li>
<li>резервная таблица FAT</li>
<li>файловая запись, соответствующая корневому каталогу</li>
<li>прочие файловые записи, по обстоятельствам (фиктивные файлы, а при желании &mdash; и фиктивные папки)</li>
</ul>
<p>Теперь надо разобраться во внутренней структуре этих областей, разрисовать их подробнее, но об этом в следующий раз.</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "usb-polygon-9.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>