<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-16: Использование записи файла</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">14</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/nishchebrod.html">
              нищеброд
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/pokhodnoe.html">
              походное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Пн 10 Июль 2017</h4>
    <article>
      <h1>USB-polygon-16: Использование записи файла</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Подготовка</a></li>
<li><a href="#_2">Изменения в программе</a></li>
<li><a href="#_3">Проверка записи</a></li>
<li><a href="#_4">Итог</a></li>
</ul>
</div>
<h2 id="_1">Подготовка</h2>
<p>В продолжение предыдущего <a href="http://romeogolf.github.io/drafts/usb-polygon-15.html">выпуска</a>: для использования операций записи в целях передачи информации от <abbr title="Персональный компьютер">ПК</abbr> в устройство предполагаю поступить следующим образом. Для выбора способа обработки передаваемой информации необходимо предварительно прочитать специально для этой цели созданный файл. Сам факт чтения файла должен переключить выбор обработчика данных.</p>
<p>Для записи предполагаю создать специальный файл. Дело в том, что Linux записывает измененный файл в начале свободной области. Если использовать для записи тот же файл, что используется для &laquo;командного&raquo; чтения, <abbr title="Операционная система">ОС</abbr> может запомнить, что он уже в другом месте, и в следующий раз обращаться к нему по другому адресу. Не исключено, что это не так, но поступая предложенным образом, я ничем не рискую.</p>
<p>Стало быть, нужно в файловой таблице добавить файлы для чтения по числу способов обработки операций записи. Потом файл для записи. И еще файл, чтение которого прекратит обработку указанным способом, либо обрабатывать в качестве команды &laquo;стоп&raquo; чтение любого непредусмотренного файла. Но лучше для остановки обработки выделить специальный файл, потому что запись данных может быть командой на их передачу по линии связи, соответственно, нужно будет читать принятые данные, оформленные в виде какого-либо файла, а такое чтение может остановить передачу.</p>
<p>При этом, способ обработки можно переключать в функции чтения, указанной в таблице файлов, а можно при помощи номера читаемого файла в функции <code>read_data()</code> еще перед вызовом специфичной для файла функции чтения. Предпочтительнее первый вариант, он логичнее (обработка привязывается к файлу-команде напрямую, через таблицу) и удобнее в реализации.</p>
<p>Сам способ обработки можно либо выбирать чем-то вроде оператора <code>switch</code> в функции <code>process_data()</code>, либо вызывать в ней по номеру файла специальную функцию, которую следует добавить в файловую таблицу по образцу функции чтения. Пожалуй, тоже логичнее будет первый вариант, поскольку странно привязывать функцию обработки записи в один файл к другому файлу в таблице.</p>
<h2 id="_2">Изменения в программе</h2>
<p>Все изменения будут сделаны в файле <code>Lib/fake_fs.c</code>. Для начала добавлю константу, определяющую сектор, с которого начинается область файлов в адресном пространстве имитируемой файловой системы, для использования вместо прямого указания <code>0x57</code>:</p>
<div class="highlight"><pre><span class="cp">#define FILES_AREA      (ROOT_SECTOR + SECTORS_PER_CLUSTER)</span>
</pre></div>


<p>Далее введу перечисление с разными вариантами обработки записываемых данных (которое при необходимости можно будет расширять) и соответствующую переменную:</p>
<div class="highlight"><pre><span class="k">enum</span> <span class="n">WriteType</span> <span class="p">{</span><span class="n">None</span><span class="p">,</span> <span class="n">ToFile</span><span class="p">,</span> <span class="n">ToLed</span><span class="p">};</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">WriteType</span> <span class="n">writeType</span> <span class="o">=</span> <span class="n">None</span><span class="p">;</span>
</pre></div>


<p>Еще добавлю объявления функций для командных файлов, их нужно для демонстрации штуки три: команду выдавать данные в файл (хотя бы кусочек), команду выдавать данные на светодиодную линейку и команду прекратить обработку записываемых данных. А так как это все-таки файлы, пусть они при открытии выдают какие-то строки, тут же эти строки и определю. И длины они будут одинаковой, равной длине куска за один раз обрабатываемых данных:</p>
<div class="highlight"><pre><span class="cp">#define SIZE_OF_COMMAND 16</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">strToFile</span><span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span> <span class="s">&quot;Write to file   &quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">strToLED</span><span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span> <span class="s">&quot;Write to LED    &quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">strStop</span><span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span> <span class="s">&quot;Stop writing    &quot;</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readToFile</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readToLed</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readStop</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>


<p>В конце программы надо написать определение функций, отвечающих за чтение файлов-команд:</p>
<div class="highlight"><pre><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readToFile</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">writeType</span> <span class="o">=</span> <span class="n">ToFile</span><span class="p">;</span>
    <span class="n">memcpy_P</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">PGM_P</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">strToFile</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readToLed</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">writeType</span> <span class="o">=</span> <span class="n">ToLed</span><span class="p">;</span>
    <span class="n">memcpy_P</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">PGM_P</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">strToLED</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readStop</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">writeType</span> <span class="o">=</span> <span class="n">None</span><span class="p">;</span>
    <span class="n">memcpy_P</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">PGM_P</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">strStop</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Теперь можно добавить файлы-команды в файловую таблицу. После добавления она станет выглядеть так:</p>
<div class="highlight"><pre><span class="k">static</span> <span class="k">const</span> <span class="n">FileEntry</span> <span class="n">fileTable</span><span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;KEY_FILETXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_KEY</span><span class="p">,</span> <span class="n">readKey</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;README  TXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_README</span><span class="p">,</span> <span class="n">readMe</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;TESTFILETXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_TEST</span><span class="p">,</span> <span class="n">readTest</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;USERDATATXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_USERDATA</span><span class="p">,</span> <span class="n">readUserData</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;DATA    BIN&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_DATA</span><span class="p">,</span> <span class="n">readData</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;TO_FILE TXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_COMMAND</span><span class="p">,</span> <span class="n">readToFile</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;TO_LED  TXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_COMMAND</span><span class="p">,</span> <span class="n">readToLed</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;STOP    TXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_COMMAND</span><span class="p">,</span> <span class="n">readStop</span><span class="p">},</span>
    <span class="p">{{</span> <span class="mi">0</span> <span class="p">},</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>Ну и, наконец, надо изменить функцию <code>process_data()</code> таким образом, чтобы записываемые данные пошли по нужному пути:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">process_data</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">BytesInBlockDiv16</span><span class="p">){</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">writeType</span><span class="p">){</span>
    <span class="k">case</span> <span class="nl">ToFile</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">BlockAddress</span> <span class="o">&gt;=</span> <span class="n">FILES_AREA</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">ToLed</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">BlockAddress</span> <span class="o">&gt;=</span> <span class="n">FILES_AREA</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">data_PC</span> <span class="o">=</span> <span class="n">data_buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">PORTD</span> <span class="o">=</span> <span class="n">data_PC</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2 id="_3">Проверка записи</h2>
<p>Компилирую, прошиваю, запускаю.</p>
<p>Устройство определяется в Windows в виде флэшки, и на ней появились дополнительные файлы. Трижды нажимаю одновременно две верхние кнопки &mdash; переключаюсь в режим выдачи переменной <code>data_PC</code>. Открываю файл <code>TESTFILE.TXT</code> блокнотом, сохраняю через меню. На светодиодах ничего, все погашены. Открываю <code>DATA.BIN</code> hex-редактором &mdash; в нем одни нули. Первый этап испытаний прошел с ожидаемым результатом.</p>
<p>Сбрасываю устройство кнопкой &laquo;Reset&raquo;. Снова переключаюсь в режим выдачи <code>data_PC</code> на светодиоды. Снова открываю блокнотом <code>TESTFILE.TXT</code>. Открываю блокнотом же файл <code>TO_FILE.TXT</code> и сразу закрываю его. На светодиодах по-прежнему ничего, не горят. Открываю <code>DATA.BIN</code> и вижу следующее:</p>
<div class="highlight"><pre>00000000: 30 30 30 30 30 30 20 20 30 30 30 30 30 31 20 20  000000  000001
00000010: 30 30 30 30 30 32 20 20 30 30 30 30 30 33 20 20  000002  000003
00000020: 30 30 30 30 30 34 20 20 30 30 30 30 30 35 20 20  000004  000005
00000030: 30 30 30 30 30 36 20 20 30 30 30 30 30 37 20 20  000006  000007
00000040: 30 30 30 30 30 38 20 20 30 30 30 30 30 39 20 20  000008  000009
00000050: 30 30 30 30 30 41 20 20 30 30 30 30 30 42 20 20  00000A  00000B
00000060: 30 30 30 30 30 43 20 20 30 30 30 30 30 44 20 20  00000C  00000D
00000070: 30 30 30 30 30 45 20 20 30 30 30 30 30 46 20 20  00000E  00000F
</pre></div>


<p>Затем открываю файл <code>TO_LED.TXT</code> и также закрываю его немедленно. Сохраняю через меню все еще открытый в блокноте файл <code>TESTFILE.TXT</code>. На светодиодах наблюдаю моргание, которое свидетельствует о том, что в порт выдаются постоянно обновляющиеся данные. В конце записи на светодиодной линейке фиксируется <code>0x20</code>, что соответствует символу пробела &mdash; именно пробелом оканчивается файл, размер которого как раз кратен размеру сектора.</p>
<p>Последний пробел файла меняю в блокноте на &laquo;5&raquo; и снова выбираю в меню &laquo;Файл -&gt; Сохранить&raquo;. Снова наблюдаю мерцание светодиодной линейки, но в конце на ней фиксируется значение <code>0x35</code>, что соответствует символу пятерки.</p>
<p>Открываю файл <code>STOP.TXT</code> и закрываю его. Еще раз сохраняю файл <code>TESTFILE.TXT</code>. На светодиодах изменений нет. Файл <code>DATA.BIN</code> смотреть обычными средствами бесполезно, он уже в кэше системы и будет взят оттуда. Но раз отключение последнего способа &laquo;записи&raquo; выполнено, можно и не проверять, я уверен.</p>
<p>В Linux провел эти же самые проверки, только вместо блокнота использовал gedit. Всё прошло примерно так же, только при сохранении файла было выдано сообщение о нехватке свободного места на флэшке, что естественно: если в Linux файл записывается не на старое место, а на свободное, то места может и не хватить. И еще с gedit не получилось поправить последний пробел на что-нибудь другое, потому что файл <code>TESTFILE.TXT</code> оказался для него слишком огромен, и концовка отображалась как-то зажевано, наслоениями.</p>
<p>Для устранения проблемы с нехваткой места я &laquo;расширил&raquo; память: все в том же файле <code>Lib/fake_fs.c</code> в функции <code>read_mbr()</code> заменил <code>data_buf[11] = 0x10;</code> на <code>data_buf[11] = 0x5F;</code>, и в функции <code>read_boot_sect()</code> в условии <code>if (BytesInBlockDiv16 == 2)</code> заменил <code>data_buf[1] = 0x10;</code> на <code>data_buf[2] = 0x10;</code>. Почему-то если в <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> поставить размер в 11 байте равным <code>0x60</code>, то Windows 7 предлагает отформатировать диск. А так он получается 3,99 Мб. Здесь еще надо разобраться, но в контексте решения задачи это пока неважно.</p>
<h2 id="_4">Итог</h2>
<p>Отладочную плату теперь можно использовать в качестве двунаправленного преобразователя информации: записывать данные в файл, инициируя передачу, скажем, по SPI, и проверять файл на наличие обновленных данных, принятых, скажем, по тому же SPI.</p>
<p>На следующем этапе мне хотелось бы воспользоваться этой возможностью для управления каким-нибудь устройством, работающем по SPI: экраном от телефона или SD-картой памяти.</p>
<p>Еще интересно разобраться с особенностями определения размера накопителя по записям в <abbr title="(Master Boot Record) Главная загрузочная запись">MBR</abbr> и <abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr>, но это уже по остаточному принципу, насколько хватит времени и сил.</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "drafts/usb-polygon-16.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>