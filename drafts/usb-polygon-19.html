<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-19: CRC-7</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">18</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/nishchebrod.html">
              нищеброд
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pokhodnoe.html">
              походное
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/samodelki.html">
              самоделки
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Ср 22 Ноябрь 2017</h4>
    <article>
      <h1>USB-polygon-19: CRC-7</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Введение</a></li>
<li><a href="#_2">Немного о контроле ошибок</a></li>
<li><a href="#crc">Суть CRC</a></li>
<li><a href="#crc-7">Подробнее о вычислении CRC-7</a></li>
<li><a href="#40">Пример ручного расчета для 40 байтов</a></li>
<li><a href="#_3">Автоматизация</a></li>
<li><a href="#-cid">Еще один пример &mdash; CID</a></li>
</ul>
</div>
<h2 id="_1">Введение</h2>
<p>В предыдущем <a href="http://romeogolf.github.io/usb-polygon-18.html">опусе</a> описывалось подключение SD-карты к устройству. Там встречались моменты, связанные с использованием CRC-7, в которой хотелось бы разобраться чуть подробнее.</p>
<p>Как следует из раздела 4.5 <a href="https://www.sdcard.org/downloads/pls/click.php?p=Part1_Physical_Layer_Simplified_Specification_Ver6.00.jpg&amp;f=Part1_Physical_Layer_Simplified_Specification_Ver6.00.pdf&amp;e=EN_SS1">спецификации</a> на SD-карты памяти, CRC-7 используется для всех команд, для всех откликов, кроме R3, для регистров CSD и CID. При использовании одной линии данных в режиме поблочной передачи данных применяется CRC-16.</p>
<p>При этом, в режиме SPI вычисление CRC отключено. Однако, его можно включить, что повысит надежность информационного обмена с картой, особенно при посредственно реализованной линии передачи, например, длинными неэкранированными проводами. Кроме того, можно при желании попробовать перейти от SPI-режима к &laquo;родному&raquo;. Ну и в конце концов, при инициализации карты первая команда подается в &laquo;родном&raquo; режиме и требует CRC. Там, конечно, уже все вычислено до нас, но желательно не тупо использовать чужие результаты, а разобраться в том, как эти результаты были получены.</p>
<p>Здесь я не собираюсь приводить примеры фрагментов программ или автоматов на логических элементах, вычисляющих CRC. Этого добра в интернетах и так навалом. Здесь я хочу ответить на некоторые вопросы, ответов на которые я или не нашел, или они были разбросаны по разным источникам. Мне нужно было разобрать этот вопрос с точки зрения практического применения, оставляя глубины теории в стороне, насколько это возможно.</p>
<p>А главное, хочу привести примеры ручного счета именно для CRC-7, а не для каких-то абстрактных четырехразрядных кодов, которые компактно выглядят, но непонятно, откуда взялись и где применяются. Причем, меня интересуют примеры, правильность вычисления в которых можно подтвердить документами, заслуживающими доверие, либо практически.</p>
<h2 id="_2">Немного о контроле ошибок</h2>
<p>При информационном обмене между различными устройствами часто необходимо иметь уверенность, что принимающее устройство приняло именно то, что собиралось выдать передающее. Часто, но не всегда. Например, при потоковой передаче оцифрованного звука единичный сбой может вызвать малозаметный щелчок &mdash; не так уж и страшно. Однако, при передаче сжатого видео, где каждый кадр зависит от предыдущего, сбой может вызвать искажения изображения до тех пор, пока не придет следующий несбойный ключевой кадр. А при межбанковских транзакциях целостность информации вообще вещь зашкаливающей важности.</p>
<p>Уверенность в том, что информация на приеме соответствует информации на передаче, достигается разными способами. Самый надежный &mdash; помехоустойчивое кодирование. Наверное, многие слышали хотя бы названия кодов Хэмминга или Рида-Соломона. При их использовании мало того, что ошибку можно локализовать, ее можно даже исправить (с оговорками, конечно), и приемнику не нужно запрашивать повтор битых данных. Но такое кодирование имеет два серьезных недостатка: увеличенный объем данных для передачи (кодирование-то с избыточностью), и требование вычислительных ресурсов для декодирования, локализации сбоя и восстановления ошибочной информации.</p>
<p>Самый дурацкий вариант, практически бесполезный &mdash; установка в определенных местах определенных &laquo;магических&raquo; констант, типа <code>55 aa</code> в конце <abbr title="Master Boot Record, главная загрузочная запись">MBR</abbr>. Вычислительных ресурсов не требует вообще, но уверенности в том, что данные между такими  константами целые, не дает никакой. Правда, позволяет определить, не пропали ли некоторые биты-байты при передаче, не стало ли сообщение короче. Так что &laquo;магические&raquo; константы используются не в этих целях. По крайней мере, не только в этих, и если и в этих, то вместе с другими способами.</p>
<p>Контрольная сумма &mdash; нечто промежуточное. Требует заметно меньше ресурсов и существенно меньше дополнительного места в сообщении, чем помехоустойчивое кодирование. Помогает обнаружить сам факт наличия ошибки без возможности найти саму ошибку и тем более восстановить целостность сообщения.</p>
<p>Алгоритмы контрольного суммирования имеются разные, также отличающиеся ресурсоемкостью, а сама контрольная сумма (<abbr title="контрольная сумма">КС</abbr>) добавляется чаще всего в конце сообщения (&laquo;в конце&raquo; с точки зрения передачи данных, то есть, если данные передаются старшими разрядами вперед, то в начале, со стороны младших разрядов). Причем, <abbr title="контрольная сумма">КС</abbr> может быть и не суммой вовсе. Просто так исторически сложилось, что часто использовались разного рода суммы, на самом деле <abbr title="контрольная сумма">КС</abbr> может быть результат выполнения над сообщением некоторой такой функции, чтобы этот результат для разных сообщений отличался.</p>
<p>Строго говоря, контрольное суммирование &mdash; это хеширование данных, соответственно, <abbr title="контрольная сумма">КС</abbr> &mdash; это хеш, полученный с помощью некоторой хеш-функции. Хеш-функция, напомню, позволяет получить блок данных фиксированной относительно небольшой длины с высокой степенью вероятности однозначно соответствующий некоторому входному блоку данных произвольной длины. Если хеши разных сообщений отличаются, то сообщения точно отличаются. Если хеши одинаковые, то есть маленькая вероятность, что сообщения все же разные, но скорее всего одинаковые.</p>
<p>Таким образом, приемник получает сообщение и <abbr title="контрольная сумма">КС</abbr>. Алгоритм вычисления <abbr title="контрольная сумма">КС</abbr> приемнику известен. Приемник вычисляет <abbr title="контрольная сумма">КС</abbr> полученных данных и сравнивает с той, что принял вместе с сообщением. Если посчитанная и принятая <abbr title="контрольная сумма">КС</abbr> не совпадают, значит и сообщение отличается от того, которое должно быть. Дальнейшее поведение приемника определяется разработчиком в зависимости от назначения прибора: отбросить и забыть, сообщить передатчику об ошибке, запросить повтор, записать в память с признаком сбоя.</p>
<p>Простейший вариант <abbr title="контрольная сумма">КС</abbr> &mdash; разряд контроля четности. Одноразрядная <abbr title="контрольная сумма">КС</abbr>, дополняющая число единиц в двоичном представлении данных до нечетного. По сути, это сумма битов данных по модулю 2, инициализированная единицей. Занимает всего один разряд, требует мало вычислений (операция XOR довольно дешевая), но не помогает обнаружить четную ошибку. Например, если где-то нолик стал единицей, а в другом месте единица &mdash; ноликом, или две единицы обнулились.</p>
<p>Чуть понадежнее и посложнее &mdash; побайтовое арифметическое сложение сообщения. Возникающий разряд переноса можно прибавлять перед следующим суммированием, а можно отбрасывать, только надо договориться разработчикам приемника и передатчика.</p>
<p>Один из самых сложных вариантов &mdash; хеш-функции типа SHA-1 или MD5. Это вовсе не сумма (как и CRC), но суть та же: возможность контроля целостности данных, обработанных соответствующей функцией.</p>
<p>CRC посложнее и понадежнее простого суммирования, но не такое сложное и надежное, как MD5. Имеет массу разновидностей, объединенных принципом вычисления и отличающихся длиной поля, отведенного под результат и порождающим многочленом. Не обеспечивает 100% защиты от допуска сбойного сообщения, но надо очень постараться, чтобы изувечить данные, сохранив CRC. От непреднамеренных сбоев, например, при передаче по не особенно качественным линиям связи, защищает неплохо.</p>
<h2 id="crc">Суть CRC</h2>
<p>В общих чертах про это дело написано в <a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B8%D0%B7%D0%B1%D1%8B%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4">Википедии</a>, но кое-что в собственном сжатом пересказе запишу.</p>
<p>Существует теория линейных циклических кодов. А еще есть арифметика полиномов, математические операции над многочленами. Но умные люди, которые в этом понимают, уже сделали все самое сложное: разработали алгоритм и подобрали самые полезные порождающие многочлены, причем, не тупо перебором, а теоретически обоснованно. Для вычисления CRC всю эту кухню знать уже не обязательно, достаточно простых математических операций.</p>
<p>Короче, CRC &mdash; это остаток от деления по модулю 2 исходного сообщения на образующий полином. Число при буквах CRC (CRC-7, например, или CRC-32) указывает на степень полинома, а по сути &mdash; на длину делителя (делимым будет сообщение), и, как следствие, на длину результата операции, который будет дописан к сообщению.</p>
<p>То есть, CRC-7 добавит к сообщению 7 разрядов, а CRC-32 &mdash; 32 разряда. А степень полинома в практическом применении означает максимальную степень двойки в делителе, то есть, число двоичных разрядов. Таким образом, для CRC-7 степень полинома равна 7, значит, ненулевой старший двоичный разряд делителя &mdash; седьмой (начиная с нуля), итого 8 разрядов. Да, результат вычисления CRC на один двоичный разряд короче образующего делителя.</p>
<p>Для каждой степени CRC можно использовать большое число делителей (образующих полиномов). На их вид накладываются определенные ограничения, например, они должны начинаться с единицы, заканчиваться ею же, делиться по модулю 2 без остатка только на себя и на единицу, и все равно их довольно много. Но, как я уже говорил, умные дядьки вычислили, что некоторые из них лучше других. Лучше тем, что с их использованием меньше пакетов данных, у которых могут совпасть CRC, таким образом, выше достоверность контроля с использованием CRC.</p>
<p>Однако некоторые образующие полиномы имеют достаточно близкие свойства, либо могут быть оптимальными при определенной длине обрабатываемой последовательности. Поэтому существуют CRC одинаковой степени, отличающиеся образующими полиномами. А это значит, что производители приемников и передатчиков в одной области должны договориться между собой о том, какой из полиномов использовать.</p>
<p>В этом плане CRC-7 хорош: я не встречал в литературе полинома седьмой степени, отличающегося от x<sup>7</sup> + x<sup>3</sup> + 1.</p>
<p>Кстати, упомянутый выше бит четности &mdash; это также и CRC-1, так как его можно посчитать не только суммированием, но и по общему для других CRC алгоритму с образующим полиномом <code>x + 1</code>.</p>
<h2 id="crc-7">Подробнее о вычислении CRC-7</h2>
<p>Стало быть, CRC-7 &mdash; это остаток от деления по модулю 2 некоторого блока данных на образующий полином седьмой степени.</p>
<p>Сперва о блоке данных. Он может быть произвольной длины, но в разумных пределах. Во-первых, чем длиннее блок, тем больше вероятность получения разных блоков с одинаковой <abbr title="контрольная сумма">КС</abbr>. Впрочем, для контроля ошибок это не очень критично. Во-вторых, чем длиннее блок, тем больше информации придется повторять, если он окажется сбойным. Обидно, если ошибка в одном бите, а заново пересылать нужно несколько мегабайтов. Блок данных рассматривается как одно длинное двоичное число, последовательность двоичных разрядов. При расчете блок в конце дополняется нулями в количестве, равном степени полинома, для CRC-7 надо дописать 7 нулей. Это для того, чтобы при делении на полином в операции смогли поучаствовать все разряды.</p>
<p>Теперь о полиноме. В нашем случае это x<sup>7</sup> + x<sup>3</sup> + 1. Не вдаваясь в подробности, можно вместо x подставить двойку. При этом не забываем, что 1 = 2<sup>0</sup>. Тогда получится число 0b10001001 или 0x89. Вот это число будет использоваться в качестве делителя по модулю 2. В разного рода справочных данных пишут, что образующий полином CRC-7 равен 9. Это потому, что старший разряд любого образующего полинома всегда равен 1, стало быть, его можно не учитывать, а подразумевать. Если из полинома CRC-7 выкинуть старший разряд, останется 0b1001 = 0d9 = 0x9.</p>
<p>Подходим вплотную к делению. Лучше всего процедуру иллюстрирует классическое деление столбиком. Берем в левой части делимого столько разрядов, сколько содержит делитель. Умножаем делитель на такую цифру, чтобы произведение было как можно больше, но меньше выбранных разрядов делимого. Вычитаем произведение делителя на подобранную цифру, которая записывается в очередной разряд частного. Старший разряд разности всегда будет нулем, его можно не писать. К разности дописывается следующий разряд, взятый из делимого и операция повторяется до тех пор, пока есть, из чего вычитать. А когда разряды делимого для дополнения очередной разности закончились, последняя разность представляет собой остаток от деления.</p>
<p>Вот пример десятичного деления столбиком:</p>
<pre>
  2825 <u>| 7   </u>
  <u>0 </u>   | 0403
  28
  <u>28 </u>
   02
   <u>00 </u>
    25
    <u>21</u>
     4
</pre>

<p>Сперва выделяем старшую двойку. Из нее можно вычесть 7, умноженную только на 0. К полученной в результате вычитания двойке дописываем следующий разряд, получаем 28. Из 28 можно вычесть 7, умноженное на 4 (четверка пойдет очередным разрядом частного). В результате вычитания получаем 0, дописываем из следующего разряда делимого цифру 2, а из нее можно вычесть 7, умноженную на 0 (ноль будет следующим разрядом частного). И так далее, пока не получим в результате вычитания четверку, из которой 7 не вычесть, и дописывать из делимого уже нечего. Итого, частное равно 403, и остаток равен 4.</p>
<p>При этом, операции вычитания делителя, умноженного на ноль, обычно опускаются. В частное дописывается ноль, а очередной разряд делителя дописывается в этой же строчке:</p>
<pre>
  2825 <u>| 7   </u>
  <u>28  </u> | 403
    25
    <u>21</u>
     4
</pre>

<p>Деление двоичных чисел по модулю 2 выполняется почти так же. Но есть несколько особенностей.</p>
<p>Во-первых, сложение по модулю 2 и вычитание по модулю 2 &mdash; это одна и та же операция, &laquo;исключающее ИЛИ&raquo; (XOR) поразрядно. Напомню, почему. Вот таблица истинности для операции <code>X1 xor X2 = R</code>:</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="center">X1</th>
<th align="center">X2</th>
<th align="center">R</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody>
</table>
<p>То есть, как &laquo;ИЛИ&raquo;, но исключая последнюю строчку.</p>
<p>При сложении по модулю 2 <code>0 + 0 = 0</code>, <code>0 + 1 = 1</code>, <code>1 + 0 = 1</code>, как и при любом другом сложении, а вот <code>1 + 1 = 10</code>, но по модулю 2 займов и переносов нет, поэтому старший разряд результата &mdash; разряд переноса &mdash; отбрасывается, остается 0.</p>
<p>Примерно то же самое с вычитанием. <code>0 - 0 = 0</code>, <code>1 - 0 = 0</code>, <code>1 - 1 = 0</code>, тут все стандартно и понятно. <code>0 - 1 = -1</code>, а <code>-1</code> в двоичном представлении &mdash; это заполненная единицами разрядная сетка, например, <code>0xFF</code> для байтового результата операции. В данном случае результат одноразрядный, и <code>0 - 1 = 1</code>.</p>
<p>Во-вторых (и это следует из первого), с точки зрения арифметики по модулю 2 трудно однозначно сказать, какое число больше, а какое меньше. В обычной десятичной арифметике <code>9 + 3 = 12</code>, а <code>9 - 3 = 6</code>, значит, девять на три меньше, чем двенадцать, и на три больше, чем шесть. В арифметике по модулю 2 операции <code>9 - 3</code> и <code>9 + 3</code> дают одинаковый результат <code>10</code>.</p>
<p>Далее по тексту применительно к арифметике по модулю два термины &laquo;сложение&raquo;, &laquo;вычитание&raquo; и &laquo;исключающее ИЛИ (xor)&raquo; равнозначны и взаимозаменяемы.</p>
<p>В-третьих, раз арифметика двоичная, делитель для вычитания при выполнении деления можно умножать только на цифры 0 и 1. На 0 умножается, если делитель меньше уменьшаемого, и на 1, если больше или равен. А определить &laquo;больше&raquo; или &laquo;меньше&raquo; затруднительно. Можно ориентироваться на порядок. У делителя старший разряд равен 1. Если у очередной порции старших разрядов делимого самый старший разряд равен нулю, то делитель умножается на 0, и очередным разрядом результата будет 0, а если единица, то делитель умножается на 1 (то есть, пишется под этой порцией разрядов делимого и вычитается из нее), и очередным разрядом результата будет 1.</p>
<h2 id="40">Пример ручного расчета для 40 байтов</h2>
<p>Возьму образец, используемый в спецификации, в разделе, посвященном CRC-7:</p>
<blockquote>
<p>CMD17 (Argument=0) &ndash;&gt;<br>01 010001 00000000000000000000000000000000 <b>&ldquo;0101010&rdquo;</b>1</p>
</blockquote>
<p>Префикс команды (0b01), код команды (0b010001 = 0x11 = 17), 4 байта аргумента, 7 разрядов <abbr title="контрольная сумма">КС</abbr> (выделено полужирным и взято в кавычки) и последний разряд, обязательно равный единице. Можно попробовать пересчитать вручную <abbr title="контрольная сумма">КС</abbr>, а потом сравнить ее с приведенной в примере.</p>
<p>Начинаю расчет столбиком. Вместо последнего байта с <abbr title="контрольная сумма">КС</abbr> и единицей пишу 7 нулей после аргумента &mdash; это делимое. Образующий полином &mdash; это делитель:</p>
<pre>
  01010001000000000000000000000000000000000000000 <u>| 10001001 </u>
  <u>00000000 </u>                                       | 0
   10100010
</pre>

<p>Старшие 8 разрядов делимого начинаются на 0. Значит, первым (старшим) разрядом частного будет 0. Под старшими разрядами делимого пишем 8 нулей, производим вычитание (точнее, xor), игнорируем старший ноль, к получившимся семи разрядам добавляем очередной разряд из делимого, а там ноль.</p>
<pre>
  01010001000000000000000000000000000000000000000 <u>| 10001001 </u>
  <u>00000000 </u>                                       | 01
   10100010
   <u>10001001 </u>
    01010110
</pre>

<p>После вычитания (xor) в старшем разряде единица, значит, следующий разряд частного равен 1, для вычитания пишем уже не нули, а делитель. Вычитаем, игнорируем старший ноль, дописываем с младшей стороны ноль, взятый из делимого. Здесь при очередном вычитании множителем для делителя опять должен быть ноль, так как старший разряд уменьшаемого &mdash; ноль. И так далее.</p>
<p>Процедуру можно чуть-чуть упростить по аналогии с делением &laquo;школьным&raquo; столбиком. Вычитания делителя, умноженного на 0, не вносят никаких изменений, кроме сдвига для следующего вычитания и добавления еще одного нуля к разрядам частного. Значит, их можно не записывать, чтобы не увеличивать высоту &laquo;столбика&raquo;, а только добавлять нужное количество разрядов из делимого до длины делителя. Кроме того, нас интересует только остаток от деления, а частное никому не нужно, поэтому его тоже можно не записывать. Вот, что получается:</p>
<pre>
  01010001000000000000000000000000000000000000000 <u>| 10001001 </u>
   <u>10001001 </u>                                    .
    010101100                                   .
     <u>10001001  </u>                                 .
     0010010100                                 .
       <u>10001001 </u>                                .
        0011101000                              .
          <u>10001001</u>                              .
           11000010                             .
           <u>10001001 </u>                            .
            10010110                            .
            <u>10001001   </u>                         .
             0011111000                         .
               <u>10001001 </u>                        .
                11100010                        .
                <u>10001001 </u>                       .
                 11010110                       .
                 <u>10001001 </u>                      .
                  10111110                      .
                  <u>10001001  </u>                    .
                   011011100                    .
                    <u>10001001 </u>                   .
                     10101010                   .
                     <u>10001001  </u>                 .
                      010001100                 .
                       <u>10001001     </u>            .
                        000010100000            .
                            <u>10001001  </u>          .
                             010100100          .
                              <u>10001001  </u>        .
                               010110100        .
                                <u>10001001  </u>      .
                                 011110100      .
                                  <u>10001001 </u>     .
                                   11111010     .
                                   <u>10001001 </u>    .
                                    11100110    .
                                    <u>10001001 </u>   .
                                     11011110   .
                                     <u>10001001 </u>  .
                                      10101110  .
                                      <u>10001001  </u>.
                                       010011100.
                                        <u>10001001.</u>
                                         00101010
</pre>

<p>Последняя операция вычитания (xor) дает в результате число <code>0b10101</code>. Добавляем к нему справа последний нолик, оставшийся от делимого, получаем <code>0b101010</code>. Больше с ним ничего сделать нельзя &mdash; кончились неиспользованные разряды делимого. Этого числа явно недостаточно для того, чтобы вычесть из него делитель &mdash; оно короткое. Стало быть, это и есть искомый остаток. Его следует при необходимости дополнить слева нулями до семи разрядов. Нули слева все равно ничего не значат, а результат должен быть семиразрядным. В итоге получается <code>"0101010"</code>, что полностью совпадает с <abbr title="контрольная сумма">КС</abbr> в примере. Дописываем справа обязательную единицу и получаем последний байт сообщения, содержащего команду 17.</p>
<p>Так вычисляется контрольная сумма для передаваемых сообщений. Для принятых сообщений можно ее выделить, запомнить, заполнить нулями (отрезав последнюю единичку в случае с CRC-7), посчитать и сравнить с запомненной. Но можно сделать немного проще.</p>
<p>Если в случае обычного деления из делимого вычесть остаток, а результат поделить на тот же делитель, то остатком от деления будет ноль &mdash; это очевидно. При делении по модулю два получится примерно то же самое. Если из сообщения, дополненного семью нулями, вычесть по модулю 2 остаток от деления на образующий полином (то есть, CRC-7), то получится отправленное сообщение (без учета последней единички), потому что &laquo;исключающее ИЛИ&raquo; хвостовых нулей и CRC даст в результате CRC. Остаток от деления в этом случае тоже должен быть ноль:</p>
<pre>
  01010001000000000000000000000000000000000101010 <u>| 10001001 </u>
                              ...
                                   11111010     .
                                   <u>10001001 </u>    .
                                    11100111    .
                                    <u>10001001 </u>   .
                                     11011100   .
                                     <u>10001001 </u>  .
                                      10101011  .
                                      <u>10001001  </u>.
                                       010001001.
                                        <u>10001001.</u>
                                         00000000
</pre>

<p>Здесь пропущены первые (совпадающие) операции вычитания, показано только окончание, отличающееся тем, что вместо нулей на хвосте записан CRC-7.</p>
<p>Таким образом, проверка полученного сообщения может быть такой: отбрасываем хвостовую единицу и просто делим по модулю 2 на образующий полином. Если в результате получаем ноль, значит сообщение практически наверняка не сбойное. Теоретически можно, конечно, подобрать такой сбой, что CRC-7 не изменится, но это специально стараться надо. Случайная ошибка в паре-тройке разрядов к такому привести не может.</p>
<h2 id="_3">Автоматизация</h2>
<p>Говорят, у японцев есть поговорка, что если автоматизировать бардак, то получится автоматизированный бардак. Автоматизировать можно только то, что хорошо отработано вручную.</p>
<p>Расчет CRC-7 вручную выполнен успешно, принцип понятен. Можно поручить это дело программному автомату или схеме, построенной на логических элементах.</p>
<p>Для этого понадобится буферный сдвиговый регистр, аппаратный или программная переменная, к которой периодически применяется оператор арифметического сдвига влево.</p>
<p>Регистр должен иметь размерность, соответствующую образующему полиному &mdash; на единицу короче полинома. В случае с CRC-7 он должен быть семиразрядным и иметь бит переноса (или переполнения, как хотите). Аппаратно построить такой регистр не проблема, а программно нужно учитывать, что восьмой разряд нужно рассматривать, как бит переноса, и, если машинное слово длиннее 8 битов, то старшие биты игнорируются.</p>
<p>Для разных CRC регистр должен быть инициализирован разными начальными значениями. В случае с CRC-7 этот регистр изначально заполняется нулями. Ненулевая инициализация может быть полезной, если часто встречаются сообщения, начинающиеся с длинной последовательности нулей. Для ручного расчета столбиком требование ненулевой инициализации означает предварительное дописывание к сообщению с левой стороны начального значения регистра.</p>
<p>Сообщение, для которого рассчитывается <abbr title="контрольная сумма">КС</abbr>, лежит наготове для постепенного поразрядного захода в этот регистр:</p>
<pre>
  |0000000| <- 0101000100000000...
</pre>

<p>Запускаем цикл задвигания сообщения в регистр поразрядно. На каждом сдвиге проверяем бит переноса. Если из регистра выталкивается 0, то ничего не надо делать, продолжаем цикл:</p>
<pre>
  0 <- |0000000| <- 101000100000000...
</pre>

<pre>
  0 <- |0000001| <- 01000100000000...
</pre>

<pre>
  0 <- |0000010| <- 1000100000000...
</pre>

<p>&hellip;</p>
<pre>
  0 <- |1010001| <- 00000000...
</pre>

<p>И вот наступает момент, когда из регистра выдвигается 1. Это соответствует ситуации при делении столбиком, когда пора вычитать делитель:</p>
<pre>
  1 <- |0100010| <- 0000000...
</pre>

<p>Но делитель вычитался из <code>10100010</code>, а здесь, в регистре, осталось <code>0100010</code>. Старшая единица у операндов в тот момент, когда требуется вычитание, есть всегда, поэтому используется только для обнаружения этого момента, а результатом вычитания старшего разряда все равно всегда был 0. Поэтому для операции вычитания можно использовать не весь делитель, который был при делении столбиком, а тоже обрезанный на старшую единицу. Эту единицу будем подразумевать. От образующего полинома CRC-7 после отбрасывания старшей единицы и незначащих старших нулей остается <code>1001</code> двоичное, то есть, <code>9</code> десятичное и шестнадцатеричное.</p>
<p>Отсюда становится понятно, почему в справочных данных, например, на странице Википедии, пишут, что значении образующего полинома для CRC-7 равно 9, хотя при делении столбиком 9 не совсем подходит.</p>
<p>Итак, применяем &laquo;исключающее ИЛИ&raquo; с константой 9 к регистру</p>
<pre>
  1 <- |0100010| <- 0000000...
    xor 0001001
</pre>

<p>Получаем</p>
<pre>
       |0101011| <- 0000000...
</pre>

<p>И продолжаем сдвигать:</p>
<pre>
  0 <- |1010110| <- 000000...
</pre>

<p>На этом шаге снова делать ничего не надо, бит переноса равен нулю. А на следующем надо будет снова вычитать. И так до тех пор, пока не закончится счетчик цикла. В спецификации указано, что для команд защищается 40 разрядов, а для регистров CID и CSD &mdash; 120. И не забываем добавить к этому семь ноликов на хвосте, как при делении столбиком.</p>
<p>Это принято называть &laquo;прямым алгоритмом&raquo;. Для аппаратной реализации вполне сносная штука. Для программной имеет серьезный недостаток. Дело в том, что процессор оперирует минимально адресуемой единицей, которая редко бывает меньше восьми разрядов, а бывает и существенно больше. А в данном случае надо сдвигать по одному битику, затрачивая на чуть-чуть сдвинутые данные столько же, сколько на целый байт. Вот если бы сдвигать сразу байтами, то даже сдвигать не надо было бы &mdash; просто выполнять операции над последовательными байтами, образующими массив данных.</p>
<p>Для этого существуют табличные алгоритмы. Буферный сдвиговый регистр можно сделать побольше и продвигать через него не по биту, а по байту или даже больше. Выдвинутая часть будет не битом переноса, а адресом в заранее подготовленной таблице, в которой хранятся остатки от деления на образующий полином для всех вариантов, которые может содержать байт.</p>
<p>При этом понятно, что чем длиннее последовательность битов, обрабатываемая за раз, тем длиннее должна быть таблица с заранее посчитанными остатками для таких последовательностей. Неизбежный паритет между оптимальностью по быстродействию и оптимальностью по размеру. Таблицы для такого алгоритма можно составить самостоятельно, посчитав остатки от деления на образующий полином всех вариантов сдвигаемой за один раз единицы данных. А можно найти в интернете, в той же <a href="https://ru.wikibooks.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B8%D0%B7%D0%B1%D1%8B%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4">Википедии</a>.</p>
<p>Вот только реальное ускорение работы на табличных алгоритмах можно получить в том случае, если сдвиги будут производиться на величину, кратную минимально адресуемой единице. Поэтому они весьма популярны для CRC-16, CRC-32. Найти готовые таблицы для табличного алгоритма расчета CRC-7 у меня не получилось. И хотя в принципе известно, как заполнить такие таблицы самому, не вижу в этом смысла никакого. Тем более, для массива, размером в 40 разрядов.</p>
<p>Итак, понимая принцип вычисления CRC, можно реализовать ее на используемой архитектуре процессора/контроллера или ПЛИС, пользуясь предпочитаемым языком программирования/описания или просто паяльником. А сверить правильность работы реализованного автомата можно с помощью упомянутой уже страницы <a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B8%D0%B7%D0%B1%D1%8B%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4">Википедии</a>, на которой приведены результаты вычисления различных CRC  для строки &laquo;123456789&raquo;, которая в шестнадцатеричном виде выглядит, как <code>31 32 33 34 35 36 37 38 39</code>.</p>
<p>И напоследок, немного воспоминаний на эту тему. Относительно давно пришлось с коллегой дорабатывать имеющуюся специализированную встроенную систему для того, чтобы она могла сбрасывать накопленный буфер данных килобайтной длины по UART. К пакету нужно было прицепить CRC-16. UART-передатчик был реализован на ПЛИС. Попробовали разные варианты. Самый быстрый вариант программного табличного расчета CRC-16 вызывал задержку между окончанием передачи тела пакета и началом передачи посчитанной <abbr title="контрольная сумма">КС</abbr>, причем, весьма заметную задержку. Аппаратная реализация прямого алгоритма на ПЛИС, считающая CRC на лету и выдающая результат в конце тела пакета, не позволяла заметить на глаз разрыва в передаче на экране осциллографа.</p>
<h2 id="-cid">Еще один пример &mdash; CID</h2>
<p>В предыдущем <a href="http://romeogolf.github.io/usb-polygon-18.html#crc">опусе</a> я упомянул, что при отработке получения регистров CID и CSD я посчитал вручную CRC-7 для CID. Это, собственно, и послужило темой для нынешнего опуса. А вот, собственно, и расчет CRC-7 для конкретного полученного регистра, выполненный столбиком вручную.</p>
<p>Логичнее на стороне приема вычислить остаток от деления на образующий многочлен и получить ноль. Но я буду вычислять именно контрольную сумму.</p>
<p>Для начала вот строчка, содержащая считанный CID:</p>
<div class="highlight"><pre>00000000: 13 4b 47 53 44 35 31 32 10 f7 02 80 11 00 68 e9  .KGSD512......h.
</pre></div>


<p>Байт с контрольной суммой <code>0xe9 = 0b11101001</code>.</p>
<p>Дальше идет разложенный в двоичное представление регистр и операции с ним. Получилось очень длинно, поэтому в два приема, с переносом. Первая половина регистра:</p>
<pre>
    13  |   4b  |   47  |   53  |   44  |   35  |   31  |   32  |
 0001001101001011010001110101001101000100001101010011000100110010
    <u>10001001   </u>
     0010011010
       <u>10001001   </u>
        0010011110
          <u>10001001   </u>
           0010111100
             <u>10001001  </u>
              011010101
               <u>10001001 </u>
                10111001
                <u>10001001  </u>
                 011000010
                  <u>10001001 </u>
                   10010111
                   <u>10001001   </u>
                    0011110010
                      <u>10001001 </u>
                       11110110
                       <u>10001001 </u>
                        11111111
                        <u>10001001 </u>
                         11101101
                         <u>10001001 </u>
                          11001000
                          <u>10001001 </u>
                           10000011
                           <u>10001001    </u>
                            00010100001
                               <u>10001001  </u>
                                010100000
                                 <u>10001001  </u>
                                  010100100
                                   <u>10001001  </u>
                                    010110111
                                     <u>10001001  </u>
                                      011111001
                                       <u>10001001 </u>
                                        11100000
                                        <u>10001001 </u>
                                         11010011
                                         <u>10001001 </u>
                                          10110100
                                          <u>10001001  </u>
                                           011110101
                                            <u>10001001 </u>
                                             11111001
                                             <u>10001001 </u>
                                              11100000
                                              <u>10001001 </u>
                                               11010010
                                               <u>10001001 </u>
                                                10110110
                                                <u>10001001  </u>
                                                 011111110
                                                  <u>10001001 </u>
                                                   11101110
                                                   <u>10001001 </u>
                                                    11001111
                                                    <u>10001001 </u>
                                                     10001101
                                                     <u>10001001    </u>
                                                      00001000010
</pre>

<p>Вторая половина регистра, дополненная слева переносом от первой половины, а справа отрезан байт с <abbr title="контрольная сумма">КС</abbr>, но дописаны 7 нулей:</p>
<pre>
 перенос   |   10  |   f7  |   02  |   80  |   11  |   00  |   68  |  CRC  |
 00001000010000100001111011100000010100000000001000100000000011010000000000
     <u>10001001    </u>
      00011010010
         <u>10001001 </u>
          10110110
          <u>10001001  </u>
           011111100
            <u>10001001 </u>
             11101011
             <u>10001001 </u>
              11000101
              <u>10001001 </u>
               10011001
               <u>10001001   </u>
                0010000101
                  <u>10001001    </u>
                   00011001100
                      <u>10001001 </u>
                       10001010
                       <u>10001001      </u>
                        0000011000101
                             <u>10001001 </u>
                              10011000
                              <u>10001001   </u>
                               0010001000
                                 <u>10001001       </u>
                                  00000010000001
                                        <u>10001001    </u>
                                         00010000001
                                            <u>10001001    </u>
                                             00010000000
                                                <u>10001001    </u>
                                                 00010010000
                                                    <u>10001001   </u>
                                                     0011001011
                                                       <u>10001001 </u>
                                                        10000100
                                                        <u>10001001    </u>
                                                         00011011000
                                                            <u>10001001 </u>
                                                             10100010
                                                             <u>10001001  </u>
                                                              010101100
                                                               <u>10001001  </u>
                                                                010010100
                                                                 <u>10001001  </u>
                                                                  001110100
</pre>

<p>Берем остаток: <code>1110100</code> и приклеиваем справа обязательную единицу. Получаем <code>11101001</code>, то есть <code>0xE9</code>, что и требовалось получить.</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "drafts/usb-polygon-19.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>