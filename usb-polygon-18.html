<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-18: Подключение SD-карты</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">22</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/nishchebrod.html">
              нищеброд
                <span class="badge">5</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pokhodnoe.html">
              походное
                <span class="badge">5</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/samodelki.html">
              самоделки
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Ср 16 Май 2018</h4>
    <article>
      <h1>USB-polygon-18: Подключение SD-карты</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Введение</a></li>
<li><a href="#_2">Подключение карты к устройству</a></li>
<li><a href="#_3">Инициализация карты</a></li>
<li><a href="#_4">Чтение регистров</a><ul>
<li><a href="#_5">Подготовка</a></li>
<li><a href="#cid">Разбор CID</a></li>
<li><a href="#csd">Разбор CSD</a></li>
</ul>
</li>
<li><a href="#_6">Чтение данных</a><ul>
<li><a href="#_7">Маленько</a></li>
<li><a href="#_8">Как можно больше</a></li>
</ul>
</li>
<li><a href="#_9">Стирание</a></li>
<li><a href="#_10">Проба записи</a></li>
<li><a href="#_11">Запись данных с ПК</a><ul>
<li><a href="#_12">Маленько и просто</a></li>
<li><a href="#_13">Побольше и посложнее</a></li>
</ul>
</li>
<li><a href="#_14">Пример использования</a></li>
<li><a href="#_15">Итог</a></li>
</ul>
</div>
<h2 id="_1">Введение</h2>
<p>К отладочной плате по SPI подключен экран. Хочется попробовать подключить также внешнюю энергонезависимую память.</p>
<p>Пожалуй, самый простой вариант &mdash; это SD-карточка в режиме SPI. Буду цеплять ее параллельно с экраном.</p>
<p>Полезная вещь, например, для хранения знаков для экрана, чтобы не занимать память контроллера. Опять же, на будущее &mdash; для хранения настроек прибора, скажем, последней использованной температуры паяльника в самодельной паяльной станции. Можно, конечно, воспользоваться энергонезависимой памятью самого контроллера. Но, во-первых, ресурс памяти по чтению-стиранию-записи не бесконечен, а карточку заменить проще. Во-вторых, теоретически может понадобиться большой объем данных, например, под картинки для вывода на экран или звуки какие-нибудь. Причем, карточку с набором &laquo;файлов&raquo; можно заменять для использования другого набора.</p>
<p>В конце концов, хочется просто опробовать работу с картой памяти: вдруг пригодится когда-нибудь.</p>
<h2 id="_2">Подключение карты к устройству</h2>
<p>Нашел в закромах старенькую карточку Kingmax на 512 МБ. Вещь из тех, что &laquo;девать некуда, и выкинуть жалко&raquo;. Найти ей применение сегодня непросто: почти везде в современных гаджетах используются microSD, да и такой объем памяти почти бесполезен даже в приборах постарше &mdash; ни в фотоаппарат, ни, тем более, видеорегистратор&hellip; Вот и очень хорошо, что ей выпал шанс еще поработать.</p>
<p>Как обычно, сперва порылся в интернетах в поисках распиновки и системы команд. Нарыл следующее:</p>
<ol>
<li>Спецификация <a href="https://www.sdcard.org/downloads/pls/click.php?p=Part1_Physical_Layer_Simplified_Specification_Ver6.00.jpg&amp;f=Part1_Physical_Layer_Simplified_Specification_Ver6.00.pdf&amp;e=EN_SS1">Part_1_Physical_Layer_Simplified_Specification_Ver6.00</a> с сайта <a href="http://www.sdcard.org">SD card</a>, &mdash; первоисточник, библия, камасутра и устав. Тут есть все, что надо, но на английском и местами не очень понятно даже при знании английского. На момент написания данного опуса спецификация версии 6.0 самая свежая, в ней даже есть цоколевка карт (в отличие от, скажем, версии 3.01).</li>
<li>Вольный <a href="http://microsin.net/programming/file-systems/sd-specifications-part-1-physical-layer-simplified-specification-ver-200.html">перевод</a> упомянутого документа и вынесенная отдельно <a href="http://microsin.net/programming/file-systems/sd-specifications-part-1-physical-layer-simplified-specification-ver-200-spi-mode.html">глава 7 про SPI</a>, что удобно для чтения по диагонали и поиска места, нужного именно сейчас, чтобы вдумчиво почитать в оригинале.</li>
<li>Статья <a href="http://elm-chan.org/docs/mmc/mmc_e.html">&laquo;Как работать с SD-картой&raquo;</a> на английском.</li>
<li>Ее переводы <a href="http://piclist.ru/S-MMC-SD-Cards-RUS/S-MMC-SD-Cards-RUS.html">1</a> и <a href="http://microsin.net/programming/file-systems/howto-use-mmc-sdc.html">2</a> на русский.</li>
<li>Пожалуй, самое полезное, полное и с хорошим примером из того, что я нашел на русском &mdash; статья в двух частях (<a href="http://we.easyelectronics.ru/AVR/mmcsd-i-avr-chast-1-inicializaciya-i-identifikaciya.html">1</a> и <a href="http://we.easyelectronics.ru/AVR/mmcsd-i-avr-chast-2-rabota-s-kartoy.html">2</a>), в которой есть все для того, чтобы взять паяльник и попробовать.</li>
</ol>
<p>Беру паяльник и пробую. Гнезда для карты у меня нет, покупать не хочу, делать сам &mdash; тоже. Просто припаял провода к контактам карты. Потом пожалел об этом. Надо было сперва дамп снять с помощью кардридера, хотя бы первых секторов, чтобы было потом с чем сравнивать чтение по SPI, ну да ладно.</p>
<p>Припаял опять же провода МГТФ. С имеющимся в наличии плоским шлейфом не сложилось: очень уж легкоплавкая изоляция у него, а паяльник у меня так себе. Получилось так:</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/18/card-text.jpg" title="Распайка карты"><img alt="Распайка карты" src="http://romeogolf.github.io/images/usb-polygon/18/preview/card-text-prew.jpg" title="Распайка карты"></a></p>
<p>На устройстве провода припаял к контактным площадкам порта B, некоторые к уже занятым площадкам, вместе с проводами экрана от Nokia:</p>
<ul>
<li>1 контакт подсоединил к площадке разряда 6: это CS, но &laquo;штатный&raquo; CS SPI-порта занят на экран, буду использовать пока свободный 6 разряд;</li>
<li>2 контакт &mdash; к площадке 2: Data In к MOSI;</li>
<li>3 и 6 контакты &mdash; на корпус, на полигон лицевой стороны устройства;</li>
<li>4 контакт &mdash; питание &mdash; к тому же стабилизатору, от которого питается экран;</li>
<li>5 контакт &mdash; к площадке 1, это CLK;</li>
<li>7 контакт &mdash; к площадке 3: Data Out к MISO;</li>
</ul>
<p>Контакты DI и DO должны быть &laquo;подтянуты&raquo; к питанию через 50-килоомные резисторы. Я сделал это прямо на карточке, но резисторы нашел на 30 кОм.</p>
<p>8 и 9 контакты карточки в режиме SPI не используются. На устройстве площадка 5 занята под (D/C) экрана, площадка 4 &mdash; под сброс экрана. Осталась свободной еще площадка 7 разряда.</p>
<p>В файл <code>common.h</code> теперь надо добавить определение для нового подключенного разряда:</p>
<div class="highlight"><pre><span></span>    <span class="cp">#define BIT_CS_SD (1 &lt;&lt; 6)</span>
</pre></div>


<p>Устройство в сборе стало выглядеть еще страшнее:</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/18/all-front.jpg" title="Подключение"><img alt="Подключение - вид сверху" src="http://romeogolf.github.io/images/usb-polygon/18/preview/all-front-prew.jpg" title="Подключение"></a>
<a href="http://romeogolf.github.io/images/usb-polygon/18/all-back.jpg" title="Подключение"><img alt="Подключение - вид снизу" src="http://romeogolf.github.io/images/usb-polygon/18/preview/all-back-prew.jpg" title="Подключение"></a></p>
<h2 id="_3">Инициализация карты</h2>
<p>Процедура инициализации просто и понятно расписана в первой части упомянутой выше <a href="http://we.easyelectronics.ru/AVR/mmcsd-i-avr-chast-1-inicializaciya-i-identifikaciya.html">статьи</a>.</p>
<p>Для работы с картой, инициализации в том числе, понадобятся функции байтового обмена по SPI. Сделаю их по аналогии с <code>out8bit()</code>, работающей с экраном, только буду использовать линию CS карты и добавлю помимо функции записи еще и функцию чтения:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">SdOutByte</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">data8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT_CS_SD</span><span class="p">;</span>            <span class="c1">// cs -&gt; 0</span>
    <span class="n">SPDR</span> <span class="o">=</span> <span class="n">data8</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">SPSR</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SPIF</span><span class="p">)))</span> <span class="p">;</span> <span class="c1">// wait for transmit</span>
    <span class="n">PORTB</span> <span class="o">|=</span> <span class="n">BIT_CS_SD</span><span class="p">;</span>             <span class="c1">// cs -&gt; 1</span>
<span class="p">}</span>

<span class="kt">uint8_t</span> <span class="nf">SdInByte</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT_CS_SD</span><span class="p">;</span>            <span class="c1">// cs -&gt; 0</span>
    <span class="n">SPDR</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">SPSR</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SPIF</span><span class="p">)))</span> <span class="p">;</span> <span class="c1">// wait for transmit</span>
    <span class="n">PORTB</span> <span class="o">|=</span> <span class="n">BIT_CS_SD</span><span class="p">;</span>             <span class="c1">// cs -&gt; 1</span>
    <span class="k">return</span> <span class="n">SPDR</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Как можно заметить, я включаю CS карты для каждого байта отдельно, а не на весь период обмена. Возможно, это не слишком оптимально с точки зрения быстродействия. Но при обмене по SPI все равно работа не слишком быстрая, зато так надежнее при одновременно подключенных нескольких ведомых: точно не пересекутся.</p>
<p>На основе этих функций можно сделать функцию отправки команды карте. Для этого добавлю тип-перечисление для выбора типа отклика на команду, а еще объявлю переменную-массив для получения этого самого отклика. В максимальном варианте он будет пятибайтовым, а в случае ответа типа R1 буду читать только первый байт этого массива.</p>
<div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">ResponceType</span> <span class="p">{</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">R7</span><span class="p">};</span>
<span class="kt">uint8_t</span> <span class="n">sdResponce</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</pre></div>


<p>Теперь можно добавить и функцию для командования флэшкой:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">SdSendCommand</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">Index</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">Argument</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">Crc</span><span class="p">,</span>
                   <span class="k">enum</span> <span class="n">ResponceType</span> <span class="n">responceType</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">Responce</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SdOutByte</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
    <span class="n">SdOutByte</span><span class="p">(</span><span class="n">Index</span><span class="p">);</span>
    <span class="n">SdOutByte</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">Argument</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">));</span>
    <span class="n">SdOutByte</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">Argument</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
    <span class="n">SdOutByte</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">Argument</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">));</span>
    <span class="n">SdOutByte</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">Argument</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">SdOutByte</span><span class="p">(</span><span class="n">Crc</span><span class="p">);</span>

    <span class="kt">uint8_t</span> <span class="n">cntErr</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">Responce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">cntErr</span><span class="o">--</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">Responce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">switch</span><span class="p">(</span><span class="n">responceType</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">R1</span><span class="p">:</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">R2</span><span class="p">:</span>
            <span class="n">Responce</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">R3</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">R7</span><span class="p">:</span>
            <span class="n">Responce</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>
            <span class="n">Responce</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>
            <span class="n">Responce</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>
            <span class="n">Responce</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Параметры функции: индекс команды с уже добавленным префиксом, аргумент команды, контрольная сумма, тип ответа и указатель на буфер, в который будет прочитан ответ.</p>
<p>Тип ответа надо указывать, соответствующий индексу команды в первом параметре. Контрольную сумму можно использовать, а можно и нет: по умолчанию ее вычисление в режиме SPI отключено, но младший бит должен быть &laquo;1&raquo;.</p>
<p>А индексы команд надо бы определить отдельно макросообразно для удобства:</p>
<div class="highlight"><pre><span></span><span class="cm">/* =============================================================== */</span>
<span class="cm">/* MMC card commands                                               */</span>
<span class="cm">/* =============================================================== */</span>
<span class="cm">/* Standart card commands CMDx */</span>
<span class="cp">#define MMC_COMMANDS_BASE       (unsigned char) 0x40</span>
<span class="cp">#define MMC_GO_IDLE_STATE       MMC_COMMANDS_BASE + 0         </span><span class="c1">// CMD0</span>
<span class="cp">#define MMC_SEND_OP_COND        MMC_COMMANDS_BASE + 1         </span><span class="c1">// CMD1</span>
<span class="cp">#define MMC_SEND_IF_COND        MMC_COMMANDS_BASE + 8         </span><span class="c1">// CMD8</span>
<span class="cp">#define MMC_SEND_CSD            MMC_COMMANDS_BASE + 9         </span><span class="c1">// CMD9</span>
<span class="cp">#define MMC_SEND_CID            MMC_COMMANDS_BASE + 10        </span><span class="c1">// CMD10</span>
<span class="cp">#define MMC_SEND_STATUS         MMC_COMMANDS_BASE + 13        </span><span class="c1">// CMD13</span>
<span class="cp">#define MMC_READ_SINGLE_BLOCK   MMC_COMMANDS_BASE + 17        </span><span class="c1">// CMD17</span>
<span class="cp">#define MMC_WRITE_SINGLE_BLOCK  MMC_COMMANDS_BASE + 24        </span><span class="c1">// CMD24</span>
<span class="cp">#define MMC_APP_CMD             MMC_COMMANDS_BASE + 55        </span><span class="c1">// CMD55</span>
<span class="cp">#define MMC_READ_OCR            MMC_COMMANDS_BASE + 58        </span><span class="c1">// CMD58</span>
<span class="c1">// Application specific command ACMDx</span>
<span class="cp">#define MMC_CMD_SD_STATUS       MMC_COMMANDS_BASE + 13        </span><span class="c1">// ACMD13</span>
<span class="cp">#define MMC_CMD_SD_SEND_OP_COND MMC_COMMANDS_BASE + 41        </span><span class="c1">// ACMD41</span>
<span class="cp">#define MMC_CMD_SD_SEND_SCR     MMC_COMMANDS_BASE + 51        </span><span class="c1">// ACMD51</span>
</pre></div>


<p>Это определение команд я бессовестно упер из упомянутой <a href="http://we.easyelectronics.ru/AVR/mmcsd-i-avr-chast-2-rabota-s-kartoy.html">статьи</a>, точнее, из приложенного к ней примера кода.</p>
<p>Теперь после функций инициализации экрана и перед вызовом <code>SetupHardware()</code> начинаю инициализировать карту. Для начала надо отправить на нее минимум 74 такта CLK по SPI:</p>
<div class="highlight"><pre><span></span>    <span class="c1">// ********************************</span>
    <span class="cm">/* SD card */</span>

    <span class="cm">/* &gt; 74 clk to init */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SdOutByte</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<p>Затем подаю команду 0, без аргументов (точнее, с нулем в аргументе), с заранее вычисленной контрольной суммой (это важно, пока не перешли в режим SPI), с ожиданием отклика R1, который надо записать в <code>sdResponce</code>:</p>
<div class="highlight"><pre><span></span>    <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_GO_IDLE_STATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
</pre></div>


<p>Далее жду отклик:</p>
<div class="highlight"><pre><span></span>    <span class="kt">uint16_t</span> <span class="n">cntErr</span> <span class="o">=</span> <span class="mh">0x7FF</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">sdResponce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_SEND_OP_COND</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">sdResponce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cntErr</span><span class="o">--</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">));</span>

        <span class="n">PORTD</span> <span class="o">=</span> <span class="mh">0x1C</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sdResponce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PORTD</span> <span class="o">=</span> <span class="mh">0x55</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* error! */</span>
        <span class="n">PORTD</span> <span class="o">=</span> <span class="mh">0xAA</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(;;){}</span>
</pre></div>


<p>В качестве параметра <code>Crc</code> для <code>SdSendCommand()</code> передается единица. В режиме SPI, напомню, проверка CRC7 отключена по умолчанию, но в младшем разряде обязательно должна быть единица, так что можно передавать любое нечетное число.</p>
<p>В переменной <code>cntErr</code> будет счетчик таймаута ожидания. Отправляю команду 1 до тех пор, пока не получу нулевой отклик, либо до таймаута. И здесь выставляю на светодиодах 0x1C, то есть, три огонька в серединке.</p>
<p>Затем проверяю отклик на не ноль. Если не ноль, то зажигаю светодиоды через один, начиная с младшего. А если отклик не пришел и на команду 0 (до команды 1 дело не дошло) &mdash; зажигаю светодиоды через один, начиная со второго.</p>
<p>И наконец, запрещаю дальнейшую программу при помощи мертвого цикла <code>for</code>, чтобы посмотреть, что же будет на светодиодах.</p>
<p>В результате вижу три огонька подряд посередке, а это значит, что команда 0 прошла, команда 1 тоже прошла, и отклик на нее получен. Карта инициализирована.</p>
<p>Надо сказать, что проведена инициализация по самому простому варианту, и не все карты таким образом можно инициализировать. Но я использую карту SD &mdash; не SDHC и не SDXC, при этом карта припаяна, то есть, вставлять другую не предполагается. Поэтому начал с простейшего способа, который должен был заработать. И заработал.</p>
<h2 id="_4">Чтение регистров</h2>
<h3 id="_5">Подготовка</h3>
<p>Судя по косвенным признакам (по состоянию светодиодов), с картой уже можно работать. Но хотелось бы получить более достоверное подтверждение инициализированности карты. Пожалуй, считаю-ка я регистры CID и CSD. Заодно получу более полную информацию о том, что же у меня за карта и что она может.</p>
<p>Добавлю соответствующую функцию: <code>SdReadReg()</code>, но для нее заранее добавлю функцию ожидания токена данных и тип-перечисление для выбора требуемого регистра. Ожидание токена данных пригодится и дальше при чтении данных.</p>
<p>Кстати, надо добавить и определение токена чуть ниже определения кодов команд:</p>
<div class="highlight"><pre><span></span><span class="c1">//==================================================================//</span>
<span class="c1">// MMC data tokens                                                  //</span>
<span class="c1">//==================================================================//</span>
<span class="cp">#define MMC_START_TOKEN_SINGLE (unsigned char) 0xFE</span>
<span class="c1">//==================================================================//</span>
</pre></div>


<p>Вставляю где-нибудь чуть выше определения функции <code>SdOutByte()</code>:</p>
<div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">RegType</span> <span class="p">{</span><span class="n">CID</span><span class="p">,</span> <span class="n">CSD</span><span class="p">};</span>
</pre></div>


<p>А после <code>SdSendCommand()</code> записываю:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">SdWaitForDataToken</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">answer</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">maxErrors</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

  <span class="k">do</span> <span class="p">{</span>
      <span class="n">answer</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">maxErrors</span><span class="o">--</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">answer</span> <span class="o">!=</span> <span class="n">MMC_START_TOKEN_SINGLE</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">answer</span> <span class="o">!=</span> <span class="n">MMC_START_TOKEN_SINGLE</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">SdReadReg</span><span class="p">(</span><span class="k">enum</span> <span class="n">RegType</span> <span class="n">regType</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">regType</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">CID</span><span class="p">:</span>
            <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_SEND_CID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">CSD</span><span class="p">:</span>
            <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_SEND_CSD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sdResponce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">SdWaitForDataToken</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">SdOutByte</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
            <span class="n">SdOutByte</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Тут все достаточно несложно. Сперва в функции проверяется, какой из регистров нужно читать, при этом формируется соответствующая команда для карточки. Аргумент нулевой, <abbr title="контрольная сумма">КС</abbr> нулевая с единицей в младшем разряде, ожидается отклик типа R1, который будет записан в буфер sdResponce.</p>
<p>Далее проверяется полученный отклик, и если он равен нулю, то есть, все в порядке, то ждем токен данных. Дождавшись пишем 16 байтов в буфер (передаваемый по указателю).</p>
<p>Потом идет запись двух байтов &mdash; зачем? Затем, что карта добавляет к блоку данных два байта контрольной суммы. Их тоже нужно прочитать, чтобы завершить операцию. Но сами байты <abbr title="контрольная сумма">КС</abbr> нас не интересуют. Поэтому можно просто выдать дважды восемь тактов частоты по SCLK. Для этого можно использовать как функцию чтения, так и функцию записи, не принципиально. Семантически вернее вставить чтение, а результаты игнорировать. Но, во-первых, в прототипе (в коде, на котором я основывался) была запись, а во-вторых, захотелось попробовать и посмотреть на результат. Может, позже исправлю.</p>
<p>Функция возвращает булев тип, <code>true</code> если все прошло успешно, и <code>false</code>, если выбран неправильный регистр (что почти нереально), если получен ненулевой отклик на команду или долго нет токена данных.</p>
<p>Теперь надо закрыть мертвый цикл, который был нужен, чтобы посмотреть состояние светодиодов после инициализации карты. Кроме того, открываю закрытый ранее фрагмент кода, инициализировавший 128-байтовый буфер данных, но заполняю его теперь, скажем, <code>0x0F</code>, после чего вызываю команду чтения регистра:</p>
<div class="highlight"><pre><span></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
        <span class="cm">/*data[i] = 0x0F;*/</span>
    <span class="p">}</span>

    <span class="n">SdReadReg</span><span class="p">(</span><span class="n">CID</span> <span class="cm">/*CSD/*, data);</span>
</pre></div>


<p>Теперь после подачи питания на устройство инициализируется карточка (после экрана, конечно), а затем, перед выполнением основного цикла программы, содержимое выбранного регистра читается в буферный массив. В модуле <code>fake_fs</code> уже реализовано чтение на <abbr title="персональный компьютер">ПК</abbr> этого массива в виде файла <code>DATA.BIN</code>.</p>
<p>Теперь можно считать оба регистра по очереди. Правда, для выбора второго регистра надо переместить символы комментария в вызове функции <code>SdReadReg()</code> и перекомпилировать программу. Можно, конечно, сделать выбор регистра при помощи кнопок на устройстве, либо при помощи чтения какого-то специального служебного &laquo;файла&raquo;, но операция одноразовая, так что не стоит усложнять код ради такого.</p>
<h3 id="cid">Разбор CID</h3>
<p>После компиляции и перепрошивки открываю на устройстве файл <code>DATA.BIN</code>:</p>
<div class="highlight"><pre><span></span>00000000: 13 4b 47 53 44 35 31 32 10 f7 02 80 11 00 68 e9  .KGSD512......h.
00000010: 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f  ................
...
</pre></div>


<p>И далее до 128 байтов. Интересуют первые 16. Регистр передается старшим байтом вперед, поэтому в буфере он как бы развернут, старший байт имеет смещение 0. Разберу CID в соответствии со спецификацией:</p>
<div class="colortable"></div>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Field</th>
<th align="left">Width</th>
<th align="left">CID-slice</th>
<th align="left">Значение</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Manufacturer ID</td>
<td align="left">MID</td>
<td align="left">8</td>
<td align="left">[127:120]</td>
<td align="left">0x13</td>
</tr>
<tr>
<td align="left">OEM/Application ID</td>
<td align="left">OID</td>
<td align="left">16</td>
<td align="left">[119:104]</td>
<td align="left">KG</td>
</tr>
<tr>
<td align="left">Product name</td>
<td align="left">PNM</td>
<td align="left">40</td>
<td align="left">[103:64]</td>
<td align="left">SD512</td>
</tr>
<tr>
<td align="left">Product revision</td>
<td align="left">PRV</td>
<td align="left">8</td>
<td align="left">[63:56]</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">Product serial number</td>
<td align="left">PSN</td>
<td align="left">32</td>
<td align="left">[55:24]</td>
<td align="left">0x118002F7</td>
</tr>
<tr>
<td align="left">reserved</td>
<td align="left">&ndash;</td>
<td align="left">4</td>
<td align="left">[23:20]</td>
<td align="left">0x0</td>
</tr>
<tr>
<td align="left">Manufacturing date</td>
<td align="left">MDT</td>
<td align="left">12</td>
<td align="left">[19:8]</td>
<td align="left">Июнь 2008</td>
</tr>
<tr>
<td align="left">CRC7 checksum</td>
<td align="left">CRC</td>
<td align="left">7</td>
<td align="left">[7:1]</td>
<td align="left">0x64</td>
</tr>
<tr>
<td align="left">not used, always 1</td>
<td align="left">&ndash;</td>
<td align="left">1</td>
<td align="left">[0:0]</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>Значение контрольной суммы в таблице записал с учетом сдвига вправо, так как младший разряд этого байта к ней не относится, она семиразрядная. Остальное все достаточно очевидно. Правда, числовые данные мне ни о чем не говорят, но &laquo;KG&raquo; для KingsMax выглядит довольно логично, а &laquo;SD512&raquo; для карточки SD объемом 512 МБ вообще подходит идеально. Из чего делаю вывод (даже не пересчитывая <abbr title="контрольная сумма">КС</abbr>), что прочитал нужный регистр и правильно.</p>
<p id="crc">А еще я посчитал вручную CRC7 этого пакета данных и убедился в его совпадении. Но рассказ о пересчете <abbr title="контрольная сумма">КС</abbr> заслуживает отдельного разговора.</p>
<h3 id="csd">Разбор CSD</h3>
<p>Заменяю в команде чтения регистра &laquo;CID&raquo; на &laquo;CSD&raquo;, перекомпилирую, перезапускаю питание, и в открывшемся на <abbr title="персональный компьютер">ПК</abbr> окне устройства опять читаю файл <code>DATA.BIN</code>:</p>
<div class="highlight"><pre><span></span>00000000: 00 5e 00 32 57 59 83 ba ed b7 7f 8f 96 40 00 45  .^.2WY.......@.E
00000010: 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f  ................
...
</pre></div>


<p>И далее до 128 байтов. Буду разбирать, подобно CID, но это посложнее, потому что больше полей, и многие поля не кратны байту или полубайту. Проще бы сделать это программно, но вручную несколько нагляднее. Сделаю это (для примера), хотя в данном применении реально нужно всего несколько полей.</p>
<div class="colortable mini"></div>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Field</th>
<th align="left">Width</th>
<th align="left">Value</th>
<th align="left">Cell<br>Type</th>
<th align="left">CSD-slice</th>
<th>Значение</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">CSD structure</td>
<td align="left">CSD_STRUCTURE</td>
<td align="left">2</td>
<td align="left">00b</td>
<td align="left">R</td>
<td align="left">[127:126]</td>
<td>0 &#8658; v 1.0</td>
</tr>
<tr>
<td align="left">reserved</td>
<td align="left">&ndash;</td>
<td align="left">6</td>
<td align="left">00 0000b</td>
<td align="left">R</td>
<td align="left">[125:120]</td>
<td>0</td>
</tr>
<tr>
<td align="left">data read<br>access-time-1</td>
<td align="left">TAAC</td>
<td align="left">8</td>
<td align="left">xxh</td>
<td align="left">R</td>
<td align="left">[119:112]</td>
<td>0x5E &#8658; 5.0&nbsp;&middot;&nbsp;1ms</td>
</tr>
<tr>
<td align="left">data read<br>access-time-2 in<br>CLK cycles (NSAC*100)</td>
<td align="left">NSAC</td>
<td align="left">8</td>
<td align="left">xxh</td>
<td align="left">R</td>
<td align="left">[111:104]</td>
<td>0</td>
</tr>
<tr>
<td align="left">max. data<br>transfer rate</td>
<td align="left">TRAN_SPEED</td>
<td align="left">8</td>
<td align="left">32h or 5Ah</td>
<td align="left">R</td>
<td align="left">[103:96]</td>
<td>0x32 &#8658; 25 МГц</td>
</tr>
<tr>
<td align="left">card command classes</td>
<td align="left">CCC</td>
<td align="left">12</td>
<td align="left">01x110110101b</td>
<td align="left">R</td>
<td align="left">[95:84]</td>
<td>010101110101</td>
</tr>
<tr>
<td align="left">max. read data<br>block length</td>
<td align="left">READ_BL_LEN</td>
<td align="left">4</td>
<td align="left">xh</td>
<td align="left">R</td>
<td align="left">[83:80]</td>
<td>9 &#8658; 512</td>
</tr>
<tr>
<td align="left">partial blocks<br>for read allowed</td>
<td align="left">READ_BL_PARTIAL</td>
<td align="left">1</td>
<td align="left">1b</td>
<td align="left">R</td>
<td align="left">[79:79]</td>
<td>1</td>
</tr>
<tr>
<td align="left">write block<br>misalignment</td>
<td align="left">WRITE_BLK_MISALIGN</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R</td>
<td align="left">[78:78]</td>
<td>0</td>
</tr>
<tr>
<td align="left">read block<br>misalignment</td>
<td align="left">READ_BLK_MISALIGN</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R</td>
<td align="left">[77:77]</td>
<td>0</td>
</tr>
<tr>
<td align="left">DSR implemented</td>
<td align="left">DSR_IMP</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R</td>
<td align="left">[76:76]</td>
<td>0</td>
</tr>
<tr>
<td align="left">reserved</td>
<td align="left">&ndash;</td>
<td align="left">2</td>
<td align="left">00b</td>
<td align="left">R</td>
<td align="left">[75:74]</td>
<td>0</td>
</tr>
<tr>
<td align="left">device size</td>
<td align="left">C_SIZE</td>
<td align="left">12</td>
<td align="left">xxxh</td>
<td align="left">R</td>
<td align="left">[73:62]</td>
<td>EEB &#8658; 477,5 MiB</td>
</tr>
<tr>
<td align="left">max. read<br>current @VDD min</td>
<td align="left">VDD_R_CURR_MIN</td>
<td align="left">3</td>
<td align="left">xxxb</td>
<td align="left">R</td>
<td align="left">[61:59]</td>
<td>3 &#8658; 10 мА</td>
</tr>
<tr>
<td align="left">max. read<br>current @VDD max</td>
<td align="left">VDD_R_CURR_MAX</td>
<td align="left">3</td>
<td align="left">xxxb</td>
<td align="left">R</td>
<td align="left">[58:56]</td>
<td>3 &#8658; 10 мА</td>
</tr>
<tr>
<td align="left">max. write<br>current @VDD min</td>
<td align="left">VDD_W_CURR_MIN</td>
<td align="left">3</td>
<td align="left">xxxb</td>
<td align="left">R</td>
<td align="left">[55:53]</td>
<td>3 &#8658; 25 мА</td>
</tr>
<tr>
<td align="left">max. write<br>current @VDD max</td>
<td align="left">VDD_W_CURR_MAX</td>
<td align="left">3</td>
<td align="left">xxxb</td>
<td align="left">R</td>
<td align="left">[52:50]</td>
<td>3 &#8658; 25 мА</td>
</tr>
<tr>
<td align="left">device size<br>multiplier</td>
<td align="left">C_SIZE_MULT</td>
<td align="left">3</td>
<td align="left">xxxb</td>
<td align="left">R</td>
<td align="left">[49:47]</td>
<td>2 &#8658; 256</td>
</tr>
<tr>
<td align="left">erase single<br>block enable</td>
<td align="left">ERASE_BLK_EN</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R</td>
<td align="left">[46:46]</td>
<td>1</td>
</tr>
<tr>
<td align="left">erase sector<br>size</td>
<td align="left">SECTOR_SIZE</td>
<td align="left">7</td>
<td align="left">xxxxxxxb</td>
<td align="left">R</td>
<td align="left">[45:39]</td>
<td>0x7F &#8658; 256</td>
</tr>
<tr>
<td align="left">write protect<br>group size</td>
<td align="left">WP_GRP_SIZE</td>
<td align="left">7</td>
<td align="left">xxxxxxxb</td>
<td align="left">R</td>
<td align="left">[38:32]</td>
<td>0x0F &#8658; 16</td>
</tr>
<tr>
<td align="left">write protect<br>group enable</td>
<td align="left">WP_GRP_ENABLE</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R</td>
<td align="left">[31:31]</td>
<td>1</td>
</tr>
<tr>
<td align="left">reserved (Do not use)</td>
<td align="left">&ndash;</td>
<td align="left">2</td>
<td align="left">00b</td>
<td align="left">R</td>
<td align="left">[30:29]</td>
<td>0</td>
</tr>
<tr>
<td align="left">write speed factor</td>
<td align="left">R2W_FACTOR</td>
<td align="left">3</td>
<td align="left">xxxb</td>
<td align="left">R</td>
<td align="left">[28:26]</td>
<td>3 &#8658; x8</td>
</tr>
<tr>
<td align="left">max. write data<br>block length</td>
<td align="left">WRITE_BL_LEN</td>
<td align="left">4</td>
<td align="left">xxxxb</td>
<td align="left">R</td>
<td align="left">[25:22]</td>
<td>9 &#8658; 512</td>
</tr>
<tr>
<td align="left">partial blocks<br>for write allowed</td>
<td align="left">WRITE_BL_PARTIAL</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R</td>
<td align="left">[21:21]</td>
<td>0</td>
</tr>
<tr>
<td align="left">reserved</td>
<td align="left">&ndash;</td>
<td align="left">5</td>
<td align="left">00000b</td>
<td align="left">R</td>
<td align="left">[20:16]</td>
<td>0</td>
</tr>
<tr>
<td align="left">File format group</td>
<td align="left">FILE_FORMAT_GRP</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R/W</td>
<td align="left">[15:15]</td>
<td>0</td>
</tr>
<tr>
<td align="left">copy flag</td>
<td align="left">COPY</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R/W</td>
<td align="left">[14:14]</td>
<td>0</td>
</tr>
<tr>
<td align="left">permanent write<br>protection</td>
<td align="left">PERM_WRITE_PROTECT</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R/W</td>
<td align="left">[13:13]</td>
<td>0</td>
</tr>
<tr>
<td align="left">temporary write<br>protection</td>
<td align="left">TMP_WRITE_PROTECT</td>
<td align="left">1</td>
<td align="left">xb</td>
<td align="left">R/W</td>
<td align="left">[12:12]</td>
<td>0</td>
</tr>
<tr>
<td align="left">File format</td>
<td align="left">FILE_FORMAT</td>
<td align="left">2</td>
<td align="left">xxb</td>
<td align="left">R/W</td>
<td align="left">[11:10]</td>
<td>0</td>
</tr>
<tr>
<td align="left">reserved</td>
<td align="left">&ndash;</td>
<td align="left">2</td>
<td align="left">00b</td>
<td align="left">R/W</td>
<td align="left">[9:8]</td>
<td>0</td>
</tr>
<tr>
<td align="left">CRC</td>
<td align="left">CRC</td>
<td align="left">7</td>
<td align="left">xxxxxxxb</td>
<td align="left">R/W</td>
<td align="left">[7:1]</td>
<td>0x22</td>
</tr>
<tr>
<td align="left">not used, always&lsquo;1&rsquo;</td>
<td align="left">&ndash;</td>
<td align="left">1</td>
<td align="left">1b</td>
<td align="left">&ndash;</td>
<td align="left">[0:0]</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Разберу чуть подробнее:</p>
<p>Поле CSD_STRUCTURE содержит 0, следовательно, структура имеет версию 1.0 (что и ожидается от SD).</p>
<p>Поле TAAC содержит 0x5E, что в соответствии со спецификацией делится на две части: 6, соответствующую 1 мс, и 0xB, соответствующую 5,0. Итого получаем асинхронную часть времени доступа к данным. В режиме SPI обращать внимание на такие мелочи, право, не стоит. Это же относится к параметрам NSAC (равному 0) и TRAN_SPEED (равному 32, то есть, 2,5 &middot; 10 Мбит/с или 25 МГц &mdash; норма для SD).</p>
<p>Поле CCC содержит 010101110101b, что несколько не соответствует заявленной в спецификации маске 01x110110101b, но это поле тоже можно игнорировать в данном случае. Здесь указано, какое подмножество команд флэшка способна воспринять. А в режиме SPI множество команд в принципе ограничено, да и нужно-то не очень много.</p>
<p>Поле READ_BL_LEN содержит 9 и означает размер читаемого блока данных 2<sup>9</sup> = 512. В спецификации есть примечание, что размер записываемого блока данных для карт SD всегда равен размеру читаемого блока.</p>
<p>Поле READ_BL_PARTIAL равно 1, что ожидаемо для карты SD и радует: можно читать блоки любого размера до 512, вплоть до 1 байта. Жаль, что WRITE_BLK_MISALIGN и READ_BLK_MISALIG равны 0, то есть, читать и писать можно только в пределах блока, через границу не перейти. Впрочем, это тоже было ожидаемо.</p>
<p>Поле DSR_IMP содержит 0, то есть, регистр DSR отсутствует, что, впрочем, для режима SPI тоже неважно. Бывает какой-то настраиваемый задающий каскад для выходных линий, позволяющий оптимизировать обмен. Но подробности о нем в упрощенной спецификации даже не стали печатать.</p>
<p>Поле C_SIZE содержит пользовательскую емкость карты, за вычетом защищенной области. Там записано 0xEEB, надо прибавить 1 и умножить на множитель из поля C_SIZE_MULT, получим размер в блоках, значит, надо еще домножить на размер блока, итого получим 500 695 040 байтов, или 488 960 килобайтов, или 477,5 метра.</p>
<p>Минимальные значения токов VDD_R_CURR_MIN и VDD_R_CURR_MAX равны 3, то есть, 10 мА. Максимальные значения токов VDD_W_CURR_MIN и VDD_W_CURR_MAX &mdash; тоже 3, но это уже 25 мА. Но важно ли это в данном случае?</p>
<p>Поле C_SIZE_MULT содержит 2, значит множитель равен 2<sup>C_SIZE_MULT + 2</sup> = 256, это использовалось выше при вычислении пользовательской емкости флэшки.</p>
<p>Поле ERASE_BLK_EN содержит 1, что разрешает стирать данные блоками по 512 байтов. То есть, меньше 512 байтов стереть нельзя. Но если бы в этом поле был 0, то минимальный стираемый участок был бы (SECTOR_SIZE &middot; 512) байтов.</p>
<p>Поле SECTOR_SIZE содержит число записываемых блоков (WRITE_BL_LEN = 512) в стираемом секторе. К записанному здесь 0x7F нужно еще прибавить 1, получим 128 блоков, или 65536 байтов, или 64 кбайта. Почему в этом поле такое значение, если ERASE_BLK_EN = 1? Не знаю.</p>
<p>Поле WP_GRP_SIZE содержит размер группы, защищаемой от записи, измеряемый в стираемых секторах. 0x0F + 1 = 16 блоков, по 64 кбайта получается метр.</p>
<p>Поле WP_GRP_ENABLE содержит 1 и разрешает групповую защиту от записи.</p>
<p>Поле R2W_FACTOR определяет типичное время программирования блока в виде множителя к времени чтения. 3 означает восьмикратное время.</p>
<p>Поле WRITE_BL_LEN аналогично полю READ_BL_LEN и содержит максимальную длину блока данных для записи, 512 байтов. Для SD-карт эти два поля должны быть равны. Они и равны, собственно.</p>
<p>Поле WRITE_BL_PARTIAL указывает, можно ли писать блоками меньшего размера, чем указано в предыдущем поле. Жаль, но значение равно 0. Не очень удобно.</p>
<p>Дальше пошли поля, предназначенные как для чтения, так и для записи, заполненные нулями. Причем, чтобы записать в эти поля, нужно сформировать данные для регистра CSD таким образом, чтобы в разрядах, соответствующих полям только для чтения находились разряды в том же состоянии, что и в регистре флэшки, иначе запись выполнена не будет. То есть, надо считать CSD, изменить нужные разряды и записать обратно.</p>
<ul>
<li>FILE_FORMAT_GRP показывает выбранную группу форматов файлов. 0 означает один из четырех возможных файловых форматов, 1 зарезервирована.</li>
<li>COPY показывает, является ли содержимое карты оригиналом или копией.</li>
<li>PERM_WRITE_PROTECT &mdash; постоянная защита от записи всей карты от перезаписи или стирания (все команды записи и стирания навсегда отменяются). Программная защита от перезаписи.</li>
<li>TMP_WRITE_PROTECT &mdash; временная защита от записи всей карты от перезаписи или стирания (все команды записи и стирания временно отменяются). Программная защита от перезаписи.</li>
<li>FILE_FORMAT &mdash; файловая система как на жестком диске с таблицей разделов.</li>
</ul>
<p>Поле CRC содержит контрольную сумму CRC7, которую при желании можно пересчитать и сверить. Записано 0x22. Поверю на слово. Вместе с последним разрядом регистра, который должен всегда быть установленным в 1, байт с контрольной суммой в итоге содержит 0x45.</p>
<p>Перед продолжением экспериментов с чтением-стиранием-записью стоит упомянуть, что на используемой и описываемой здесь SD-карточке используется адресация байтовая, в то время как на SDHC и SDXC &mdash; посекторная, блоками по 512 байтов. В моем случае надо указывать адрес в байтах, даже если операция не поддерживает побайтовой адресации. Например, стирание выполняется секторами, а указывать надо любой байт внутри стираемого сектора.</p>
<h2 id="_6">Чтение данных</h2>
<h3 id="_7">Маленько</h3>
<p>Прочитать регистры получилось. Это хорошо само по себе, плюс получена дополнительная информация о карте насчет поблочного чтения-стирания-записи. Теперь надо попробовать читать данные. Где-то там, в самом начале, должна быть <abbr title="Master Boot Record, главная загрузочная запись">MBR</abbr> с таблицей разделов, а где-то подальше от начала &mdash; <abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr>. Закрываю вызов <code>SdReadDataBlock()</code>, а вместо него вставляю команду чтения данных с адреса 0, 128 байтов в буферный массив <code>data</code> (который можно будет прочитать в виде файла <code>DATA.BIN</code>):</p>
<div class="highlight"><pre><span></span>    <span class="n">SdReadDataBlock</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</pre></div>


<p>В результате читаю следующее:</p>
<div class="highlight"><pre><span></span>00000000: fa 33 c0 8e d0 bc 00 7c 8b f4 50 07 50 1f fb fc  .3.....|..P.P...
00000010: bf 00 06 b9 00 01 f2 a5 ea 1d 06 00 00 be be 07  ................
00000020: b3 04 80 3c 80 74 0e 80 3c 00 75 1c 83 c6 10 fe  ...&lt;.t..&lt;.u.....
00000030: cb 75 ef cd 18 8b 14 8b 4c 02 8b ee 83 c6 10 fe  .u......L.......
00000040: cb 74 1a 80 3c 00 74 f4 be 8b 06 ac 3c 00 74 0b  .t..&lt;.t.....&lt;.t.
00000050: 56 bb 07 00 b4 0e cd 10 5e eb f0 eb fe bf 05 00  V.......^.......
00000060: bb 00 7c b8 01 02 57 cd 13 5f 73 0c 33 c0 cd 13  ..|...W.._s.3...
00000070: 4f 75 ed be a3 06 eb d3 be c2 06 bf fe 7d 81 3d  Ou...........}.=
</pre></div>


<p>Ну, допустим. Меняю начальный адрес с 0 на 2. При чтении вижу в массиве <code>data</code> результат инициализации, то есть, чтения не было. Чтобы выяснить, где произошел сбой, добавляю в функцию чтения данных вывод на светодиоды некоторого контрольного значения:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">SdReadDataBlock</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_READ_SINGLE_BLOCK</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sdResponce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">SdWaitForDataToken</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">data_device</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">data_device</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">data_device</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Дополнительно переключаю <code>mode_out</code> на 1, чтобы по умолчанию на светодиоды выводилась переменная <code>data_device</code>, закрываю строчку <code>data_device = cnt_bt</code> а при анализе <code>mode_out</code> в <code>case 1</code> вместо <code>PORTD = canDo;</code> пишу <code>PORTD = cnt_bt;</code>.</p>
<p>Оказывается, что <code>sdResponce</code> не равен нулю, то есть, в команде ошибка. Ошибка, на самом деле, очевидная: размер блока по умолчанию равен 512 байтов, следовательно, при попытке чтения такого блока с адреса 2 будет переход через границу блока, а граница на замке, нельзя так делать.</p>
<p>Ввожу определение кода команды 16, установки размера блока:</p>
<div class="highlight"><pre><span></span>    <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_SET_BLOCK_LEN</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
</pre></div>


<p>И перед командой чтения добавляю вызов команды, задающей размер блока в соответствии с размером буферного массива:</p>
<div class="highlight"><pre><span></span>    <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_SET_BLOCK_LEN</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
</pre></div>


<p>Теперь все читается. Вот первые 16 байтов массива:</p>
<div class="highlight"><pre><span></span>00000000: c0 8e d0 bc 00 7c 8b f4 50 07 50 1f fb fc bf 00  .....|..P.P.....
</pre></div>


<p>Видно, что он начинается с третьего по счету байта, то есть, с адреса 2. Меняю адрес на 128, читаю еще блок:</p>
<div class="highlight"><pre><span></span>00000000: 55 aa 75 c7 8b f5 ea 00 7c 00 00 49 6e 76 61 6c  U.u.....|..Inval
00000010: 69 64 20 70 61 72 74 69 74 69 6f 6e 20 74 61 62  id partition tab
00000020: 6c 65 00 45 72 72 6f 72 20 6c 6f 61 64 69 6e 67  le.Error loading
00000030: 20 6f 70 65 72 61 74 69 6e 67 20 73 79 73 74 65   operating syste
00000040: 6d 00 4d 69 73 73 69 6e 67 20 6f 70 65 72 61 74  m.Missing operat
00000050: 69 6e 67 20 73 79 73 74 65 6d 00 00 00 00 00 00  ing system......
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Здесь уже очевидно (по текстовым сообщениям), что имеем дело с <abbr title="Master Boot Record, главная загрузочная запись">MBR</abbr>.</p>
<h3 id="_8">Как можно больше</h3>
<p>Однако читать данные блоками по 128 байтов неинтересно и утомительно. Надо попробовать читать в виде файла такого размера, какой позволяет объем имитируемой &laquo;флэшки&raquo;.</p>
<p>Для этого надо внести некоторые изменения. Прежде всего команду установки размера блока внесу первой строчкой в функцию <code>SdReadDataBlock()</code>. Пусть одним параметром задается и размер читаемого блока, и количество читаемых данных. Это не совсем оптимально, потому что при последовательном чтении множества блоков размер блока можно бы выставить один раз в начале. Но я не буду читать подряд огромное количество, а при таком подходе не надо следить за соответствием размера блока и размера данных. Правда, надо следить за соответствием адреса начала чтения размеру блока &mdash; чтобы не возникла ситуация перехода границы.</p>
<p>Затем следует добавить объявление функции чтения блока в файле <code>common.h</code>, чтобы ее можно было вызвать в <code>Lib/fake_fs.c</code>:</p>
<div class="highlight"><pre><span></span>        <span class="k">extern</span> <span class="kt">bool</span> <span class="nf">SdReadDataBlock</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">);</span>
</pre></div>


<p>Дальше будут дополнения в модуле <code>fake_fs</code>. Определяю мегабайтный размер файла, читаемого с флэшки и объявляю функцию чтения этого файла:</p>
<div class="highlight"><pre><span></span><span class="cp">#define SIZE_OF_SD      0x100000</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readSD</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>


<p>В конец файловой таблицы добавляю новый файл:</p>
<div class="highlight"><pre><span></span>    <span class="p">{</span><span class="s">&quot;SD      BIN&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_SD</span><span class="p">,</span> <span class="n">readSD</span><span class="p">},</span>
</pre></div>


<p>И где-нибудь в конце определяю функцию чтения:</p>
<div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readSD</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SdReadDataBlock</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">data_buf</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Делаю в простом варианте, не заморачиваясь с проверкой некратного размера читаемого куска или выхода за границы. С 16-байтовыми кусками, читаемыми по USB, такие казусы не должны возникнуть.</p>
<p>Очень несложные добавки приводят к возможности считывания файла <code>SD.BIN</code>, в котором мегабайт данных от начала SD-карты. Если в таблице файлов закрыть строчку, соответствующую файлу <code>TESTFILE.TXT</code> (он весит метр), то размер <code>SD.BIN</code> можно увеличить до трех метров, при желании даже с гаком. Имитируемая &laquo;флэшка&raquo; имеет размер 4 метра, поэтому больше не получится, операционная система занервничает, выдаст ошибки.</p>
<p>Компилирую, прошиваю, перезапускаю питание. На <abbr title="персональный компьютер">ПК</abbr> открывается окно &laquo;флэшки&raquo;, можно открыть вновь появившийся файл <code>SD.BIN</code> в HEX-редакторе. Весь приводить не буду, но:</p>
<div class="highlight"><pre><span></span>00000000: fa 33 c0 8e d0 bc 00 7c 8b f4 50 07 50 1f fb fc  .3.....|..P.P...
00000010: bf 00 06 b9 00 01 f2 a5 ea 1d 06 00 00 be be 07  ................
00000020: b3 04 80 3c 80 74 0e 80 3c 00 75 1c 83 c6 10 fe  ...&lt;.t..&lt;.u.....
00000030: cb 75 ef cd 18 8b 14 8b 4c 02 8b ee 83 c6 10 fe  .u......L.......
00000040: cb 74 1a 80 3c 00 74 f4 be 8b 06 ac 3c 00 74 0b  .t..&lt;.t.....&lt;.t.
00000050: 56 bb 07 00 b4 0e cd 10 5e eb f0 eb fe bf 05 00  V.......^.......
00000060: bb 00 7c b8 01 02 57 cd 13 5f 73 0c 33 c0 cd 13  ..|...W.._s.3...
00000070: 4f 75 ed be a3 06 eb d3 be c2 06 bf fe 7d 81 3d  Ou...........}.=
00000080: 55 aa 75 c7 8b f5 ea 00 7c 00 00 49 6e 76 61 6c  U.u.....|..Inval
00000090: 69 64 20 70 61 72 74 69 74 69 6f 6e 20 74 61 62  id partition tab
000000a0: 6c 65 00 45 72 72 6f 72 20 6c 6f 61 64 69 6e 67  le.Error loading
000000b0: 20 6f 70 65 72 61 74 69 6e 67 20 73 79 73 74 65   operating syste
000000c0: 6d 00 4d 69 73 73 69 6e 67 20 6f 70 65 72 61 74  m.Missing operat
000000d0: 69 6e 67 20 73 79 73 74 65 6d 00 00 00 00 00 00  ing system......
000000e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000110: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000130: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000140: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000150: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000160: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03  ................
000001c0: 33 00 06 02 e2 ca ef 00 00 00 11 eb 0e 00 00 00  3...............
000001d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa  ..............U.
</pre></div>


<p>Первый сектор (512 байтов) заканчивается на <code>55 aa</code>, как и должна заканчиваться <abbr title="Master Boot Record, главная загрузочная запись">MBR</abbr>. Первые два куска по 128 байтов совпадают с тем, что было прочитано через буферный массив <code>data</code>. По смещению <code>0x1BE</code> начинается запись первого раздела. По смещению <code>0x08</code> в записи раздела, то есть, по смещению <code>0x1C6</code> в <abbr title="Master Boot Record, главная загрузочная запись">MBR</abbr> находится расстояние до первого сектора раздела в секторах. Видим там <code>0xEF</code>, что означает адрес <code>0x1DE00</code>. Посмотрим, что лежит по этому адресу, хотя бы первые 128 байтов:</p>
<div class="highlight"><pre><span></span>0001de00: eb 3e 90 50 77 72 53 68 6f 74 20 00 02 20 01 00  .&gt;.PwrShot .. ..
0001de10: 02 00 02 00 00 f8 78 00 3f 00 10 00 ef 00 00 00  ......x.?.......
0001de20: 11 eb 0e 00 80 00 29 35 62 24 00 43 41 4e 4f 4e  ......)5b$.CANON
0001de30: 5f 44 43 20 20 20 46 41 54 31 36 20 20 20 33 ff  _DC   FAT16   3.
0001de40: 8e df be 00 7c 8d 9c e4 01 8e 47 02 fc b9 00 02  ....|.....G.....
0001de50: f3 a4 c7 07 58 00 ff 2f 8c c8 fa 8e d0 bc 00 06  ....X../........
0001de60: fb 8b ec 83 ec 16 c5 36 78 00 89 76 f6 8c 5e f8  .......6x..v..^.
0001de70: 8d 7e ea b9 0b 00 57 f3 a4 5f 8e d9 be 78 00 89  .~....W.._...x..
</pre></div>


<p>Первые три байта: инструкция перехода <code>0xEB</code>, смещение перехода <code>0x3E</code> и инструкция NOP <code>0x90</code>. Правда, смещение приходится в зарезервированную область, если рассматривать версию <abbr title="Partition Boot Record, загрузочная запись раздела">PBR</abbr>, которую я использовал для имитации флэшки, но это не очень важно.</p>
<p>Далее 8 байтов OEM-названия: &laquo;PwrShot&raquo;, что просто замечательно, так как флэшка использовалась в фотоаппарате Canon PowerShot, в котором и форматировалась.</p>
<p>Дальше 2 байта содержат количество байтов в секторе, их 512. Ну и так далее. В конце сектора последние два байта <code>55 aa</code>, а дальше начинается FAT:</p>
<div class="highlight"><pre><span></span>0001dff0: 00 49 42 4d 42 49 4f 20 20 43 4f 4d 00 80 55 aa  .IBMBIO  COM..U.
0001e000: f8 ff ff ff ff ff ff ff 05 00 06 00 07 00 08 00  ................
0001e010: 09 00 0a 00 0b 00 0c 00 0d 00 0e 00 0f 00 10 00  ................
0001e020: 11 00 12 00 13 00 14 00 15 00 16 00 17 00 18 00  ................
0001e030: 19 00 1a 00 1b 00 1c 00 1d 00 1e 00 1f 00 20 00  .............. .
0001e040: 21 00 22 00 23 00 24 00 25 00 26 00 27 00 28 00  !.&quot;.#.$.%.&amp;.&#39;.(.
0001e050: 29 00 2a 00 2b 00 2c 00 2d 00 2e 00 2f 00 30 00  ).*.+.,.-.../.0.
0001e060: 31 00 32 00 33 00 34 00 35 00 36 00 37 00 38 00  1.2.3.4.5.6.7.8.
0001e070: 39 00 3a 00 3b 00 3c 00 3d 00 3e 00 3f 00 40 00  9.:.;.&lt;.=.&gt;.?.@.
0001e080: 41 00 42 00 43 00 44 00 45 00 46 00 47 00 48 00  A.B.C.D.E.F.G.H.
0001e090: 49 00 4a 00 4b 00 4c 00 4d 00 4e 00 4f 00 50 00  I.J.K.L.M.N.O.P.
0001e0a0: 51 00 52 00 53 00 54 00 55 00 56 00 57 00 58 00  Q.R.S.T.U.V.W.X.
0001e0b0: 59 00 5a 00 5b 00 5c 00 5d 00 5e 00 5f 00 60 00  Y.Z.[.\.].^._.`.
0001e0c0: 61 00 62 00 63 00 64 00 65 00 66 00 67 00 68 00  a.b.c.d.e.f.g.h.
0001e0d0: 69 00 6a 00 6b 00 6c 00 6d 00 6e 00 6f 00 70 00  i.j.k.l.m.n.o.p.
0001e0e0: 71 00 72 00 73 00 74 00 75 00 76 00 77 00 78 00  q.r.s.t.u.v.w.x.
0001e0f0: 79 00 7a 00 7b 00 7c 00 7d 00 7e 00 7f 00 80 00  y.z.{.|.}.~.....
0001e100: 81 00 82 00 83 00 84 00 85 00 86 00 87 00 88 00  ................
0001e110: 89 00 8a 00 8b 00 8c 00 8d 00 8e 00 8f 00 90 00  ................
0001e120: 91 00 92 00 93 00 ff ff 95 00 96 00 97 00 98 00  ................
</pre></div>


<p>Видно, что сразу начинается описание длинного нефрагментированного файла, кластеры которого следуют подряд. В кластере 147 (0x93) находится конец этого файла, обозначенный в таблице с помощью <code>ff ff</code>, дальше начинается следующий файл.</p>
<p>По смещению <code>0x2d000</code> лежит резервная FAT:</p>
<div class="highlight"><pre><span></span>0002d000: f8 ff ff ff ff ff ff ff 05 00 06 00 07 00 08 00  ................
0002d010: 09 00 0a 00 0b 00 0c 00 0d 00 0e 00 0f 00 10 00  ................
...
</pre></div>


<p>Ниже что-то очень похожее на корневой каталог:</p>
<div class="highlight"><pre><span></span>00040000: 2e 20 20 20 20 20 20 20 20 20 20 10 f4 00 d5 93  .          .....
00040010: f5 48 f5 48 00 00 d5 93 f5 48 02 00 00 00 00 00  .H.H.....H......
00040020: 2e 2e 20 20 20 20 20 20 20 20 20 10 f4 00 d5 93  ..         .....
00040030: f5 48 f5 48 00 00 d5 93 f5 48 00 00 00 00 00 00  .H.H.....H......
00040040: 31 30 31 43 41 4e 4f 4e 20 20 20 10 00 00 d5 93  101CANON   .....
00040050: f5 48 02 49 00 00 d5 93 f5 48 03 00 00 00 00 00  .H.I.....H......
00040060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00040070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Еще ниже что-то вроде каталога со списком файлов:</p>
<div class="highlight"><pre><span></span>00044000: 2e 20 20 20 20 20 20 20 20 20 20 10 0c 00 d5 93  .          .....
00044010: f5 48 f5 48 00 00 d5 93 f5 48 03 00 00 00 00 00  .H.H.....H......
00044020: 2e 2e 20 20 20 20 20 20 20 20 20 10 0c 00 d5 93  ..         .....
00044030: f5 48 f5 48 00 00 d5 93 f5 48 02 00 00 00 00 00  .H.H.....H......
00044040: 49 4d 47 5f 32 30 37 38 4a 50 47 20 00 00 d5 93  IMG_2078JPG ....
00044050: f5 48 02 49 00 00 d5 93 f5 48 04 00 e0 e2 23 00  .H.I.....H....#.
00044060: 49 4d 47 5f 32 30 37 39 4a 50 47 20 00 00 dd 93  IMG_2079JPG ....
00044070: f5 48 02 49 00 00 dd 93 f5 48 94 00 18 56 28 00  .H.I.....H...V(.
</pre></div>


<p>И еще ниже что-то, сильно смахивающее на фотографию:</p>
<div class="highlight"><pre><span></span>00048000: ff d8 ff e1 25 fe 45 78 69 66 00 00 49 49 2a 00  ....%.Exif..II*.
00048010: 08 00 00 00 09 00 0f 01 02 00 06 00 00 00 7a 00  ..............z.
00048020: 00 00 10 01 02 00 15 00 00 00 80 00 00 00 12 01  ................
00048030: 03 00 01 00 00 00 01 00 00 00 1a 01 05 00 01 00  ................
00048040: 00 00 a0 00 00 00 1b 01 05 00 01 00 00 00 a8 00  ................
00048050: 00 00 28 01 03 00 01 00 00 00 02 00 00 00 32 01  ..(...........2.
00048060: 02 00 14 00 00 00 b0 00 00 00 13 02 03 00 01 00  ................
00048070: 00 00 01 00 00 00 69 87 04 00 01 00 00 00 c4 00  ......i.........
00048080: 00 00 56 0b 00 00 43 61 6e 6f 6e 00 43 61 6e 6f  ..V...Canon.Cano
00048090: 6e 20 50 6f 77 65 72 53 68 6f 74 20 41 35 33 30  n PowerShot A530
000480a0: 00 00 00 00 00 00 00 00 00 00 00 00 b4 00 00 00  ................
000480b0: 01 00 00 00 b4 00 00 00 01 00 00 00 32 30 31 36  ............2016
000480c0: 3a 30 37 3a 32 31 20 31 38 3a 33 30 3a 34 33 00  :07:21 18:30:43.
000480d0: 1f 00 9a 82 05 00 01 00 00 00 3e 02 00 00 9d 82  ..........&gt;.....
000480e0: 05 00 01 00 00 00 46 02 00 00 00 90 07 00 04 00  ......F.........
000480f0: 00 00 30 32 32 30 03 90 02 00 14 00 00 00 4e 02  ..0220........N.
...
00048470: 49 4d 47 3a 50 6f 77 65 72 53 68 6f 74 20 41 35  IMG:PowerShot A5
00048480: 33 30 20 4a 50 45 47 00 00 00 00 00 00 00 00 00  30 JPEG.........
00048490: 46 69 72 6d 77 61 72 65 20 56 65 72 73 69 6f 6e  Firmware Version
000484a0: 20 31 2e 30 30 00 00 00 00 00 00 00 00 00 00 00   1.00...........
000484b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000484c0: 00 00 00 00 00 00 00 00 01 00 00 00 02 00 00 00  ................
000484d0: 00 00 00 00 78 00 00 00 e7 ff ff ff e7 ff ff ff  ....x...........
000484e0: e9 ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00  ................
...
</pre></div>


<p>В общем, чтение флэшки вышло успешным и убедительным.</p>
<h2 id="_9">Стирание</h2>
<p>С флэшкой можно провернуть такую операцию, как стирание. Честно говоря, операция не очень-то полезная. Во-первых, при каждой операции записи контроллер флэшки все равно предварительно сотрет записываемый сектор. Во-вторых, в подобных флэшках после стирания ячейки должны содержать <code>0xFF</code>, а не нули, то есть, происходит не только стирание, но и запись нулей. Но я попробую. Потому что хочется.</p>
<p>Для стирания потребуются команды 32, 33 и 38: указания адреса начала области стирания, адреса окончания области и собственно стирания. Добавляю их определения туда же, где остальные определения команд:</p>
<div class="highlight"><pre><span></span><span class="cp">#define MMC_ERASE_WR_BLK_START  MMC_COMMANDS_BASE + 32        </span><span class="c1">// CMD32</span>
<span class="cp">#define MMC_ERASE_WR_BLK_END    MMC_COMMANDS_BASE + 33        </span><span class="c1">// CMD33</span>
<span class="cp">#define MMC_ERASE               MMC_COMMANDS_BASE + 38        </span><span class="c1">// CMD38</span>
</pre></div>


<p>Затем в файле <code>MassStorage.c</code> закрываю вызов команды чтения данных в буференый массив <code>SdReadDataBlock(0, 128, data);</code>, она уже не нужна, а вместо нее ставлю три команды подряд:</p>
<div class="highlight"><pre><span></span>    <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_ERASE_WR_BLK_START</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
    <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_ERASE_WR_BLK_END</span><span class="p">,</span> <span class="mh">0x800</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
    <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_ERASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
</pre></div>


<p>В результате выполнения этой последовательности окажутся заполнены нулями сектора начиная с того, в котортом есть адрес 0, заканчивая тем, в котором есть адрес 0x800. С тем же успехом можно было задать адреса, скажем, 9 и 0x803. Причем, эти команды должны идти строго втроем, именно в этой последовательности. Нельзя однажды задать адрес начала стирания, а потом его подразумевать: если после него не будет остальных команд, он сбросится.</p>
<p>В общем, ничего примечательного. Данные действительно стерлись, действительно в указанной области. Эксперименты с разными адресами тоже не показали ничего такого, о чем стоило бы упомянуть.</p>
<h2 id="_10">Проба записи</h2>
<p>Закрываю команды стирания. Попробовал &mdash; и хватит. Далее в имеющуюся заготовку функции записи добавлю <code>data_device = 1;</code> перед <code>return true</code> и <code>data_device = 2</code> перед <code>return false</code>, опять же для контроля успешности выполнения.</p>
<p>Записывать планирую для начала из буферного массива <code>data</code>, поэтому изменяю его инициализатор на счетчик, начинающийся с пятерки, для наглядности:</p>
<div class="highlight"><pre><span></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<p>И после закрытых команд стирания вызываю запись:</p>
<div class="highlight"><pre><span></span>    <span class="n">SdWriteDataBlock</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</pre></div>


<p>В результате можно с имитируемой &laquo;флэшки&raquo; прочитать файл <code>DATA.BIN</code> следующего содержания:</p>
<div class="highlight"><pre><span></span>00000000: 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14  ................
00000010: 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24  ........... !&quot;#$
00000020: 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34  %&amp;&#39;()*+,-./01234
00000030: 35 36 37 38 39 3a 3b 3c 3d 3e 3f 40 41 42 43 44  56789:;&lt;=&gt;?@ABCD
00000040: 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50 51 52 53 54  EFGHIJKLMNOPQRST
00000050: 55 56 57 58 59 5a 5b 5c 5d 5e 5f 60 61 62 63 64  UVWXYZ[\]^_`abcd
00000060: 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74  efghijklmnopqrst
00000070: 75 76 77 78 79 7a 7b 7c 7d 7e 7f 80 81 82 83 84  uvwxyz{|}~......
</pre></div>


<p>Дальнейшие эксперименты с заданием различных адресов показали забавный результат. Если адрес начала записи указать не 0, а, к примеру, 3, то операция записи выполнена не будет. Похоже, по той же причине, которая вызвала сбой операции чтения &mdash; переход границы блока. Если же предварительно задать длину блока, как при операции чтения, то запись выполняется, но не с указанного адреса, а все равно с начала блока, внутри которого находится указанный адрес.</p>
<p>В общем, процедура записи похожа на процедуру чтения, также требует задания размера блока, если он меньше 512 байтов. Но чтобы записать весь сектор, желательно иметь буфер размером в сектор. Кусочками не получится, запись следующего куска мало того, что начнется опять с начала, так еще и сотрет весь сектор заново.</p>
<h2 id="_11">Запись данных с <abbr title="персональный компьютер">ПК</abbr></h2>
<h3 id="_12">Маленько и просто</h3>
<p>Попробую организовать запись на SD-флэшку через имитируемую &laquo;флэшку&raquo;, для начала хотя бы маленький кусочек. Сперва перенесу вызов команды установки размера блока в функцию записи, так же, как это было сделано с функцией чтения. Ну, и закрою функцию записи в <code>MassStorage</code>.</p>
<p>Определю функцию записи в файле <code>common.h</code>:</p>
<div class="highlight"><pre><span></span>        <span class="k">extern</span> <span class="kt">bool</span> <span class="nf">SdWriteDataBlock</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">);</span>
</pre></div>


<p>А в файле <code>fake_fs.c</code> надо написать совсем немного. Там уже организована возможность записи &laquo;в файл&raquo;. Необходимо предварительно открыть для чтения файл <code>TO_FILE.TXT</code> (то есть, прочитать его любым способом), после чего любые данные, отправляемые устройству на запись, будут направляться в буферный массив, пока помещаются.</p>
<p>Я всего лишь добавлю запись накопленных в массиве <code>data</code> данных на флэшку в тот момент, когда буфер наполнен. Для этого в функции <code>process_data()</code> при анализе <code>writeType</code> в <code>case ToFile</code> внутри фигурных скобок перед <code>break</code> надо добавить</p>
<div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ind</span><span class="o">++</span><span class="p">;</span>
            <span class="n">SdWriteDataBlock</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
</pre></div>


<p>Теперь после перекомпиляции и перезапуска питания открываю &laquo;блокнотом&raquo; файл <code>TO_FILE.TXT</code>, после чего забрасываю мышью в окно &laquo;флэшки&raquo; предварительно подготовленный для этой цели текстовый файл с классической &laquo;рыбой&raquo;. Для чистоты эксперимента на время выключаю питание устройства, потом подключаю снова, читаю <code>SD.BIN</code> и в первых 128 байтах вижу следующее:</p>
<div class="highlight"><pre><span></span>00000000: 4c 6f 72 65 6d 20 69 70 73 75 6d 20 64 6f 6c 6f  Lorem ipsum dolo
00000010: 72 20 73 69 74 20 61 6d 65 74 2c 20 63 6f 6e 73  r sit amet, cons
00000020: 65 63 74 65 74 75 72 20 61 64 69 70 69 73 63 69  ectetur adipisci
00000030: 6e 67 20 65 6c 69 74 2c 20 73 65 64 20 64 6f 20  ng elit, sed do 
00000040: 65 69 75 73 6d 6f 64 20 74 65 6d 70 6f 72 20 69  eiusmod tempor i
00000050: 6e 63 69 64 69 64 75 6e 74 20 75 74 20 6c 61 62  ncididunt ut lab
00000060: 6f 72 65 20 65 74 20 64 6f 6c 6f 72 65 20 6d 61  ore et dolore ma
00000070: 67 6e 61 20 61 6c 69 71 75 61 2e 20 55 74 20 65  gna aliqua. Ut e
00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</pre></div>


<p>Запись получилась.</p>
<h3 id="_13">Побольше и посложнее</h3>
<p>К сожалению, для такого способа записи необходим буферный массив с размером не меньше, чем у сектора, то есть, 512 байтов. А у AT90USB162 всего оперативки 512 байтов. Надо придумывать нечто иное, без буфера.</p>
<p>Сперва надо, как в функции записи, выдать команду отправки блока данных, получив ответ, выдать токен данных, а потом начать пересылать данные, поступающие по USB. Примерно так, как это было сделано для отправки данных из файла <abbr title="персональный компьютер">ПК</abbr> на экран. После того, как будет выдано максимально возможное число байтов &mdash; 512 &mdash; надо выдать некоторый заменитель контрольной суммы, прочитать отклик на данные от карты (должен быть ненулевым), и дождаться окончания состояния &laquo;busy&raquo;, пока контроллер SD-карты записывает полученный блок в свою флэш-память. При желании записать более одного сектора следует все вышеописанное повторить.</p>
<p>В общем, многое из используемого в функции записи нужно сделать видимым для модуля <code>fake_fs</code>. Поэтому переношу в файл <code>common.h</code> определения команд и токена из <code>MassStorage.c</code>, а также объявление типа для вариантов отклика, кроме того объявляю там же переменную и три функции:</p>
<div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">ResponceType</span> <span class="p">{</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">R7</span><span class="p">};</span>

<span class="p">...</span>

        <span class="k">extern</span> <span class="kt">uint8_t</span> <span class="n">sdResponce</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
        <span class="k">extern</span> <span class="kt">void</span> <span class="nf">SdOutByte</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">data8</span><span class="p">);</span>
        <span class="k">extern</span> <span class="kt">uint8_t</span> <span class="nf">SdInByte</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
        <span class="k">extern</span> <span class="kt">void</span> <span class="nf">SdSendCommand</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">Index</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">Argument</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">Crc</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ResponceType</span> <span class="n">responceType</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">Responce</span><span class="p">);</span>
</pre></div>


<p>В файле <code>fake_fs.c</code> вношу изменения в функцию <code>prepare_data()</code>: добавляю переменных и полностью переписываю <code>case ToFile</code>:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">process_data</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">BytesInBlockDiv16</span><span class="p">){</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">canToFile</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="p">...</span>

    <span class="k">case</span> <span class="nl">ToFile</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">&gt;=</span> <span class="n">FILES_AREA</span><span class="p">)</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">canToFile</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_SET_BLOCK_LEN</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
                <span class="n">SdSendCommand</span><span class="p">(</span><span class="n">MMC_WRITE_SINGLE_BLOCK</span><span class="p">,</span> <span class="p">(</span><span class="mi">512</span> <span class="o">*</span> <span class="n">cnt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">sdResponce</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sdResponce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">canToFile</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">SdOutByte</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
                    <span class="n">SdOutByte</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
                    <span class="n">SdOutByte</span><span class="p">(</span><span class="n">MMC_START_TOKEN_SINGLE</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">canToFile</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">canToFile</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">SdOutByte</span><span class="p">(</span><span class="n">data_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="n">ind</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">canToFile</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="mi">32</span> <span class="p">))</span> <span class="p">{</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">canToFile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">SdOutByte</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>    <span class="cm">/* intstead CRC */</span>
                <span class="n">SdOutByte</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
                <span class="kt">uint8_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">SdInByte</span><span class="p">();</span>           <span class="cm">/* Data Responce */</span>
                <span class="k">while</span><span class="p">(</span><span class="n">SdInByte</span><span class="p">()</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
</pre></div>


<p>Здесь переменная <code>ind</code> содержит индекс 16-байтового куска из тех, которыми ведется обмен по USB через конечную точку. Нужна для того, чтобы закончить работу с записью текущего сектора и при необходимости начать новый. </p>
<p>Переменная <code>cnt</code> &mdash; счетчик 512-байтовых блоков. Желаемый записываемый объем в упомянутых блоках задается в последней конструкции <code>if (cnt &gt; x)</code>, где x &mdash; предел счета блоков.</p>
<p>Переменная <code>canToFile</code> запрещает запись на флэшку, когда заданный объем заполнен, а данные все еще идут.</p>
<p>Если индекс равен нулю, значит, сектор только начинается, и нужно выдать команду записи сектора и токен данных. Если индекс от нуля включительно до 32 исключительно, то пишется сектор. Если индекс равен 32, то сектор дописан и нужно флэшек об этом сообщить и при необходимости подготовить начало записи нового сектора. А если дописали до конца, то запретить работу с флэшкой.</p>
<p>Вот, собственно, и все. Перекомпилированная программа зашита в устройство. После перезапуска питания прочитан файл <code>TO_FILE.TXT</code>, после чего в окно &laquo;флэшки&raquo; заброшен на запись файл с текстовой &laquo;рыбой&raquo;. Теперь на настоящей, не имитируемой флэшке с нулевого сектора хранится текст, около 6 килобайтов всякой ерунды. А также проверена возможность записи объема данных, ограниченного только объемом памяти во флэшке.</p>
<p>Запись с <abbr title="персональный компьютер">ПК</abbr> на флэш хотя и работает, но не очень-то удобна, и не допускает нормального разделения на файлы. Но такая задача и не ставилась. Для нормальной записи на флэшку можно использовать функции, встроенные в библиотеку LUFA и перекладывающие часть работы на <abbr title="операционная система">ОС</abbr> и контроллер SD-карты.</p>
<h2 id="_14">Пример использования</h2>
<p>Допустим, есть желание выводить на <abbr title="жидкокристаллический">ЖК</abbr>-экран некоторую картинку, изменяющуюся в результате внешнего воздействия, скажем, по нажатию кнопки. Места для кода картинок нет. Точнее, оно сильно ограничено, поэтому можно хранить в памяти программ очень мало очень маленьких картинок. Зато их можно хранить на флэшке, на подключенной SD-карте.</p>
<p>Для начала следует сформировать блок данных, который будет записан на SD-карту. В нем нужно закодировать выводимые изображения. Картинки должны составлять последовательность одинаковых пакетов данных, желательно кратных степени двойки по размеру для удобства адресации.</p>
<p>Делаю двадцать похожих картинок 19х19 точек в виде кружочка, внутри которого две цифры (от &laquo;00&raquo; до &laquo;19&raquo;) и маленькая &laquo;стрелочка&raquo; (две точки вне круга и одна внутри). Никаких рисовально-графических программ под рукой нет, зато есть блокнот в клеточку, на котором рисую черновик:</p>
<p><a href="http://romeogolf.github.io/images/usb-polygon/18/dial-sketch.jpg" title="Набросок циферблата"><img alt="dial_sketch" src="http://romeogolf.github.io/images/usb-polygon/18/preview/dial-sketch-small.jpg" title="Набросок циферблата"></a></p>
<p>Глядя на эскиз, собираю двоичный файл по аналогии с файлом для выдачи на экран из <a href="http://romeogolf.github.io/usb-polygon-17.html#file">опуса 17</a>:</p>
<div class="highlight"><pre><span></span>00000000: 01 42 01 a6 02 00 00 00 00 80 00 60 00 10 00 88  .B.........`....
00000010: 00 48 00 44 00 84 00 0f 00 84 00 44 00 48 00 88  .H.D.......D.H..
00000020: 00 10 00 60 00 80 00 00 00 00 01 43 01 a6 02 00  ...`.......C....
00000030: 00 00 00 0f 00 30 00 40 00 8f 00 92 00 11 00 0f  .....0.@........
00000040: 00 00 00 0f 00 12 00 91 00 8f 00 40 00 30 00 0f  ...........@.0..
00000050: 00 00 00 00 01 44 01 a6 02 00 00 00 00 00 00 00  .....D..........
00000060: 00 00 00 00 00 00 00 01 00 01 00 01 00 01 00 01  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03 00  ................
</pre></div>


<p>Здесь я не стал делать предварительное стирание картинки, так как его достаточно сделать один раз, а потом все картинки будут рисоваться на одном и том же месте, затирая предыдущие.</p>
<p>19 точек в высоту и 19 в ширину &mdash; это три байтовые линии по 19 байтов, в третьей линии используются только 3 младших разряда. Две пары байтов используются для установки начальной позиции каждой линии, итого &mdash; 12 байтов.</p>
<p>Позиция по горизонтали вычисляется так: (96 / 2) - (19 / 2) = 38,5 = 0x26 (округляя до меньшего). Добавив разряд команды установки адреса по X (0x80), получим 0xA6.</p>
<p>По вертикали начну с третьей линейки, то есть, адрес 2. Плюс разряд команды установки адреса по Y (0x40), получаем 0x42.</p>
<p>Для второй и третьей линеек картинки адрес по X будет тот же, а адреса по Y &mdash; 0x43 и 0x44 соответственно.</p>
<p>19 пар байтов для данных для каждой линии, итого (с установкой адреса) &mdash; 114 байтов. Всего на картинку из трех линий получается 126 байтов. Пара байтов осталось. Добавляю еще страховочную команду &laquo;стоп&raquo; в виде тройки в первом байте пары при произвольном втором байте. При известной длине &laquo;файла&raquo; картинки команда остановки вообще-то не нужна, достаточно ограничить цикл чтения заданным числом. Но место есть, поэтому вставлю.</p>
<p>Проверяю эту картинку по той же технологии, что и в <a href="http://romeogolf.github.io/usb-polygon-17.html#file">опусе 17</a>: подключаю устройство, в окне &laquo;флэшки&raquo; читаю файл <code>TO_SPI.TXT</code>, затем записываю на &laquo;флэшку&raquo; полученный двоичный файл. Вижу &mdash; нарисовано именно то, что задумано.</p>
<p><img alt="dial_00" src="http://romeogolf.github.io/images/usb-polygon/18/dial-00.jpg" title="Циферблат на нулевом значении"></p>
<p>Картинка занимает как раз кратное степени двойки (2<sup>7</sup>) число байтов. Собираю файл из двадцати таких картинок. Но вручную лениво, поэтому набросал за вечер с перерывами программку на С++, которая заполняет массив одинаковыми кругами, цифрами в зависимости от номера картинки и &laquo;стрелочками&raquo;, которые рисовались почти вручную, по точкам.</p>
<p>Записываю получившийся файл на SD-карту, как описано в предыдущем параграфе. После сброса проверяю чтение &mdash; совпадает. Вообще-то, правильнее бы перед записью подогнать размер записываемого файла в программе к размеру реально получившегося бинарника. Но для однократной операции не буду вмешиваться в код, сработает и так.</p>
<p>Пора вносить изменения в программу контроллера, в файл <code>MassStorage.c</code>.</p>
<p>Для наглядности возвращаю значение режима вывода на светодиоды <code>mode_out</code> в нулевое и добавляю переменную, хранящую его предыдущее значение:</p>
<div class="highlight"><pre><span></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mode_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// режим вывода</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mode_out_old</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// режим вывода</span>
</pre></div>


<p>Добавляю еще несколько переменных:</p>
<div class="highlight"><pre><span></span>    <span class="kt">int8_t</span> <span class="n">cnt20</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// счетчик для циферблата</span>
    <span class="kt">int8_t</span> <span class="n">cnt20old</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">canDoOld</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// для определения момента включения</span>
</pre></div>


<p>Там, где изменяется счетчик нажатия кнопок, добавляю изменение вновь введенного счетчика по модулю 20. Вместо</p>
<div class="highlight"><pre><span></span>                    <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="n">BT_1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">cnt_bt</span><span class="o">++</span><span class="p">;}</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="n">BT_2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">cnt_bt</span><span class="o">--</span><span class="p">;}</span>
</pre></div>


<p>пишу</p>
<div class="highlight"><pre><span></span>                    <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="n">BT_1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">cnt_bt</span><span class="o">++</span><span class="p">;</span>
                        <span class="n">cnt20</span><span class="o">++</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">cnt20</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span><span class="n">cnt20</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;}</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="n">BT_2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">cnt_bt</span><span class="o">--</span><span class="p">;</span>
                        <span class="n">cnt20</span><span class="o">--</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">cnt20</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">cnt20</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;}</span>
                    <span class="p">}</span>
</pre></div>


<p>В блоке <code>switch (mode_out)</code> меняю в <code>case 2:</code> <code>cnt_bt</code> на <code>cnt20</code>. Далее, после выполнения всех операций внутри условия <code>if (bt_now != bt_old)</code> вставляю такой блок кода:</p>
<div class="highlight"><pre><span></span>            <span class="k">if</span> <span class="p">(</span><span class="n">canDo</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">canDoOld</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">canDoOld</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">mode_out_old</span> <span class="o">=</span> <span class="n">mode_out</span><span class="p">;</span>
                    <span class="n">mode_out</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="n">scrClear</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cnt20</span> <span class="o">!=</span> <span class="n">cnt20old</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">cnt20old</span> <span class="o">=</span> <span class="n">cnt20</span><span class="p">;</span>
                    <span class="kt">uint32_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">cnt20</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
                    <span class="kt">uint32_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="kt">uint8_t</span> <span class="n">forScreen</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
                    <span class="kt">bool</span> <span class="n">canOut</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">128</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">SdReadDataBlock</span><span class="p">(</span><span class="n">addr</span><span class="o">++</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">forScreen</span><span class="p">);</span>
                        <span class="n">addr</span><span class="o">++</span><span class="p">;</span>
                        <span class="k">switch</span> <span class="p">(</span><span class="n">forScreen</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                            <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
                                <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT_DC</span><span class="p">;</span>       <span class="c1">// d/c -&gt; 0</span>
                                <span class="n">canOut</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
                                <span class="n">PORTB</span> <span class="o">|=</span> <span class="n">BIT_DC</span><span class="p">;</span>        <span class="c1">// d/c -&gt; 1</span>
                                <span class="n">canOut</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
                                <span class="n">canOut</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
                                <span class="n">scrClear</span><span class="p">();</span>
                                <span class="n">canOut</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="k">default</span><span class="o">:</span>
                                <span class="p">;</span>
                        <span class="p">}</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">forScreen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span><span class="k">break</span><span class="p">;}</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">canOut</span><span class="p">)</span> <span class="p">{</span><span class="n">out8bit</span><span class="p">(</span><span class="n">forScreen</span><span class="p">[</span><span class="mi">1</span><span class="p">]);}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">canDoOld</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">mode_out</span> <span class="o">=</span> <span class="n">mode_out_old</span><span class="p">;</span>
            <span class="p">}</span>
</pre></div>


<p>Здесь используется введенный в <a href="http://romeogolf.github.io/usb-polygon-15.html">опусе 15</a> флаг <code>canDo</code>. Он переключается нижними кнопками, четвертой и пятой. Сперва проверяется начало включения режима работы с экраном при помощи вспомогательной переменной <code>canDoOld</code>, при его включении режим отображения на светодиодную линейку (таймер-счетчик) переключается на счетчик по модулю 20 &mdash; для наглядности. При выключении режима работы с экраном режим отображения на диодах возвращается в запомненное состояние.</p>
<p>В режиме <code>canDo == 1</code> проверяется изменение счетчика <code>cnt20</code>. Если счетчик изменился, то вычисляется адрес начала картинки, соответствующей значению счетчика. Вычисляется очень просто &mdash; сдвигом на 7 влево, раз уж картинка занимает 2<sup>7</sup> байтов.</p>
<p>Далее читаются подряд пары байтов из кода картинки, расшифровывается значение первого &mdash; командного &mdash; байта пары, выполняются соответствующие команде действия и при необходимости передается второй байт пары.</p>
<p>Так как картинки относительно небольшие, можно было бы считывать их целиком в буферный массив <code>data[128]</code>, но если считывать именно так, парами байтов, можно использовать картинки, размером в весь экран.</p>
<p id="dial">Итак, после компиляции и перепрошивки вижу на светодиодах нарастающий счетчик. Нажимаю четвертую кнопку &mdash; на светодиодах пусто, на экране вместо моего логотипа появляется кружочек с двумя ноликами внутри и маленькой стрелочкой вверх. Нажимаю верхнюю кнопку, и правый нолик изменяется на единичку, а стрелочка смещается по часовой стрелке. Первой и второй кнопкой можно заставить этот циферблат показать все, на что он способен.</p>
<p><img alt="dial_300" src="http://romeogolf.github.io/images/usb-polygon/18/dial-300.gif" title="Циферблат в действии"></p>
<h2 id="_15">Итог</h2>
<p>К устройству успешно подключена SD-карта. Отлажена ее инициализация, чтение, стирание, запись. Показан пример применения, с предварительным формированием служебного файла, записью его на карточку и последующим считыванием для использования в программе.</p>
<p>Показано применение одновременно сосуществующих на шине SPI разных устройств. Причем, одно из них отображает данные из другого, хоть и не напрямую.</p>
<p>Надо сказать, что на подобных ограниченных по памяти устройствах оправдано использование именно SD-карт, а не SDHC или SDXC. Старые карты проще в использовании и способны читаться побайтово, а не посекторно.</p>
<p>И да, многое в проекте сделано неоптимально, но цель проекта &mdash; демонстрация и отладка. В реальном проекте полезного прибора оптимизацию нужно выполнять по ситуации, выбирая, что важнее: удобство, простота и скорость написания кода, быстродействие устройства или объем памяти, занимаемый программой и данными. Чем-то придется пожертвовать, а чаще всего &mdash; двумя из трех.</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "usb-polygon-18.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>