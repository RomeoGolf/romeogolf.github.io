<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-7: Обмен по USB, подготовка устройства</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-0">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">17</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/nishchebrod.html">
              нищеброд
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pokhodnoe.html">
              походное
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/samodelki.html">
              самоделки
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Ср 25 Январь 2017</h4>
    <article>
      <h1>USB-polygon-7: Обмен по USB, подготовка устройства</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Проект заново</a></li>
<li><a href="#_2">&laquo;Лампочки и кнопки&raquo;</a></li>
<li><a href="#_3">Проверка связи</a></li>
<li><a href="#-">Пиши-читай (заготовка)</a></li>
<li><a href="#flash-">Чтение и запись мимо flash-памяти</a></li>
<li><a href="#_4">Еще немного о взаимодействии с ПК</a></li>
</ul>
</div>
<h2 id="_1">Проект заново</h2>
<p>Продолжаем разговор. Попробую завести какой-то обмен между платой и ПК. Подготовлю заготовку контроллерной программы, но не буду продолжать то, что сделано раньше, а начну сначала.</p>
<p>Создаю папку <code>usb-polygon</code>, копирую в нее demo-проект <code>MassStorage</code> из <code>ClassDriver</code> и саму библиотеку <code>LUFA</code> (второе, в принципе, не обязательно, но я так сделаю), и в <code>MassStorage</code> создаю git-репозиторий.</p>
<p>Далее правлю <code>Makefile</code>, оставляя в переменной <code>LUFA_PATH</code> только одну пару точек (библиотека теперь лежит одним уровнем выше) и закрываю комментариями переменные <code>COMPILER_PATH</code> и <code>SHELL</code> &mdash; они не нужны, если cygwin уже настроен, как описано в предыдущих выпусках цикла. В результате получаю первую успешную компиляцию проекта с получением hex-файла, который, однако, еще нельзя использовать.</p>
<p>Надо исправить в <code>Makefile</code> переменную <code>MCU</code> на <code>at90usb162</code> и <code>BOARD</code> на <code>NONE</code> и начинать править код, потому что компилятор выдаст ошибки. Чтобы получить удачную компиляцию, в коде <code>MassStorage.c</code> закрываю комментариями функции (и блоки, их содержащие), с <code>Dataflash</code> в названии, а заодно и с <code>LED</code> в названии, потому что в моей плате хоть и есть светодиоды, но не такие и не там. Также закрываю Dataflash-функции в модуле <code>Lib/SCSI.c</code> и директивы <code>#include</code> с файлами <code>LEDs.c</code>, <code>Dataflash.c</code> и <code>Platform.c</code> в заголовочном файле <code>MassStorage.h</code>.</p>
<h2 id="_2">&laquo;Лампочки и кнопки&raquo;</h2>
<p>Теперь надо добавить код, который будет выдавать что-то интересное на светодиоды и реагировать на кнопки.</p>
<p>Перед главной функцией (<code>main</code>) добавляю объявление переменной &mdash; контрольного счетчика, который можно будет увеличивать разными способами: в основном цикле безусловно или при обнаружении изменения флага, в прерываниях, еще как-нибудь:</p>
<div class="highlight"><pre><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1">// просто счетчик</span>
</pre></div>


<p>В главной функции после <code>GlobalInterruptEnable();</code> добавляю инициализацию портов, объявление переменных и запуск таймеров:</p>
<div class="highlight"><pre>    <span class="n">PORTD</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>    <span class="c1">// начальное значение - все нули</span>
    <span class="n">DDRD</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>     <span class="c1">// все линии порта на вывод</span>
    <span class="n">PORTC</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>    <span class="c1">// без &quot;подтяжки&quot; (есть внешняя)</span>
    <span class="n">DDRC</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>     <span class="c1">// все линии порта на ввод</span>

    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cnt_bt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// счетчик нажатий на кнопки</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mode_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// режим вывода</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bt_now</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// состояние кнопок</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bt_old</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// состояние кнопок в прошлый раз</span>

    <span class="cm">/* запуск таймера 0 на период ~0.01 с */</span>
    <span class="cm">/* (защита от дребезга) */</span>
    <span class="n">TCCR0B</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>  <span class="cm">/* 1 тик = 0.000032 с */</span>
    <span class="n">TCNT0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* 256 раз ~ 0.008192 c  */</span>

    <span class="cm">/* запуск таймера 1 на период 0.5 с */</span>
    <span class="cm">/* (счетчик с полусекундной задержкой) */</span>
    <span class="n">TCCR1B</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>              <span class="cm">/* 1 тик = 0.000032 с */</span>
    <span class="n">TCNT1</span> <span class="o">=</span> <span class="mi">65536</span> <span class="o">-</span> <span class="mi">15625</span><span class="p">;</span>
    <span class="cm">/* разрешение прерываний таймера 1*/</span>
    <span class="cm">/*TIMSK1 = (1 &lt;&lt; TOIE1);*/</span>
</pre></div>


<p>В главном цикле <code>for</code> после <code>USB_USBTask();</code> добавляю код:</p>
<div class="highlight"><pre>        <span class="cm">/* проверка срабатывания таймера без прерываний по флагу */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">TIFR1</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TCNT1</span> <span class="o">=</span> <span class="mi">65536</span> <span class="o">-</span> <span class="mi">15625</span><span class="p">;</span>  <span class="cm">/* перезапуск таймера 1 */</span>
            <span class="n">TIFR1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>              <span class="cm">/* сброс флага таймера 1 */</span>
            <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>                  <span class="cm">/* инкремент контрольного счетчика по таймеру */</span>
        <span class="p">}</span>

        <span class="cm">/* обработка действий по срабатыванию таймера 0 */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">TIFR0</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TCNT0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* перезапуск таймера 0 */</span>
            <span class="n">TIFR0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* сброс флага срабатывания таймера 0 */</span>

            <span class="cm">/* cnt++;*/</span>     <span class="c1">// инкремент счетчика - чтобы что-то изменялось</span>
            <span class="n">bt_now</span> <span class="o">=</span> <span class="n">PINC</span><span class="p">;</span>                  <span class="c1">// считывание порта с кнопками</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bt_now</span> <span class="o">!=</span> <span class="n">bt_old</span><span class="p">)</span> <span class="p">{</span>         <span class="c1">// если состояние порта изменилось</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// если нажаты сразу две верхние кнопки на разрядах 3 и 4</span>
                    <span class="n">mode_out</span><span class="o">++</span><span class="p">;</span>             <span class="c1">// циклически изменить режим отображения,</span>
                    <span class="n">mode_out</span> <span class="o">=</span> <span class="n">mode_out</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span><span class="c1">// которых всего 4 - 0, 1, 2 и 3 (2 разряда по маске)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                    <span class="c1">// в противном случае</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">cnt_bt</span><span class="o">++</span><span class="p">;}</span>  <span class="c1">// верхняя кнопка увеличивает счет нажатий</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">bt_now</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">cnt_bt</span><span class="o">--</span><span class="p">;}</span>  <span class="c1">// а вторая сверху - уменьшает</span>
                <span class="p">}</span>
                <span class="n">bt_old</span> <span class="o">=</span> <span class="n">bt_now</span><span class="p">;</span>            <span class="c1">// и сохраняем состояние порта для следующей проверки</span>
            <span class="p">}</span>

            <span class="k">switch</span> <span class="p">(</span><span class="n">mode_out</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="mi">0</span> <span class="o">:</span>
                    <span class="n">PORTD</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>    <span class="c1">// просто счетчик</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="mi">1</span> <span class="o">:</span>
                     <span class="n">PORTD</span> <span class="o">=</span> <span class="n">bt_now</span><span class="p">;</span>            <span class="c1">// состояние кнопок</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="mi">2</span> <span class="o">:</span>
                    <span class="n">PORTD</span> <span class="o">=</span> <span class="n">cnt_bt</span><span class="p">;</span>  <span class="c1">// счетчик нажатий</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">default</span><span class="o">:</span>
                    <span class="n">PORTD</span> <span class="o">=</span> <span class="mh">0x55</span><span class="p">;</span>    <span class="c1">// просто константа</span>
            <span class="p">}</span>
        <span class="p">}</span>
</pre></div>


<p>После главного цикла добавлю на всякий случай незадействованный обработчик прерывания таймера 1:</p>
<div class="highlight"><pre><span class="cm">/* обработчик прерывания таймера, если разрешено, для проверки */</span>
<span class="n">ISR</span> <span class="p">(</span><span class="n">TIMER1_OVF_vect</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TCNT1</span> <span class="o">=</span> <span class="mi">65536</span><span class="o">-</span><span class="mi">15625</span><span class="p">;</span>    <span class="c1">// перезапуск таймера</span>
    <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>                  <span class="c1">// инкремент контрольного счетчика</span>
<span class="p">}</span>
</pre></div>


<p>Все это компилируется и работает на плате в автономном режиме: светодиоды по умолчанию демонстрируют счетчик, изменяющийся с полусекундным интервалом, одновременное нажатие на верхние две кнопки переключает режим отображения, позволяя показать состояние кнопок, &laquo;кнопочный&raquo; счетчик (увеличиваемый нажатием на верхнюю кнопку и уменьшаемый нажатием на вторую) или просто константу 0х55 (светодиоды горят через один). Плата при этом видна в системе как флэш-накопитель с файловой системой RAW и емкостью 0. Причем, Windows 7 дает ей букву очень не сразу и настойчиво предлагает отформатировать. Сохраняю очередной коммит в git и добавляю ему тег &laquo;v0.1&raquo;.</p>
<h2 id="_3">Проверка связи</h2>
<p>Для начала хочу сделать так, чтобы плата посредством светодиодов показала, что видит обращение к себе со стороны компьютера.</p>
<p>Под объявлением счетчика cnt добавляю объявление еще одного:</p>
<div class="highlight"><pre><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cnt_usb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>В переключателе <code>switch (mode_out)</code> вместо вывода константы делаю вывод этого счетчика:</p>
<div class="highlight"><pre>                <span class="k">default</span><span class="o">:</span>
                    <span class="n">PORTD</span> <span class="o">=</span> <span class="n">cnt_usb</span><span class="p">;</span>
</pre></div>


<p>И <code>mode_out</code> при объявлении присваиваю значение 3, чтобы показывало, что там творится при подаче питания с порта. Ну и надо наконец найти подходящее место, в которое вставить инкремент этого счетчика.</p>
<p>Нахожу функцию <code>void MassStorage_Task(void)</code>, в которой обрабатываются SCSI-команды, подаваемые устройству. Вот сразу после выяснения статуса команды проверяю этот статус и, если команда выполнена успешно, увеличиваю значение счетчика: после</p>
<div class="highlight"><pre>        <span class="cm">/* Decode the received SCSI command, set returned status code */</span>
        <span class="n">CommandStatus</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">SCSI_DecodeSCSICommand</span><span class="p">()</span> <span class="o">?</span> <span class="nl">MS_SCSI_COMMAND_Pass</span> <span class="p">:</span> <span class="n">MS_SCSI_COMMAND_Fail</span><span class="p">;</span>
</pre></div>


<p>вставляю</p>
<div class="highlight"><pre>        <span class="k">if</span> <span class="p">(</span><span class="n">CommandStatus</span><span class="p">.</span><span class="n">Status</span> <span class="o">==</span> <span class="n">MS_SCSI_COMMAND_Pass</span><span class="p">){</span>
            <span class="n">cnt_usb</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>


<p>После компиляции и прошивки  запускаю выполнение (под Windows 7). Счетчик мгновенно досчитывает до значения 11. Потом потихонечку отсчитывает до 18, а потом резко наматывает довольно много, одновременно на экране ПК появляется предложение отформатировать диск, а счетчик продолжает считать. Буква диска получена. Счетчик еще считает потихонечку. Выделение буквы диска в проводнике вызывает всплеск отсчета, щелчок правой кнопкой &mdash; тоже, как и выбор пункта &laquo;Свойства&raquo; контекстного меню.</p>
<p>А счетчик продолжает считать. Система при подключении опрашивает устройство, чтобы узнать, что это и какие драйвера подключать. Потом пытается прочитать информацию о файловой системе, раз уж это MassStorage. Ну и потом периодически опрашивает, чтобы быть в курсе &mdash; не уснуло ли, а то и вовсе отключилось.</p>
<p>Кстати, если сравнивать статус не с <code>MS_SCSI_COMMAND_Pass</code>, а с <code>MS_SCSI_COMMAND_Fail</code>, счетчик ведет себя похоже, только не тикает, пока к устройству нет обращения. По-видимому, это связано с нереализованными в устройстве операциями записи и чтения. Точнее, с испорченными &mdash; там же были закрыты функции Dataflash.</p>
<p>Сделаю из этого в git отдельную ветку, скажем, test_usb.</p>
<p>Продолжу проверку связи. Условие с приращением счетчика <code>cnt_usb</code> в <code>MassStorage.c</code> я закрою, зато добавлю строчку <code>cnt_usb++</code> в модуле <code>SCSI.c</code> в функции <code>bool SCSI_DecodeSCSICommand(void)</code>, в переключателе <code>CommandBlock.SCSICommandData[0]</code> при выборе <code>SCSI_CMD_INQUIRY'. Ну и добавлю объявление переменной</code>cnt_usb<code>в</code>SCSI.h<code>, где-нибудь в самом конце перед</code>#endif`:</p>
<div class="highlight"><pre>        <span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cnt_usb</span><span class="p">;</span>
</pre></div>


<p>Такая модификация позволяет узнать, когда и сколько раз система выдает устройству запрос <code>INQUIRY</code>. Оказывается, пять раз после подключения, а потом по разику после запуска программы на С++ из предыдущего <a href="http://romeogolf.github.io/usb-polygon-6.html">выпуска</a>, потому что там есть явная подача этой команды при помощи <code>DeviceIoControl</code>.</p>
<p>Аналогичным образом &mdash; переставляя инкремент счетчика в разные пункты данного <code>switch</code> &mdash; можно исследовать количество и интенсивность подачи разных SCSI-команд системой устройству при подключении или при программном обращении. Это тема забавная, но не очень интересная, потому что такую информацию можно найти не обязательно методами реверс-инжиниринга, достаточно почитать документацию. Но сохраню коммит с подсчетом <code>INQUIRY</code> в той же ветке и вернусь в ветку <code>master</code> к тегу &laquo;v0.1&raquo;.</p>
<h2 id="-">Пиши-читай (заготовка)</h2>
<p>На следующем этапе пробую реализовать запись и чтение данных по USB. Понятно, что в прототипе функции чтения и записи реализованы так, чтобы читать и писать в микросхему флэш-памяти, то есть, сделано это все в модуле DataflashManager. Но у меня флэшки нет, и данный модуль мне не нужен. Однако, убрать его совсем я пока не могу, потому что в нем есть важные макроопределения, без которых не компилируется проект. Значит, нужно эти самые <code>#define</code> перенести в нужный модуль (лучше, пожалуй, сделать для этого отдельный, но это попозже, пока для проверки &mdash; так) и переписать функции чтения-записи без участия флэш.</p>
<p>Для начала в заголовочном файле SCSI.h, где-нибудь в самом конце перед <code>#endif</code>, вставляю</p>
<div class="highlight"><pre><span class="cm">/* ----- instead DataflashManager ----- */</span>

<span class="cm">/* ------------------------------------ */</span>
</pre></div>


<p>для строк, которые должны заменить <code>DataflashManager.h</code>, и начинаю заполнять этот пробел. Сначала надо вставить то, что в <code>DataflashManager.h</code> отсутствует, но подключается через <code>#include</code>. Подключается хитро, с проверкой переменной <code>BOARD</code>, определенной в makefile, поэтому возьму этот кусок из <code>LUFA\CodeTemplates\DriverStubs\Dataflash.h</code>:</p>
<div class="highlight"><pre><span class="cm">/* from ..\..\LUFA\CodeTemplates\DriverStubs\Dataflash.h */</span>
    <span class="cm">/* Public Interface - May be used in end-application: */</span>
        <span class="cm">/* Macros: */</span>
            <span class="cm">/** Constant indicating the total number of dataflash ICs mounted on the selected board. */</span>
            <span class="cp">#define DATAFLASH_TOTALCHIPS     1 </span><span class="c1">// TODO: Replace with the number of Dataflashes on the board, max 2</span>
            <span class="cm">/** Mask for no dataflash chip selected. */</span>
            <span class="cp">#define DATAFLASH_NO_CHIP        0</span>
            <span class="cm">/** Mask for the first dataflash chip selected. */</span>
            <span class="cp">#define DATAFLASH_CHIP1          1 </span><span class="c1">// TODO: Replace with mask with the pin attached to the first Dataflash /CS set</span>
            <span class="cm">/** Mask for the second dataflash chip selected. */</span>
            <span class="cp">#define DATAFLASH_CHIP2          2 </span><span class="c1">// TODO: Replace with mask with the pin attached to the second Dataflash /CS set</span>
            <span class="cm">/** Internal main memory page size for the board&#39;s dataflash ICs. */</span>
            <span class="cp">#define DATAFLASH_PAGE_SIZE      1024 </span><span class="c1">// TODO: Replace with the page size for the Dataflash ICs</span>
            <span class="cm">/** Total number of pages inside each of the board&#39;s dataflash ICs. */</span>
            <span class="cp">#define DATAFLASH_PAGES          8192 </span><span class="c1">// TODO: Replace with the total number of pages inside one of the Dataflash ICs</span>
</pre></div>


<p>Недостающие значения заполнил чем-то интуитивно похожим на правду, не разбираясь пока в тонкостях использования. Дальше переписываю уже из <code>DataflashManager.h</code>:</p>
<div class="highlight"><pre><span class="cm">/* from DataflashManager.h */</span>
    <span class="cm">/* Preprocessor Checks: */</span>
        <span class="cp">#if (DATAFLASH_PAGE_SIZE % 16)</span>
            <span class="cp">#error Dataflash page size must be a multiple of 16 bytes.</span>
        <span class="cp">#endif</span>

    <span class="cm">/* Defines: */</span>
        <span class="cm">/** Total number of bytes of the storage medium, comprised of one or more Dataflash ICs. */</span>
        <span class="cp">#define VIRTUAL_MEMORY_BYTES         ((uint32_t)DATAFLASH_PAGES * DATAFLASH_PAGE_SIZE * DATAFLASH_TOTALCHIPS)</span>
        <span class="cm">/** Block size of the device. This is kept at 512 to remain compatible with the OS despite the underlying</span>
<span class="cm">         *  storage media (Dataflash) using a different native block size. Do not change this value.</span>
<span class="cm">         */</span>
        <span class="cp">#define VIRTUAL_MEMORY_BLOCK_SIZE    512</span>
        <span class="cm">/** Total number of blocks of the virtual memory for reporting to the host as the device&#39;s total capacity. Do not</span>
<span class="cm">         *  change this value; change VIRTUAL_MEMORY_BYTES instead to alter the media size.</span>
<span class="cm">         */</span>
        <span class="cp">#define VIRTUAL_MEMORY_BLOCKS        (VIRTUAL_MEMORY_BYTES / VIRTUAL_MEMORY_BLOCK_SIZE)</span>
        <span class="cm">/** Blocks in each LUN, calculated from the total capacity divided by the total number of Logical Units in the device. */</span>
        <span class="cp">#define LUN_MEDIA_BLOCKS             (VIRTUAL_MEMORY_BLOCKS / TOTAL_LUNS)</span>

    <span class="cm">/* Function Prototypes: */</span>
        <span class="kt">void</span> <span class="nf">WriteBlocks</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span>
                                          <span class="kt">uint16_t</span> <span class="n">TotalBlocks</span><span class="p">);</span>
        <span class="kt">void</span> <span class="nf">ReadBlocks</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span>
                                         <span class="kt">uint16_t</span> <span class="n">TotalBlocks</span><span class="p">);</span>
</pre></div>


<p>При этом укорачиваю названия функций чтения и записи. В <code>SCSI.c</code> вставляю пока пустые определения объявленных в заголовочнике функций:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">WriteBlocks</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span>
                                          <span class="kt">uint16_t</span> <span class="n">TotalBlocks</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ReadBlocks</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span>
                                         <span class="kt">uint16_t</span> <span class="n">TotalBlocks</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>


<p>После этого в функции <code>SCSI_Command_ReadWrite_10</code> раскомментирую блок <code>if (IsDataRead == DATA_READ)</code> и в нем тоже укорачиваю названия функций чтения и записи, чтобы соответствовали. Теперь можно закрыть пока что комментариями</p>
<div class="highlight"><pre><span class="c1">//      #include &quot;DataflashManager.h&quot;</span>
</pre></div>


<p>в заголовочниках <code>SCSI.h</code> и <code>MassStorage.h</code>. Теперь <code>make clean</code>, <code>make</code> и проверка работоспособности &mdash; прошивка и созерцание диодиков. Работает, как раньше, но без модуля <code>DataflashManager</code>. Надо добавить коммит git.</p>
<p>Правда, совсем стирать этот модуль рано, ведь функции чтения и записи еще пустые, а для их реализации надо опираться на имеющиеся.</p>
<h2 id="flash-">Чтение и запись мимо flash-памяти</h2>
<p>Из модуля <code>DataflashManager</code> беру тела функций <code>DataflashManager_ReadBlocks</code> и <code>DataflashManager_WriteBlocks</code> для <code>ReadBlocks</code> и <code>WriteBlocks</code> соответственно, стираю оттуда все, связанное с flash-памятью, добавляю по паре собственных переменных и модифицирую получение данных из буфера конечной точки. Получается следующее:</p>
<div class="highlight"><pre><span class="cm">/** Writes blocks (OS blocks, not Dataflash pages) to the storage medium, the board Dataflash IC(s), from</span>
<span class="cm"> *  the pre-selected data OUT endpoint. This routine reads in OS sized blocks from the endpoint and writes</span>
<span class="cm"> *  them to the Dataflash in Dataflash page sized blocks.</span>
<span class="cm"> *</span>
<span class="cm"> *  \param[in] BlockAddress  Data block starting address for the write sequence</span>
<span class="cm"> *  \param[in] TotalBlocks   Number of blocks of data to write</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">WriteBlocks</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span>
                                  <span class="kt">uint16_t</span> <span class="n">TotalBlocks</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">CurrDFPage</span>          <span class="o">=</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">*</span> <span class="n">VIRTUAL_MEMORY_BLOCK_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="n">DATAFLASH_PAGE_SIZE</span><span class="p">);</span>
    <span class="kt">uint16_t</span> <span class="n">CurrDFPageByte</span>      <span class="o">=</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">*</span> <span class="n">VIRTUAL_MEMORY_BLOCK_SIZE</span><span class="p">)</span> <span class="o">%</span> <span class="n">DATAFLASH_PAGE_SIZE</span><span class="p">);</span>
    <span class="kt">uint8_t</span>  <span class="n">CurrDFPageByteDiv16</span> <span class="o">=</span> <span class="p">(</span><span class="n">CurrDFPageByte</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
    <span class="kt">uint8_t</span>  <span class="n">data_8</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="cm">/* Wait until endpoint is ready before continuing */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Endpoint_WaitUntilReady</span><span class="p">())</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">TotalBlocks</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">BytesInBlockDiv16</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* Write an endpoint packet sized data block to the Dataflash */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">VIRTUAL_MEMORY_BLOCK_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="cm">/* Check if the endpoint is currently empty */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Endpoint_IsReadWriteAllowed</span><span class="p">()))</span>
            <span class="p">{</span>
                <span class="cm">/* Clear the current endpoint bank */</span>
                <span class="n">Endpoint_ClearOUT</span><span class="p">();</span>
                <span class="cm">/* Wait until the host has sent another packet */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Endpoint_WaitUntilReady</span><span class="p">())</span>
                  <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Check if end of Dataflash page reached */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">CurrDFPageByteDiv16</span> <span class="o">==</span> <span class="p">(</span><span class="n">DATAFLASH_PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="cm">/* Reset the Dataflash buffer counter, increment the page counter */</span>
                <span class="n">CurrDFPageByteDiv16</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">CurrDFPage</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/* Write one 16-byte chunk of data to the Dataflash */</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>
            <span class="n">data_8</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">Endpoint_Read_8</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="n">data_PC</span> <span class="o">=</span> <span class="n">data_8</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="cm">/* Increment the Dataflash page 16 byte block counter */</span>
            <span class="n">CurrDFPageByteDiv16</span><span class="o">++</span><span class="p">;</span>

            <span class="cm">/* Increment the block 16 byte block counter */</span>
            <span class="n">BytesInBlockDiv16</span><span class="o">++</span><span class="p">;</span>

            <span class="cm">/* Check if the current command is being aborted by the host */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">IsMassStoreReset</span><span class="p">)</span>
              <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Decrement the blocks remaining counter */</span>
        <span class="n">TotalBlocks</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* If the endpoint is empty, clear it ready for the next packet from the host */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Endpoint_IsReadWriteAllowed</span><span class="p">()))</span>
      <span class="n">Endpoint_ClearOUT</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/** Reads blocks (OS blocks, not Dataflash pages) from the storage medium, the board Dataflash IC(s), into</span>
<span class="cm"> *  the pre-selected data IN endpoint. This routine reads in Dataflash page sized blocks from the Dataflash</span>
<span class="cm"> *  and writes them in OS sized blocks to the endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> *  \param[in] BlockAddress  Data block starting address for the read sequence</span>
<span class="cm"> *  \param[in] TotalBlocks   Number of blocks of data to read</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ReadBlocks</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span>
                                 <span class="kt">uint16_t</span> <span class="n">TotalBlocks</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">CurrDFPage</span>          <span class="o">=</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">*</span> <span class="n">VIRTUAL_MEMORY_BLOCK_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="n">DATAFLASH_PAGE_SIZE</span><span class="p">);</span>
    <span class="kt">uint16_t</span> <span class="n">CurrDFPageByte</span>      <span class="o">=</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">*</span> <span class="n">VIRTUAL_MEMORY_BLOCK_SIZE</span><span class="p">)</span> <span class="o">%</span> <span class="n">DATAFLASH_PAGE_SIZE</span><span class="p">);</span>
    <span class="kt">uint8_t</span>  <span class="n">CurrDFPageByteDiv16</span> <span class="o">=</span> <span class="p">(</span><span class="n">CurrDFPageByte</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
    <span class="kt">uint8_t</span>  <span class="n">data_8</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="kt">uint8_t</span>  <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">data_8</span><span class="p">;</span>

    <span class="cm">/* Wait until endpoint is ready before continuing */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Endpoint_WaitUntilReady</span><span class="p">())</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">TotalBlocks</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">BytesInBlockDiv16</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* Read an endpoint packet sized data block from the Dataflash */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">VIRTUAL_MEMORY_BLOCK_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="cm">/* Check if the endpoint is currently full */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Endpoint_IsReadWriteAllowed</span><span class="p">()))</span>
            <span class="p">{</span>
                <span class="cm">/* Clear the endpoint bank to send its contents to the host */</span>
                <span class="n">Endpoint_ClearIN</span><span class="p">();</span>

                <span class="cm">/* Wait until the endpoint is ready for more data */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Endpoint_WaitUntilReady</span><span class="p">())</span>
                  <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/* Check if end of Dataflash page reached */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">CurrDFPageByteDiv16</span> <span class="o">==</span> <span class="p">(</span><span class="n">DATAFLASH_PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="cm">/* Reset the Dataflash buffer counter, increment the page counter */</span>
                <span class="n">CurrDFPageByteDiv16</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">CurrDFPage</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">data_8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_device</span><span class="p">;</span>

            <span class="cm">/* Read one 16-byte chunk of data from the Dataflash */</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">9</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">11</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">12</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">13</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">14</span><span class="p">]);</span>
            <span class="n">Endpoint_Write_8</span><span class="p">(</span><span class="n">pdata</span><span class="p">[</span><span class="mi">15</span><span class="p">]);</span>

            <span class="cm">/* Increment the Dataflash page 16 byte block counter */</span>
            <span class="n">CurrDFPageByteDiv16</span><span class="o">++</span><span class="p">;</span>

            <span class="cm">/* Increment the block 16 byte block counter */</span>
            <span class="n">BytesInBlockDiv16</span><span class="o">++</span><span class="p">;</span>

            <span class="cm">/* Check if the current command is being aborted by the host */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">IsMassStoreReset</span><span class="p">)</span>
              <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Decrement the blocks remaining counter */</span>
        <span class="n">TotalBlocks</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* If the endpoint is full, send its contents to the host */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Endpoint_IsReadWriteAllowed</span><span class="p">()))</span>
      <span class="n">Endpoint_ClearIN</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p><code>data_8</code> &mdash; это массив для обмена данными с буфером конечной точки, <code>data_PC</code> и <code>data_device</code> будут контрольными переменными для их отображения на светодиодах и в консоли ПК соответственно, а <code>first</code> нужна для того, чтобы в контрольную переменную попал первый байт передаваемого из ПК массива и не перезатерся при дальнейшей передаче 16-байтных кусков. Контрольные переменные надо не забыть объявить в <code>SCSI.h</code>:</p>
<div class="highlight"><pre>    <span class="cm">/* variables */</span>
        <span class="k">extern</span> <span class="kt">uint8_t</span> <span class="n">data_PC</span><span class="p">;</span>
        <span class="k">extern</span> <span class="kt">uint8_t</span> <span class="n">data_device</span><span class="p">;</span>
</pre></div>


<p>А также их надо определить и использовать в <code>MassStorage.c</code>:</p>
<div class="highlight"><pre>:cpp
uint8_t data_PC;
uint8_t data_device;
</pre></div>


<p>перед главной функцией, <code>data_device = cnt_bt;</code> перед <code>switch (mode_out) {</code> и <code>PORTD = data_PC;</code> вместо <code>PORTD = 0x55</code>.</p>
<p>Компиляция, прошивка, проверка. Теперь код для ПК, написанный несколько ранее на С++, работает ожидаемо: в консоли пишет <code>data_2 =</code> и число, соответствующее счетчику <code>cnt_bt</code> на устройстве (увеличивается нажатием верхней кнопки, уменьшается второй кнопкой, отображается на светодиодах в &laquo;режиме 2&raquo;), а на светодиодах в &laquo;режиме 3&raquo; вместо константы 0x55 отображается то, что указано в коде С++ в нулевом элементе массива q.</p>
<p>И буква устройству в Windows 7 стала выделяться гораздо быстрее &mdash; практически сразу после подключения.</p>
<p>Это изменения, достойные новой версии. Коммит с тегом &laquo;v0.2&raquo;</p>
<h2 id="_4">Еще немного о взаимодействии с ПК</h2>
<p>Вернусь к коду на С++, написанному для ПК. В операциях чтения и записи, реализованных через <code>DeviceIoControl</code>, размер передаваемых данных указывается дважды: в поле <code>myspti.t_spti.DataTransferLength</code> и в 7&ndash;8 байтах <code>myspti.t_spti.Cdb</code>, причем, в первом случае &mdash; в байтах, а во втором &mdash; в логических блоках. Насколько я разобрался, размер логического блока соответствует <code>VIRTUAL_MEMORY_BLOCK_SIZE</code> на устройстве, то есть 512 байтов. Так вот, эти два размера в <code>myspti</code> должны соответствовать друг другу, иначе могут быть ошибки. Например, можно поставить <code>q1 = 512</code> и <code>myspti.t_spti.Cdb[8] = 0x01</code> и будет работать, а <code>q1 = 1024</code> и <code>myspti.t_spti.Cdb[8] = 0x01</code> вызовет ошибку.</p>
<p>А теперь я закрою эти две сложные конструкции чтения и записи с заполнением структур <code>myspti</code> и вызовом <code>DeviceIoControl</code> блочным комментарием, а вмето них, чуть выше их, напишу следующее:</p>
<div class="highlight"><pre>                    <span class="n">result</span> <span class="o">=</span> <span class="n">WriteFile</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">OutFormatMsg</span><span class="p">(</span><span class="s">&quot;ReadFile Error&quot;</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">_tprintf</span><span class="p">(</span><span class="s">&quot;WriteFile done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                        <span class="n">_tprintf</span><span class="p">(</span><span class="s">&quot;len = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">q2</span><span class="p">);</span>
                    <span class="p">}</span>


                    <span class="n">result</span> <span class="o">=</span> <span class="n">ReadFile</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">OutFormatMsg</span><span class="p">(</span><span class="s">&quot;ReadFile Error&quot;</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">_tprintf</span><span class="p">(</span><span class="s">&quot;ReadFile done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                        <span class="n">_tprintf</span><span class="p">(</span><span class="s">&quot;data_2 = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                        <span class="n">_tprintf</span><span class="p">(</span><span class="s">&quot;len = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">q2</span><span class="p">);</span>
                    <span class="p">}</span>
</pre></div>


<p>То есть, воспользуюсь для чтения и записи специально предназначенными для этого функциями. Компилирую, прошиваю, проверяю. </p>
<p>Работает! Ура? Вроде, ура. Теперь уже можно использовать разработанное устройство для общения с ПК &mdash; передавать данные в обе стороны и как-то их использовать.</p>
<p>Причем, можно использовать не только данные, но и адрес. То есть, устройство, получив данные, может проанализировать адрес, по которому была команда их записать (или, получив команду чтения, проанализировать адрес, с которого данные затребованы) и выполнить определенные действия в зависимости от этого адреса. Сам адрес-то фиктивный, никакой памяти, к которой относится адресация, на плате нет. При использовании <code>ReadFile/WriteFile</code> можно управлять адресом c ПК при помощи предварительно выполненной функции <code>SetFilePointer(hDevice, 0, NULL, FILE_BEGIN);</code>, а в программе устройства анализировать <code>BlockAddress</code>.</p>
<p>Пожалуй, на этом надо заканчивать, и так слишком много получилось для одного выпуска. Продолжение следует&hellip;</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "usb-polygon-7.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>