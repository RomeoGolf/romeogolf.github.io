<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-12: Имитация файлов</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">14</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Ср 23 Август 2017</h4>
    <article>
      <h1>USB-polygon-12: Имитация файлов</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">Файлы: какие надо и где их взять</a></li>
<li><a href="#_2">Подготовка управляющей структуры</a></li>
<li><a href="#_3">Заготовка для первого файла</a></li>
<li><a href="#fat">Изменения в функциях чтения FAT и чтения данных</a></li>
<li><a href="#_4">Остальные файлы</a><ul>
<li><a href="#readme">Файл ReadMe</a></li>
<li><a href="#_5">Большой файл</a></li>
<li><a href="#_6">Файл, изменяющийся вручную</a></li>
</ul>
</li>
<li><a href="#_7">Низкоуровневое чтение</a></li>
<li><a href="#_8">Итог</a></li>
</ul>
</div>
<h2 id="_1">Файлы: какие надо и где их взять</h2>
<p>В предыдущем <a href="http://romeogolf.github.io/usb-polygon-11.html">выпуске</a> цикла проект для самодельного устройства был доведен до такого состояния, что <abbr title="Операционная система">ОС</abbr> <abbr title="Персональный компьютер">ПК</abbr> определяет его, как двухгигабайтную флэшку, причем, Windows 7 уже не предлагает ее отформатировать. Однако, по мнению <abbr title="Операционная система">ОС</abbr> флэшка пуста. Надо ее &laquo;наполнить&raquo;.</p>
<p>Для начала о том, какие файлы я хотел бы видеть.</p>
<p>Во-первых, текстовый файл с неким идентификатором. Это для того, чтобы собственная программа для <abbr title="Персональный компьютер">ПК</abbr>, проверив наличие воткнутых в порты флэшек и обнаружив несколько одновременно, могла с легкостью отличить нужную (то есть, данное устройство) по наличию файла с определенным именем и определенным содержимым. Очень хорошо на мой взгляд подойдет для этой цели GUID в текстовом виде.</p>
<p>Во-вторых, некий текстовый файл, скажем, Readme. Для отладки работы с текстами разного размера и содержимого, хранящимися в памяти программ устройства, как с файлами.</p>
<p>В-третьих, &laquo;файл&raquo;, содержимое которого изменялось бы при воздействии на устройство, скажем, с отображением состояния счетчика, который меняется при нажатии на кнопки. Отображать состояние счетчика хорошо бы в текстовом виде, да еще и с каким-нибудь комментарием, чтобы открывать чем попало, хоть в notepad.</p>
<p>В-четвертых, &laquo;файл&raquo; с размером, заведомо превышающим то, что может храниться в памяти устройства, скажем, счетчик где-нибудь мегабайтного размера, в текстовом виде для удобства просмотра.</p>
<p>Потом, хотелось бы, чтобы можно было управлять количеством файлов и их размером, а также способом подготовки информации при запросе конкретного файла. То есть, должна быть какая-то управляющая структура, перечисляющая имя файла, его размер и соответствующую ему подпрограмму, отвечающую за вывод данных. А наполнение корневого каталога должно формироваться в соответствии с этой структурой, и данные по запросу каждого файла должны готовиться указанными в ней функциями.</p>
<h2 id="_2">Подготовка управляющей структуры</h2>
<p>Именно такое решение &mdash; с таблицей элементов <abbr title="Файловая система">ФС</abbr> &mdash; описано в <a href="https://habrahabr.ru/post/247673/">статье</a> на <a href="https://habrahabr.ru/">Хабрахабре</a>. Эта статья вообще сильно перекликается с тем, что я тут делаю, только для другого процессора. Идея не очень сложная, понятная, только надо ее подогнать под AVR и LUFA.</p>
<p>Для начала объявляю структуру таблицы файлов с коротким именем файла, длиной файла и подпрограммой подготовки его данных. А непосредственно перед ней объявлю и тип указателя на функцию для этой подпрограммы, чтобы она принимала указатель на порцию данных, размер порции и ее смещение в файле. Так как ничего интерфейсного в этих сущностях я пока не вижу, объявлять буду в файле <code>fake_fs.c</code>, сразу после определения констант, таким образом:</p>
<div class="highlight"><pre><span class="k">typedef</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">ProcedureForRead</span><span class="p">)(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
  <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="n">ProcedureForRead</span> <span class="n">procedureForRead</span><span class="p">;</span>
<span class="p">}</span> <span class="n">FileEntry</span><span class="p">;</span>
</pre></div>


<p>Имя предполагается короткое, &laquo;8.3&raquo;, поэтому на поле имени отведено 11 символов. Поле будет копироваться в описатель файла как есть, поэтому надо сразу заполнять его правильно: без точки-разделителя, с дополнением пробелами имени до 8 символов и расширения до 3 символов.</p>
<h2 id="_3">Заготовка для первого файла</h2>
<p>Чуть выше расположу объявления для файла, содержащего GUID в текстовом виде:</p>
<div class="highlight"><pre><span class="cp">#define SIZE_OF_KEY 38</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">guidKey</span><span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span> <span class="s">&quot;{7065c23a-3818-43c5-bdf0-55567ade31e7}&quot;</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readKey</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>


<p>Чтобы данные файла лежали в памяти программ и не засоряли оперативную, нужен для начала макрос <code>PROGMEM</code>, и потом еще некоторые макросы из модуля <code>pgmspace.h</code>, который следует подключить в начале файла:</p>
<div class="highlight"><pre><span class="cp">#include &quot;avr/pgmspace.h&quot;</span>
</pre></div>


<p>И собственно функция, выдающая данные этого &laquo;файла&raquo;:</p>
<div class="highlight"><pre><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readKey</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SIZE_OF_KEY</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_KEY</span><span class="p">)</span> <span class="n">memcpy_P</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">PGM_P</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">guidKey</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="n">SIZE_OF_KEY</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">memcpy_P</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">PGM_P</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">guidKey</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Суть: если адрес очередного запрошенного куска данных (адрес начала плюс размер передаваемого куска) выходит за границы размера файла, то скопировать в отведенный буфер только помещающийся кусок. Если же запрошенный кусок помещается с запасом &mdash; скопировать его весь. А если смещение сразу выходит за границы файла &mdash; ничего не делать.</p>
<p>Еще после объявления структуры таблицы файлов надо объявить саму таблицу, содержащую приведенный выше &laquo;файл&raquo;, с просьбой разместить ее в памяти программ и с ограничительной записью в конце:</p>
<div class="highlight"><pre><span class="k">static</span> <span class="k">const</span> <span class="n">FileEntry</span> <span class="n">fileTable</span><span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;KEY_FILETXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_KEY</span><span class="p">,</span> <span class="n">readKey</span><span class="p">},</span>
    <span class="p">{{</span> <span class="mi">0</span> <span class="p">},</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h2 id="fat">Изменения в функциях чтения <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> и чтения данных</h2>
<p>Функцию чтения данных нужно дописать. Теперь она будет иметь такой вид:</p>
<div class="highlight"><pre><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">read_data</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">BytesInBlockDiv16</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">==</span> <span class="n">ROOT_SECTOR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* root, chunck 1 */</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;L&#39;</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;U&#39;</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;F&#39;</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>

    <span class="n">data_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;_&#39;</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

    <span class="n">data_buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">==</span> <span class="n">ROOT_SECTOR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* root, chunck 2 */</span>
    <span class="cm">/* все нули */</span>
    <span class="p">}</span> <span class="k">else</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">&gt;=</span> <span class="n">ROOT_SECTOR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">BlockAddress</span> <span class="o">&lt;</span> <span class="n">ROOT_SECTOR</span> <span class="o">+</span> <span class="n">SECTORS_PER_CLUSTER</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">readingChunck</span> <span class="o">=</span> <span class="p">(((</span><span class="n">BlockAddress</span> <span class="o">-</span> <span class="n">ROOT_SECTOR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">BYTES_PER_SECT_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">fileNum</span> <span class="o">=</span> <span class="p">(</span><span class="n">readingChunck</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fileNum</span> <span class="o">&lt;=</span> <span class="n">lastFileNo</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">readingChunck</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">memcpy_P</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">PGM_P</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fileTable</span><span class="p">[</span><span class="n">fileNum</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="mi">11</span><span class="p">);</span>

                <span class="n">data_buf</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">ATTR_ARCHIVE</span><span class="p">;</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* reserv */</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span> <span class="cm">/* creation minisec */</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x72</span><span class="p">;</span> <span class="cm">/* creation time */</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* creation time */</span>

            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="kt">uint32_t</span> <span class="n">firstCluster</span> <span class="o">=</span> <span class="n">ROOT_CLUSTER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="kt">uint32_t</span> <span class="n">clustFileSize</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fileNum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">size</span> <span class="o">=</span> <span class="n">pgm_read_dword</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fileTable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">));</span>
                    <span class="n">clustFileSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">BYTES_PER_CLUSTER</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
                        <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="nl">BYTES_PER_CLUST_SHIFT</span> <span class="p">:</span>
                        <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">BYTES_PER_CLUST_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">firstCluster</span> <span class="o">+=</span> <span class="n">clustFileSize</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">data_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x79</span><span class="p">;</span> <span class="cm">/*  */</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span> <span class="cm">/*  */</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x79</span><span class="p">;</span> <span class="cm">/*  */</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span> <span class="cm">/*  */</span>

                <span class="n">data_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">firstCluster</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">firstCluster</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/*  */</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/*  */</span>

                <span class="n">data_buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x79</span><span class="p">;</span> <span class="cm">/*  */</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span> <span class="cm">/*  */</span>

                <span class="n">data_buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">firstCluster</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">firstCluster</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>

                <span class="cm">/* file size */</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">pgm_read_dword</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fileTable</span><span class="p">[</span><span class="n">fileNum</span><span class="p">].</span><span class="n">size</span><span class="p">));</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                <span class="n">data_buf</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">&gt;=</span> <span class="n">ROOT_SECTOR</span> <span class="o">+</span> <span class="n">SECTORS_PER_CLUSTER</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">BlockAddress</span> <span class="o">-=</span> <span class="n">BOOT_SECTOR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="kt">uint32_t</span> <span class="n">readingClustNo</span> <span class="o">=</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">&lt;&lt;</span> <span class="n">BYTES_PER_SECT_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">BYTES_PER_CLUST_SHIFT</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">clustFileSize</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">lastFileEndClust</span> <span class="o">=</span> <span class="n">ROOT_CLUSTER</span> <span class="p">;</span>
        <span class="n">ProcedureForRead</span> <span class="n">pFunc</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lastFileNo</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">pgm_read_dword</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fileTable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">));</span>
            <span class="n">clustFileSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">BYTES_PER_CLUSTER</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
                    <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="nl">BYTES_PER_CLUST_SHIFT</span> <span class="p">:</span>
                    <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">BYTES_PER_CLUST_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">readingClustNo</span> <span class="o">&gt;</span> <span class="n">lastFileEndClust</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">readingClustNo</span> <span class="o">&lt;=</span> <span class="n">lastFileEndClust</span> <span class="o">+</span> <span class="n">clustFileSize</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">memcpy_P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pFunc</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">fileTable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">procedureForRead</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PGM_VOID_P</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pFunc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span>
                    <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">-</span> <span class="p">((</span><span class="n">lastFileEndClust</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">SECTORS_PER_CLUST_SHIFT</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">BYTES_PER_SECT_SHIFT</span><span class="p">)</span> <span class="o">+</span>
                    <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                    <span class="k">return</span> <span class="n">pFunc</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="n">fileTable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">lastFileEndClust</span> <span class="o">+=</span> <span class="n">clustFileSize</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>В нее добавились:</p>
<ul>
<li>Проверка попадания адреса в корневой каталог для имитации файловой записи в этом каталоге. В этом случае вычисляется размер файла и адрес его первого кластера, чтобы дописать в корневой каталог в конце того, что там уже записано (на текущий момент там записан только идентификатор тома, но файлов может быть несколько, а функция универсальная)</li>
<li>Проверка попадания адреса за пределы корневого каталога для имитации содержимого файла. Тогда файл будет выдаваться 16-байтными кусками, в соответстви с адресом и смещением запрошенного куска.</li>
</ul>
<p>Функция <code>read_fat</code> также заметно разрослась и усложнилась:</p>
<div class="highlight"><pre><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">read_fat</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">BlockAddress</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">BytesInBlockDiv16</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">nextClaster</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">pgm_read_dword</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fileTable</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* first fat */</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xF8</span><span class="p">;</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0F</span><span class="p">;</span>
        <span class="cm">/* second fat */</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0F</span><span class="p">;</span>
        <span class="cm">/* root dir */</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="n">data_buf</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0F</span><span class="p">;</span>
        <span class="cm">/* file1 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fileTable</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">SECTORS_PER_CLUSTER</span> <span class="o">*</span> <span class="n">BYTES_PER_SECTOR</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0F</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">SECTORS_PER_CLUSTER</span> <span class="o">*</span> <span class="n">BYTES_PER_SECTOR</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">nextClaster</span> <span class="o">=</span> <span class="p">(</span><span class="n">ROOT_CLUSTER</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextClaster</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextClaster</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextClaster</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
          <span class="n">data_buf</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextClaster</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">readingClustNo</span> <span class="o">=</span> <span class="p">((</span><span class="n">BlockAddress</span> <span class="o">&lt;&lt;</span> <span class="n">BYTES_PER_SECT_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">BytesInBlockDiv16</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">clustFileSize</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">lastFileEndClust</span> <span class="o">=</span> <span class="n">ROOT_CLUSTER</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">currFileNo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span><span class="mi">4</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">currFileNo</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lastFileNo</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">pgm_read_dword</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fileTable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">));</span>
                <span class="n">clustFileSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">BYTES_PER_CLUSTER</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
                        <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="nl">BYTES_PER_CLUST_SHIFT</span> <span class="p">:</span>
                        <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">BYTES_PER_CLUST_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">readingClustNo</span> <span class="o">==</span> <span class="n">lastFileEndClust</span> <span class="o">+</span> <span class="n">clustFileSize</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">data_buf</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
                    <span class="n">data_buf</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
                    <span class="n">data_buf</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
                    <span class="n">data_buf</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0F</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">readingClustNo</span> <span class="o">&gt;</span> <span class="n">lastFileEndClust</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">readingClustNo</span> <span class="o">&lt;</span> <span class="n">lastFileEndClust</span> <span class="o">+</span> <span class="n">clustFileSize</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">nextClaster</span> <span class="o">=</span> <span class="p">(</span><span class="n">readingClustNo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="n">data_buf</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextClaster</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                    <span class="n">data_buf</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextClaster</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                    <span class="n">data_buf</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextClaster</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                    <span class="n">data_buf</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextClaster</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">lastFileEndClust</span> <span class="o">+=</span> <span class="n">clustFileSize</span><span class="p">;</span>
                <span class="n">currFileNo</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">readingClustNo</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>В нее добавились операции по вычислению положения файла в области данных для заполнения соответствующих элементов таблицы <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>.</p>
<p>Чтобы эти изменения работали, требуется добавить глобальные переменные, необходимые для вычисления принадлежности запрашиваемых адресов тому или иному файлу. Это количество кластеров, занятых файлами, и номер последнего файла:</p>
<div class="highlight"><pre><span class="kt">uint32_t</span> <span class="n">nClusters</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">lastFileNo</span><span class="p">;</span>
</pre></div>


<p>Их необходимо инициализировать, для чего потребуется функция, определяющая по таблице файлов соответствующие параметры:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">fakeFsInit</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">nClusters</span> <span class="o">=</span> <span class="n">ROOT_CLUSTER</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">clustFileSize</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pgm_read_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fileTable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">pgm_read_dword</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fileTable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">));</span>
        <span class="n">clustFileSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">BYTES_PER_CLUSTER</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
                <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="nl">BYTES_PER_CLUST_SHIFT</span> <span class="p">:</span>
                <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">BYTES_PER_CLUST_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">nClusters</span> <span class="o">+=</span> <span class="n">clustFileSize</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">lastFileNo</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Эту функцию необходимо вызвать в файле <code>MassStorage.c</code> в функции <code>SetupHardware()</code> сразу после вызова <code>USB_Init()</code>, для чего надо не забыть включить <code>#include "Lib/fake_fs.h"</code> в <code>MassStorage</code>.</p>
<p>Для ускорения работы можно было бы вообще все вычисления, выполняемые при подготовке данных <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr> и корневого каталога, сделать в функции инициализации, а не на лету при получении запроса на чтение файла. Однако, тогда надо хранить параметры каждого файла: кластер начала, количество кластеров, размер в байтах, смещение для элемента-описателя в каталоге и для элементов списка в <abbr title="(File Allocation Table) Таблица размещения файлов">FAT</abbr>. Но тогда при увеличении числа имитируемых файлов будет разрастаться занимаемая оперативная память, а ее очень-очень мало. А вот код, вычисляющий эти данные на лету, от количества файлов не зависит.</p>
<p>Если уж на то пошло, то быстрее всего не вычислять ничего, а сложить образ файловой системы где-то в памяти. Получаем в результате обыкновенную флэшку и необходимость иметь солидный объем памяти (по сравнению с имеющейся сейчас). Поэтому жертвую вычислениями в пользу памяти.</p>
<p>Тем более, результат имеется: теперь устройство, подключенное к <abbr title="Персональный компьютер">ПК</abbr>, можно открыть, как флэшку, на которой в корневом каталоге записан файл <code>KEY_FILE.TXT</code>, и этот файл можно открыть блокнотом (который notepad.exe) и прочитать GUID. Готов очередной GIT-коммит.</p>
<h2 id="_4">Остальные файлы</h2>
<p>Имеется заготовка для добавления прочих файлов, перечисленных в начале выпуска. Дальше должно пойти проще: надо вставить в таблицу файлов новое имя файла и имя функции получения данных этого файла, а также ввести его размер. Если это текст &mdash; посчитать вручную, а если нет (например, результат каких-то действий или передачи данных извне) &mdash; задать желаемую величину.</p>
<h3 id="readme">Файл ReadMe</h3>
<p>Добавляю текстовый файл размером чуть побольше. Для этого объявляю соответствующие строковую переменную, константу-размер строки и функцию чтения:</p>
<div class="highlight"><pre><span class="cp">#define SIZE_OF_README  (92 + 53)</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">readme</span><span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&quot;This is a test device whithout any flash-memory.</span><span class="se">\r\n</span><span class="s">&quot;</span>
    <span class="s">&quot;This device have a fake file system FAT32.</span><span class="se">\r\n</span><span class="s">&quot;</span>
    <span class="s">&quot;All files in the device are generated by a program.&quot;</span><span class="p">};</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readMe</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>


<p>В таблицу файлов добавляю вторую строку (между строкой файла <code>KEY_FILETXT</code> и ограничительной строкой):</p>
<div class="highlight"><pre>    <span class="p">{</span><span class="s">&quot;README  TXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_README</span><span class="p">,</span> <span class="n">readMe</span><span class="p">},</span>
</pre></div>


<p>Ну и определяю функцию чтения этого файла, очень похожую на чтение <code>KEY_FILE.TXT</code>. Настолько похожую, что можно бы написать общую унифицированную, но не буду, поскольку текстовых файлов из строковой константы мне больше не надо. А функция такая:</p>
<div class="highlight"><pre><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readMe</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SIZE_OF_README</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">SIZE_OF_README</span><span class="p">)</span> <span class="n">memcpy_P</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">PGM_P</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">readme</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="n">SIZE_OF_README</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">memcpy_P</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">PGM_P</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">readme</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Теперь &laquo;флэшка&raquo; содержит два текстовых файла. Второй &mdash; из трех строчек. Английский в этих строчках, вероятно, хромает, но не в нем дело, &laquo;в музыканта не стрелять, играет, как умеет&raquo;.</p>
<p>Сохраняю коммит и продолжаю.</p>
<h3 id="_5">Большой файл</h3>
<p>Теперь добавлю файл, который не читает данные из памяти программ, а собирает их на лету, в процессе запросов на чтение. Для простоты пусть это будет набор возрастающих чисел, 32-разрядный счетчик. И лучше в текстовом виде, чтобы не заморачиваться с его просмотром, а открыть тем же блокнотом. И пусть он будет, скажем, мегабайтным.</p>
<p>Объявляю константу-размер и функцию чтения:</p>
<div class="highlight"><pre><span class="cp">#define SIZE_OF_TEST    0x100000</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readTest</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>


<p>Вставляю третью строчку в таблицу файлов:</p>
<div class="highlight"><pre>    <span class="p">{</span><span class="s">&quot;TESTFILETXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_TEST</span><span class="p">,</span> <span class="n">readTest</span><span class="p">},</span>
</pre></div>


<p>И определяю объявленную функцию:</p>
<div class="highlight"><pre><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readTest</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SIZE_OF_TEST</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>

    <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
    <span class="n">nibble</span> <span class="o">=</span> <span class="n">nibble</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="nl">nibble</span> <span class="p">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">nibble</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Здесь наполнение файла формируется из смещения. В 16-байтный кусок можно вместить в текстовом виде 2 числа по 6 цифр (для наглядности и простоты формирования &mdash; шестнадцатиричных) с двумя пробелами для разделения.</p>
<p>Смещение (<code>offset</code>) 16-байтовых кусков изменяется на 16. Если его разделить на 8 (путем сдвига вправо на 3 разряда), то получим величину, изменяющуюся на 2. Внутри процедуры формирования числа дополнительно увеличиваем на 1. Получаем последовательно изменяющееся число, и при достижении файлом мегабайтного размера получаем набор чисел от 000000 до 01FFFF.</p>
<p>После компиляции в корневом каталоге &laquo;флэшки&raquo; появляется еще один файл. Размер его гораздо больше, чем память программ и оперативная память устройства, вместе взятые (16 КБ + 512 Б). Первый раз он открывается блокнотом довольно долго. Оно и понятно: процедура чтения включает в себя всякого рода вычисления. Зато второй и последующие разы файл открывается моментально, потому, что <abbr title="Операционная система">ОС</abbr> уже сохранила состояние <abbr title="Файловая система">ФС</abbr> устройства и прочитанные с него файлы в своем кэше и берет данные из кэша, а не с устройства. Это может вызвать некоторые проблемы при попытке чтения обновляющихся данных на следующем этапе.</p>
<h3 id="_6">Файл, изменяющийся вручную</h3>
<p>Для оценки поведения устройства в связке с <abbr title="Операционная система">ОС</abbr>, а также для отладки получения изменяющихся данных нужна имитация файла, содержимое которого зависит от действий пользователя, скажем, нажатия на кнопки. Такой счетчик нажатий в программе уже объявлен, это <code>data_device</code> в <code>MassStorage.c</code>. Надо перенести объявление ее (а заодно и <code>data_PC</code>) в интерфейсную часть &mdash; в заголовочный файл, а он уже подключен где надо.</p>
<p>Опять же, добавляю размер файла и функцию подготовки его данных:</p>
<div class="highlight"><pre><span class="cp">#define SIZE_OF_USERDATA    0x10</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readUserData</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>


<p>Добавляю четвертую строчку таблицы:</p>
<div class="highlight"><pre>    <span class="p">{</span><span class="s">&quot;USERDATATXT&quot;</span><span class="p">,</span> <span class="n">SIZE_OF_USERDATA</span><span class="p">,</span> <span class="n">readUserData</span><span class="p">},</span>
</pre></div>


<p>и определяю функцию:</p>
<div class="highlight"><pre><span class="kt">uint8_t</span> <span class="o">*</span> <span class="nf">readUserData</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span> <span class="o">=</span> <span class="s">&quot;Counter = &quot;</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">data_device</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="p">((</span><span class="n">data_device</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="p">((</span><span class="n">data_device</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span><span class="mh">0xF</span><span class="p">);</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_device</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">48</span> <span class="o">+</span> <span class="p">(</span><span class="n">data_device</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">:</span> <span class="mi">55</span> <span class="o">+</span> <span class="p">(</span><span class="n">data_device</span> <span class="o">&amp;</span><span class="mh">0xF</span><span class="p">);</span>
    <span class="n">data_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;h&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data_buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Здесь формируется шестнадцатиричное текстовое представление переменной <code>data_device</code>, которое вставляется в сопроводительную подпись. Вся собранная строка добита пробелами до конца, до 16 символов. Точнее говоря, собирается на 16-символьной заготовке, изначально заполненной пробелами.</p>
<p>Теперь появился еще один текстовый файл. Если его открыть блокнотом, можно увидеть строку</p>
<div class="highlight"><pre>Counter = 00h   
</pre></div>


<p>Можно понажимать на кнопки устройства, на верхнюю и вторую сверху. Ничего в файле не изменится. Более того, можно закрыть файл, снова понажимать на кнопки и опять открыть файл, а там по-прежнему будет <code>00h</code>. А вот если нажать кнопку &laquo;Reset&raquo; на устройстве (&laquo;флэшка&raquo; на компьютере определится заново), потом нажать разика три на верхнюю кнопку, и уже потом открыть файл, можно увидеть</p>
<div class="highlight"><pre>Counter = 03h   
</pre></div>


<p>И эти показания уже не изменятся до очередного сброса или перезапуска питания. Получаем очередное наглядное подтверждение того, что <abbr title="Операционная система">ОС</abbr> читает носитель в кэш и потом использует данные кэша.</p>
<p>Сохраняю коммит в GIT. Эта версия уже заслуживает номера &laquo;1.0&raquo;.</p>
<h2 id="_7">Низкоуровневое чтение</h2>
<p>Напоследок попробую считать данные из разных областей устройства командой <code>dd</code> и убедиться в том, что &laquo;флэшка&raquo; отвечает на запросы в точности так, как ожидается.</p>
<p>Для начала MBR:</p>
<div class="highlight"><pre>dd <span class="k">if</span><span class="o">=</span>/dev/sdg1 <span class="nv">of</span><span class="o">=</span>/home/mbr.img <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">skip</span><span class="o">=</span>0
</pre></div>


<div class="highlight"><pre>00000000: eb 58 90 4d 53 44 4f 53 35 2e 30 00 02 08 01 00  .X.MSDOS5.0.....
00000010: 02 00 00 00 00 f8 00 00 3f 00 ff 00 3e 00 00 00  ........?...&gt;...
00000020: 00 10 00 00 08 00 00 00 00 00 00 00 02 00 00 00  ................
00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000040: 80 00 29 94 0e 0d 08 4e 4f 20 4e 41 4d 45 20 20  ..)....NO NAME
00000050: 20 20 46 41 54 33 32 20 20 20 00 00 00 00 00 00    FAT32   ......
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000110: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000130: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000140: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000150: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000160: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000001f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa  ..............U.
</pre></div>


<p>Потом FAT1:</p>
<div class="highlight"><pre>dd <span class="k">if</span><span class="o">=</span>/dev/sdg1 <span class="nv">of</span><span class="o">=</span>/home/mbr.img <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">3</span> <span class="nv">skip</span><span class="o">=</span>1
</pre></div>


<div class="highlight"><pre>00000000: f8 ff ff 0f ff ff ff 0f ff ff ff 0f ff ff ff 0f  ................
00000010: ff ff ff 0f 06 00 00 00 07 00 00 00 08 00 00 00  ................
00000020: 09 00 00 00 0a 00 00 00 0b 00 00 00 0c 00 00 00  ................
00000030: 0d 00 00 00 0e 00 00 00 0f 00 00 00 10 00 00 00  ................
00000040: 11 00 00 00 12 00 00 00 13 00 00 00 14 00 00 00  ................
00000050: 15 00 00 00 16 00 00 00 17 00 00 00 18 00 00 00  ................
00000060: 19 00 00 00 1a 00 00 00 1b 00 00 00 1c 00 00 00  ................
00000070: 1d 00 00 00 1e 00 00 00 1f 00 00 00 20 00 00 00  ............ ...
00000080: 21 00 00 00 22 00 00 00 23 00 00 00 24 00 00 00  !...&quot;...#...$...
00000090: 25 00 00 00 26 00 00 00 27 00 00 00 28 00 00 00  %...&amp;...&#39;...(...
000000a0: 29 00 00 00 2a 00 00 00 2b 00 00 00 2c 00 00 00  )...*...+...,...
000000b0: 2d 00 00 00 2e 00 00 00 2f 00 00 00 30 00 00 00  -......./...0...
000000c0: 31 00 00 00 32 00 00 00 33 00 00 00 34 00 00 00  1...2...3...4...
000000d0: 35 00 00 00 36 00 00 00 37 00 00 00 38 00 00 00  5...6...7...8...
000000e0: 39 00 00 00 3a 00 00 00 3b 00 00 00 3c 00 00 00  9...:...;...&lt;...
000000f0: 3d 00 00 00 3e 00 00 00 3f 00 00 00 40 00 00 00  =...&gt;...?...@...
00000100: 41 00 00 00 42 00 00 00 43 00 00 00 44 00 00 00  A...B...C...D...
00000110: 45 00 00 00 46 00 00 00 47 00 00 00 48 00 00 00  E...F...G...H...
00000120: 49 00 00 00 4a 00 00 00 4b 00 00 00 4c 00 00 00  I...J...K...L...
00000130: 4d 00 00 00 4e 00 00 00 4f 00 00 00 50 00 00 00  M...N...O...P...
00000140: 51 00 00 00 52 00 00 00 53 00 00 00 54 00 00 00  Q...R...S...T...
00000150: 55 00 00 00 56 00 00 00 57 00 00 00 58 00 00 00  U...V...W...X...
00000160: 59 00 00 00 5a 00 00 00 5b 00 00 00 5c 00 00 00  Y...Z...[...\...
00000170: 5d 00 00 00 5e 00 00 00 5f 00 00 00 60 00 00 00  ]...^..._...`...
00000180: 61 00 00 00 62 00 00 00 63 00 00 00 64 00 00 00  a...b...c...d...
00000190: 65 00 00 00 66 00 00 00 67 00 00 00 68 00 00 00  e...f...g...h...
000001a0: 69 00 00 00 6a 00 00 00 6b 00 00 00 6c 00 00 00  i...j...k...l...
000001b0: 6d 00 00 00 6e 00 00 00 6f 00 00 00 70 00 00 00  m...n...o...p...
000001c0: 71 00 00 00 72 00 00 00 73 00 00 00 74 00 00 00  q...r...s...t...
000001d0: 75 00 00 00 76 00 00 00 77 00 00 00 78 00 00 00  u...v...w...x...
000001e0: 79 00 00 00 7a 00 00 00 7b 00 00 00 7c 00 00 00  y...z...{...|...
000001f0: 7d 00 00 00 7e 00 00 00 7f 00 00 00 80 00 00 00  }...~...........
00000200: 81 00 00 00 82 00 00 00 83 00 00 00 84 00 00 00  ................
00000210: 85 00 00 00 86 00 00 00 87 00 00 00 88 00 00 00  ................
00000220: 89 00 00 00 8a 00 00 00 8b 00 00 00 8c 00 00 00  ................
00000230: 8d 00 00 00 8e 00 00 00 8f 00 00 00 90 00 00 00  ................
00000240: 91 00 00 00 92 00 00 00 93 00 00 00 94 00 00 00  ................
00000250: 95 00 00 00 96 00 00 00 97 00 00 00 98 00 00 00  ................
00000260: 99 00 00 00 9a 00 00 00 9b 00 00 00 9c 00 00 00  ................
00000270: 9d 00 00 00 9e 00 00 00 9f 00 00 00 a0 00 00 00  ................
00000280: a1 00 00 00 a2 00 00 00 a3 00 00 00 a4 00 00 00  ................
00000290: a5 00 00 00 a6 00 00 00 a7 00 00 00 a8 00 00 00  ................
000002a0: a9 00 00 00 aa 00 00 00 ab 00 00 00 ac 00 00 00  ................
000002b0: ad 00 00 00 ae 00 00 00 af 00 00 00 b0 00 00 00  ................
000002c0: b1 00 00 00 b2 00 00 00 b3 00 00 00 b4 00 00 00  ................
000002d0: b5 00 00 00 b6 00 00 00 b7 00 00 00 b8 00 00 00  ................
000002e0: b9 00 00 00 ba 00 00 00 bb 00 00 00 bc 00 00 00  ................
000002f0: bd 00 00 00 be 00 00 00 bf 00 00 00 c0 00 00 00  ................
00000300: c1 00 00 00 c2 00 00 00 c3 00 00 00 c4 00 00 00  ................
00000310: c5 00 00 00 c6 00 00 00 c7 00 00 00 c8 00 00 00  ................
00000320: c9 00 00 00 ca 00 00 00 cb 00 00 00 cc 00 00 00  ................
00000330: cd 00 00 00 ce 00 00 00 cf 00 00 00 d0 00 00 00  ................
00000340: d1 00 00 00 d2 00 00 00 d3 00 00 00 d4 00 00 00  ................
00000350: d5 00 00 00 d6 00 00 00 d7 00 00 00 d8 00 00 00  ................
00000360: d9 00 00 00 da 00 00 00 db 00 00 00 dc 00 00 00  ................
00000370: dd 00 00 00 de 00 00 00 df 00 00 00 e0 00 00 00  ................
00000380: e1 00 00 00 e2 00 00 00 e3 00 00 00 e4 00 00 00  ................
00000390: e5 00 00 00 e6 00 00 00 e7 00 00 00 e8 00 00 00  ................
000003a0: e9 00 00 00 ea 00 00 00 eb 00 00 00 ec 00 00 00  ................
000003b0: ed 00 00 00 ee 00 00 00 ef 00 00 00 f0 00 00 00  ................
000003c0: f1 00 00 00 f2 00 00 00 f3 00 00 00 f4 00 00 00  ................
000003d0: f5 00 00 00 f6 00 00 00 f7 00 00 00 f8 00 00 00  ................
000003e0: f9 00 00 00 fa 00 00 00 fb 00 00 00 fc 00 00 00  ................
000003f0: fd 00 00 00 fe 00 00 00 ff 00 00 00 00 01 00 00  ................
00000400: 01 01 00 00 02 01 00 00 03 01 00 00 04 01 00 00  ................
00000410: ff ff ff 0f ff ff ff 0f ff ff ff 0f 00 00 00 00  ................
</pre></div>


<p>Дальше до конца кластера &mdash; нули. С параметром skip=9 читается FAT2 с тем же самым результатом.</p>
<p>Корневой каталог:</p>
<div class="highlight"><pre>dd <span class="k">if</span><span class="o">=</span>/dev/sdg1 <span class="nv">of</span><span class="o">=</span>/home/mbr.img <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">3</span> <span class="nv">skip</span><span class="o">=</span>17
</pre></div>


<div class="highlight"><pre>00000000: 4c 55 46 41 5f 31 20 20 20 20 20 08 00 00 00 00  LUFA_1     .....
00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000020: 4b 45 59 5f 46 49 4c 45 54 58 54 20 00 04 72 00  KEY_FILETXT ..r.
00000030: 79 40 79 40 00 00 00 00 79 40 03 00 26 00 00 00  y@y@....y@..&amp;...
00000040: 52 45 41 44 4d 45 20 20 54 58 54 20 00 04 72 00  README  TXT ..r.
00000050: 79 40 79 40 00 00 00 00 79 40 04 00 91 00 00 00  y@y@....y@......
00000060: 54 45 53 54 46 49 4c 45 54 58 54 20 00 04 72 00  TESTFILETXT ..r.
00000070: 79 40 79 40 00 00 00 00 79 40 05 00 00 00 10 00  y@y@....y@......
00000080: 55 53 45 52 44 41 54 41 54 58 54 20 00 04 72 00  USERDATATXT ..r.
00000090: 79 40 79 40 00 00 00 00 79 40 05 01 10 00 00 00  y@y@....y@......
000000a0: 44 41 54 41 20 20 20 20 42 49 4e 20 00 04 72 00  DATA    BIN ..r.
000000b0: 79 40 79 40 00 00 00 00 79 40 06 01 80 00 00 00  y@y@....y@......
</pre></div>


<p>Также показана только непустая часть кластера. И, наконец, для примера один из файлов &mdash; <code>KEY_FILE.TXT</code>:</p>
<div class="highlight"><pre>dd <span class="k">if</span><span class="o">=</span>/dev/sdg1 <span class="nv">of</span><span class="o">=</span>/home/mbr.img <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">skip</span><span class="o">=</span>25
</pre></div>


<div class="highlight"><pre>00000000: 7b 37 30 36 35 63 32 33 61 2d 33 38 31 38 2d 34  {7065c23a-3818-4
00000010: 33 63 35 2d 62 64 66 30 2d 35 35 35 36 37 61 64  3c5-bdf0-55567ad
00000020: 65 33 31 65 37 7d 00 00 00 00 00 00 00 00 00 00  e31e7}..........
</pre></div>


<h2 id="_8">Итог</h2>
<p>В результате получено устройство, которое успешно делает вид, что оно &mdash; флэшка с файловой системой FAT32 и набором файлов, данные для которых можно брать из памяти устройства, можно формировать на лету путем вычислений, можно получать из каких-то внешних источников, хотя бы и от кнопок.</p>
<p>Правда, с получением изменяющихся данных есть некоторые сложности из-за кэширования их средствами <abbr title="Операционная система">ОС</abbr>. Эту тему рассмотрю чуть позже.</p>
<p>Имитируемые файлы пока что только читаются. Хотя можно в текстовом редакторе их поправить, дать команду записи и никаких ошибок при этом не получить. Ибо изменения также будут делаться в кэше, а при попытке <abbr title="Операционная система">ОС</abbr> сбросить изменения в носитель она получит ответ, что &laquo;все в порядке, принято&raquo;. Тему записи в устройство и использования записанных данных откладываю пока на неопределенный срок</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "usb-polygon-12.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>