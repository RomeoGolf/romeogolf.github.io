<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USB-polygon-6: Обмен по USB, поиск среди устройств</title>
  <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <link rel="stylesheet" href="http://romeogolf.github.io/theme/css/styles.css" type="text/css" />
  <link rel="stylesheet" type="text/css"  href="http://romeogolf.github.io/theme/css/pygments.css"/>
  <link rel="shortcut icon" type="image/png" href="http://romeogolf.github.io/images/RG32.ico" />
  <script language="JavaScript" src="http://romeogolf.github.io/theme/js/protector.js"></script>
</head>
<body>
  <header class="main-header">
    <div>
      <img src="http://romeogolf.github.io/images/72.png" style="margin-left: 34px; margin-top: 30px;"> <a id="name" href=http://romeogolf.github.io id="home-link">RomeoGolf</a>
    </div>
  </header>
    <nav class="nav_base">
      <ul class="main-nav">
          <li class="active"><a href="http://romeogolf.github.io/category/blog.html">Блог</a></li>
          <li><a href="http://romeogolf.github.io/category/tvorchestvo.html">Творчество</a></li>


          <li>
            <a href="http://romeogolf.github.io/pages/triangulum-soft.html">Triangulum Soft</a>
          </li>
          <li>
            <a href="http://romeogolf.github.io/pages/o-saite.html">О сайте</a>
          </li>
      </ul>
    </nav>
  <div class="layout">

    <div class="sidebar">
      <div class="tagcloud">
        Теги:
        <ul class="tagcloud">
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/batcmd.html">
              bat/cmd
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/linux.html">
              linux
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/markdown.html">
              markdown
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pelican.html">
              pelican
                <span class="badge">6</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/rfquiz.html">
              rfquiz
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/tar.html">
              tar
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/triangulum.html">
              triangulum
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-1">
            <a href="http://romeogolf.github.io/tag/usb-polygon.html">
              usb-polygon
                <span class="badge">15</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/windows.html">
              windows
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/nishchebrod.html">
              нищеброд
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/pokhodnoe.html">
              походное
                <span class="badge">3</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/raznoe.html">
              разное
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/remont.html">
              ремонт
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-4">
            <a href="http://romeogolf.github.io/tag/samodelki.html">
              самоделки
                <span class="badge">1</span>
            </a>
          </li>
          <li class="tag-3">
            <a href="http://romeogolf.github.io/tag/svoimi-rukami.html">
              своими руками
                <span class="badge">2</span>
            </a>
          </li>
          <li class="tag-2">
            <a href="http://romeogolf.github.io/tag/stikhi.html">
              стихи
                <span class="badge">3</span>
            </a>
          </li>
        </ul>
      </div> <!-- tagcloud -->
    </div> <!-- sidebar -->

    <div class="content">
  <section class="main-section blog-section" id="blog-posts">
    <h4 class="date">Пн 09 Январь 2017</h4>
    <article>
      <h1>USB-polygon-6: Обмен по USB, поиск среди устройств</h1>
      
      <div class="toc">
<ul>
<li><a href="#_1">А что мы, собственно, нашли?</a></li>
<li><a href="#_2">Как спросить устройство?</a></li>
<li><a href="#inquiry">Запрос INQUIRY и как это делается</a></li>
</ul>
</div>
<h2 id="_1">А что мы, собственно, нашли?</h2>
<p>В предыдущем <a href="http://romeogolf.github.io/usb-polygon-5.html">выпуске</a> получилось завести пример кода на С++, который в состоянии обнаружить подключенную флэшку. А что он еще может обнаружить?</p>
<p>Закрою в коде примера условие</p>
<div class="highlight"><pre><span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">_tcscmp</span><span class="p">(</span><span class="n">lpBuffer</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;USBSTOR&quot;</span><span class="p">))</span> <span class="p">)</span>
</pre></div>


<p>которое отсеивает устройства, не имеющие в своем &laquo;FriendlyName&raquo; подстроки <code>USBSTOR</code>. Консольный вывод программы у меня показывает, что обнаружен CD-ROM (судя по &laquo;\?\ide#diskst&raquo;), а жесткий диск не видит. Если воткнуть флэшку &mdash; то и ее тоже, конечно, находит.</p>
<p>Попробую заменить строку</p>
<div class="highlight"><pre>    <span class="k">const</span> <span class="n">GUID</span> <span class="n">InterfaceGuid</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x53F56307</span><span class="p">,</span><span class="mh">0xB6BF</span><span class="p">,</span><span class="mh">0x11D0</span><span class="p">,{</span><span class="mh">0x94</span><span class="p">,</span><span class="mh">0xF2</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0xA0</span><span class="p">,</span><span class="mh">0xC9</span><span class="p">,</span><span class="mh">0x1E</span><span class="p">,</span><span class="mh">0xFB</span><span class="p">,</span><span class="mh">0x8B</span><span class="p">}</span> <span class="p">};</span>
</pre></div>


<p>на</p>
<div class="highlight"><pre>    <span class="c1">// \\?\usbstor#disk&amp;ven_&lt;name&gt;&amp;rev_0001#7&amp;4e...</span>
    <span class="c1">// GUID_DEVINTERFACE_DISK</span>
    <span class="c1">//const GUID InterfaceGuid = { 0x53F56307,0xB6BF,0x11D0,{0x94,0xF2,0x00,0xA0,0xC9,0x1E,0xFB,0x8B} };</span>

    <span class="c1">// \\?\storage#removablemedia#8...</span>
    <span class="c1">// GUID_DEVINTERFACE_VOLUME</span>
    <span class="c1">// нельзя FriendlyName</span>
    <span class="k">const</span> <span class="n">GUID</span> <span class="n">InterfaceGuid</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x53f5630dL</span><span class="p">,</span> <span class="mh">0xb6bf</span><span class="p">,</span> <span class="mh">0x11d0</span><span class="p">,</span> <span class="p">{</span><span class="mh">0x94</span><span class="p">,</span> <span class="mh">0xf2</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0xc9</span><span class="p">,</span> <span class="mh">0x1e</span><span class="p">,</span> <span class="mh">0xfb</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">}</span> <span class="p">};</span>
</pre></div>


<p>для экспериментов. Первый вариант будет искать диски, а второй &mdash; логические тома.</p>
<p>Запуск программы с открытым вторым вариантом <code>InterfaceGuid</code> показывает флэшку (если вставлена) и все разделы жесткого диска. Ах да, и CD-ROM тоже.</p>
<p>По идее, именно второй вариант мне и нужен, потому что надо открыть устройство с определенной буквой, а буквы присваиваются разделам, а не устройствам, пусть даже у моей самоделки одному устройству соответствует один &laquo;раздел&raquo;, как, впрочем, у большинства флэшек. Но при использовании второго варианта недопустим параметр <code>SPDRP_FRIENDLYNAME</code> для функции <code>SetupDiGetDeviceRegistryProperty</code>.</p>
<p>Более того, мне вообще не нравится использование <code>SetupDiGetDeviceRegistryProperty</code>: во-первых, работа с реестром в разных версиях Windows (XP и 7) несколько отличается, и неизвестно, какие неожиданности может подкинуть попытка обеспечить &laquo;кроссплатформенность&raquo; хотя бы в пределах Windows; во-вторых, в реестр это самое &laquo;дружественное имя&raquo; записывается при первом обнаружении устройства и определении, какой драйвер для него использовать, а мне хотелось бы иметь возможность идентификации платы при каждом включении, то есть, искать идентификатор именно на устройстве, а не в реестре.</p>
<h2 id="_2">Как спросить устройство?</h2>
<p>А как обратиться к устройству? Видимо, надо сначала получить его дескриптор через <code>CreateFile</code>. Параметр-путь у нас уже есть после вызова <code>SetupDiGetDeviceInterfaceDetail</code>. То есть, обращение к реестру уже не нужно, пробуем по очереди открыть каждое обнаруженное устройство из класса &laquo;том накопителя&raquo;. Если не откроется &mdash; значит, и не надо. Если откроется &mdash; его можно будет спросить.</p>
<p>Вот это вот:</p>
<div class="highlight"><pre>        <span class="n">RequiredLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">SetupDiGetDeviceRegistryProperty</span><span class="p">(</span><span class="n">hDevInfo</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">DeviceInfoData</span><span class="p">,</span> <span class="n">SPDRP_ENUMERATOR_NAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
            <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">lpBuffer</span><span class="p">,</span> <span class="n">RequiredLength</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RequiredLength</span><span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">GetLastError</span><span class="p">()</span> <span class="o">==</span> <span class="n">ERROR_INSUFFICIENT_BUFFER</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">LocalFreeIf</span><span class="p">(</span><span class="n">lpBuffer</span><span class="p">);</span>
                <span class="n">lpBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">TCHAR</span><span class="o">*</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="p">(</span><span class="n">RequiredLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">OutFormatMsg</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;SetupDiGetDeviceRegistryProperty&quot;</span><span class="p">));</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
</pre></div>


<p>удаляем, следующий аналогичный блок с <code>SPDRP_FRIENDLYNAME</code> вместо <code>SPDRP_ENUMERATOR_NAME</code> (и <code>_tprintf</code> после него) &mdash; тоже, закрытое комментарием условие отсева <code>USBSTOR</code> &mdash; туда же. И <code>LocalFreeIf(lpBuffer);</code> также можно удалить вместе с объявлением буфера <code>lpBuffer</code> вверху кода, этот буфер теперь не нужен.</p>
<p>Короче, от всего условия отсева остается только <code>_tprintf(_T("%s\n"), pDeviceInterfaceDetailData-&gt;DevicePath);</code>. Причем, эту строчку имеет смысл сдвинуть на ступень влево, удалить обрамляющие скобки, оставшиеся от условия и добавить пояснение, что именно мы выводим в консоль.</p>
<p>Затем пытаемся открыть устройство, выведем результат попытки, и закрываем, если открылось.</p>
<p>Итого, вместо условия отсева и отображения имени флэшки получаем следующее:</p>
<div class="highlight"><pre>        <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;pDeviceInterfaceDetailData-&gt;DevicePath: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span> <span class="n">pDeviceInterfaceDetailData</span><span class="o">-&gt;</span><span class="n">DevicePath</span><span class="p">);</span>

        <span class="n">HANDLE</span> <span class="n">hDevice</span><span class="o">=</span><span class="n">CreateFile</span><span class="p">(</span>
                <span class="n">pDeviceInterfaceDetailData</span><span class="o">-&gt;</span><span class="n">DevicePath</span><span class="p">,</span>
                <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
                <span class="n">FILE_SHARE_READ</span> <span class="n">or</span> <span class="n">FILE_SHARE_WRITE</span><span class="p">,</span> <span class="c1">//0,</span>
                <span class="nb">NULL</span><span class="p">,</span>
                <span class="n">OPEN_EXISTING</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span> <span class="c1">//FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING, //FILE_ATTRIBUTE_NORMAL,</span>
                <span class="nb">NULL</span>
                <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;CreateFile failed! </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;CreateFile done! </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
            <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDevice</span><span class="p">);</span>
        <span class="p">}</span>
</pre></div>


<p>В результате обнаруживаются CD-ROM, воткнутая флэшка, мое устройство и разделы жесткого диска, причем, с разделами диска получение дескриптора не работает. А отличить флэшку от моей платы по выводу программы практически нереально. Их строки отличаются только цифрами после <code>\\?\storage#removablemedia#</code>.</p>
<p>Причем, в Windows 7 обнаруженные CD-ROM, флэшка и самоделка определяются программой так:</p>
<div class="highlight"><pre>pDeviceInterfaceDetailData-&gt;DevicePath: \\?\ide#cdromtsstcorp_cddvdw_sh-224bb________________sb00____#5&amp;135419d0&amp;0&amp;1.0.0#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
CreateFile done! 
pDeviceInterfaceDetailData-&gt;DevicePath: \\?\storage#volume#_??_usbstor#disk&amp;ven_generic&amp;prod_flash_disk&amp;rev_8.07#15e1289b&amp;0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
CreateFile done! 
pDeviceInterfaceDetailData-&gt;DevicePath: \\?\storage#volume#_??_usbstor#disk&amp;ven_lufa&amp;prod_dataflash_disk&amp;rev_0.00#955373038393518170f0&amp;0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
CreateFile done! 
</pre></div>


<p>То есть, имеется информация о disk&amp;ven, и уже можно найти нужное устройство, но мне этого мало, и есть необходимость использовать Windows XP, где эти данные отличаются.</p>
<p>Готовлю дальнейшую доработку &mdash; убираю лишнюю информацию из консоли: закрываю печать &laquo;CreateFile failed!&raquo; и переношу отображение <code>DevicePath</code> непосредственно перед &laquo;CreateFile done!&raquo;, делаю коммит.</p>
<p>Теперь у нас есть дескрипторы обнаруженных устройств, с которыми можно работать. Где-то там прячется самодельная плата, надо ее как-то идентифицировать. В этом поможет запрос <code>INQUIRY</code>.</p>
<h2 id="inquiry">Запрос <code>INQUIRY</code> и как это делается</h2>
<p>ПК общается с USB-устройствами, используя интерфейс SCSII. Ну, то есть, не только с USB, но с ними тоже. Протокол SCSII предполагает обмен при помощи команд: компьютер посылает команду устройству, оно отвечает. Среди команд есть Inquiry &mdash; запрос основных характеристик устройства. По этим характеристикам устройство можно идентифицировать. А чтобы отправить SCSII-команду, нужно использовать функцию <code>DeviceIoControl</code>. Сама по себе эта функция не страшная, а вот ее параметры&hellip; Надо подготовить изрядных размеров структуру и заполнить ее начальные значения, потом забрать результат.</p>
<p>В общем, проще пояснить комментариями в коде.</p>
<p>Для использования SCSII-интерфейса надо подключить <code>#include &lt;ntddscsi.h&gt;</code>, и в свойствах проекта указать путь к этому заголовочнику: <code>Project -&gt; Properties</code>, в окне свойств в левой панели выбрать <code>C/C++ Build -&gt; Settings</code>, и на вкладке <code>Tool Settings</code> выбрать <code>GCC C++ Compiler -&gt; Includes</code>, для <code>Include paths (-I)</code> выбрать в файловой системе <code>C:\MinGW\include\ddk</code>.</p>
<p>Чуть ниже объявим такую структуру:</p>
<div class="highlight"><pre><span class="c1">// Это структура _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER,</span>
<span class="c1">// которая eсть в spti.h из состава Windows DDK</span>
<span class="c1">// и нет в MinGW</span>
<span class="k">struct</span> <span class="n">scsi_st</span>
<span class="p">{</span>
    <span class="n">SCSI_PASS_THROUGH_DIRECT</span> <span class="n">t_spti</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">tmp</span><span class="p">;</span>              <span class="c1">// realign buffer to double word boundary</span>
    <span class="n">byte</span> <span class="n">sensebuf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">myspti</span><span class="p">;</span>
</pre></div>


<p>Можно, конечно, подключить заголовочник spti.h, но его надо сначала где-то найти, потом куда-то положить&hellip; Пусть так будет.</p>
<p>И между <code>_tprintf(_T("CreateFile done! \n"));</code> и <code>CloseHandle(hDevice);</code> вставляем такой код:</p>
<div class="highlight"><pre>            <span class="kt">char</span> <span class="n">vbuf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>             <span class="c1">// буфер для принятого пакета</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">returned</span><span class="p">;</span>     <span class="c1">// место под количество прочитанных байт</span>

            <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myspti</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_st</span><span class="p">));</span>    <span class="c1">// инициализация структуры</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SCSI_PASS_THROUGH_DIRECT</span><span class="p">);</span> <span class="c1">// длина</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1">// логический номер устройства (в одном устройстве может быть несколько логических)</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">TargetId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// целевой контроллер или устройство на шине</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">PathId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">// SCSII-порт или шина для запроса.</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">CdbLength</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>    <span class="c1">// длина command descriptor block (CDB, для кодов команд до 0x1F длина 6)</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">DataIn</span> <span class="o">=</span> <span class="n">SCSI_IOCTL_DATA_IN</span><span class="p">;</span>  <span class="c1">// на прием</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">SenseInfoLength</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>     <span class="c1">// длина блока sensebuf и его смещение</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">SenseInfoOffset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SCSI_PASS_THROUGH_DIRECT</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD</span><span class="p">);</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">TimeOutValue</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>        <span class="c1">// таймаут ожидания окончания операции</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">DataTransferLength</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>  <span class="c1">// длина данных для обмена</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">DataBuffer</span> <span class="o">=</span> <span class="n">vbuf</span><span class="p">;</span>        <span class="c1">// указатель на буфер данных</span>
            <span class="c1">// собственно CDB (блок описания команды):</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span>    <span class="c1">// код команды INQUIRY</span>
            <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x24</span><span class="p">;</span>    <span class="c1">// 36 - размер данных</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">DeviceIoControl</span><span class="p">(</span>
                        <span class="n">hDevice</span><span class="p">,</span>                        <span class="c1">// дескриптор устройства</span>
                        <span class="n">IOCTL_SCSI_PASS_THROUGH_DIRECT</span><span class="p">,</span> <span class="c1">// dwIoControlCode управляющий код операции - интерфейс для отправки CDB</span>
                        <span class="o">&amp;</span><span class="n">myspti</span><span class="p">,</span>                        <span class="c1">// входной буфер</span>
                        <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_st</span><span class="p">),</span>                <span class="c1">// его размер</span>
                        <span class="o">&amp;</span><span class="n">myspti</span><span class="p">,</span>                        <span class="c1">// выходной буфер</span>
                        <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_st</span><span class="p">),</span>                <span class="c1">// его размер</span>
                        <span class="o">&amp;</span><span class="n">returned</span><span class="p">,</span>                      <span class="c1">// сколько данных передано (надо бы сверить)</span>
                        <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>                        <span class="c1">// указатель на OVERLAPPED, не нужно.</span>

                <span class="n">vbuf</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                               <span class="c1">// для удобства вывода в консоль</span>
                <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;PDT = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span> <span class="n">vbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>        <span class="c1">// тип устройства SCSII</span>
                <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;RMB = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">vbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x080</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">);</span> <span class="c1">// съемный/нет</span>
                <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;ver. SPC = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span> <span class="n">vbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>   <span class="c1">// версия SPC</span>
                <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;vendor = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">vbuf</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>    <span class="c1">// строковое обозначение производителя</span>
                <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;product = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">vbuf</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>  <span class="c1">// строковое обозначение продукта</span>
                <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;ver = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">vbuf</span><span class="p">[</span><span class="mi">32</span><span class="p">]);</span>      <span class="c1">// строковое обозначение версии</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_tcscmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vbuf</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;LUFA&quot;</span><span class="p">))</span> <span class="p">){</span>       <span class="c1">// поиск своего устройства</span>
                    <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;--- This is my device! ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>                         <span class="c1">// для удобочитаемости пустая строка</span>
            <span class="p">}</span>
</pre></div>


<p>Таким образом, посредством DeviceIoControl выдается SCSII-команда INQUIRY, которая требует вернуть структуру с данными об устройстве. Причем, собственно команда лежит в блоке описания команды CDB, который хотя и имеет размер (16 байтов, насколько я помню), но конкретно для INQUIRY нужны только два: в нулевом передается код команды INQUIRY и в четвертом &mdash; размер принимаемых данных.</p>
<p>Ответ на команду INQUIRY окажется в буфере <code>vbuf</code> и имеет условно фиксированный размер, то есть, должна быть как минимум 36 байтов, хотя может быть и больше и содержать дополнительную информацию. Но обойдемся минимальной частью. Вот что можно оттуда извлечь:</p>
<ul>
<li>В младшем (нулевом) байте (в его младших пяти разрядах) хранится PDT &mdash; PERIPHERAL DEVICE TYPE, тип устройства. 0 &mdash; устройства прямого доступа (например, магнитные диски, флэшки тоже), 1 &mdash; устройства последовательного доступа, типа стриммеров, 2 &mdash; принтеры&hellip; Много их. Вот, например, из обнаруженного, кроме 0, тип 5: CD-ROM.</li>
<li>7 разряд первого байта указывает единицей на то, что устройство съемное.</li>
<li>Второй байт хранит версию стандарта SPC, причем, 4 соответствует  SPC-2, а 5 &mdash; SPC-3.</li>
<li>В четвертом байте лежит длина дополнительных данных, тех, что за пределами 36 байтов. Причем, не просто так, а еще и вычисления какие-то требуются, но это неважно, потому что не нужно.</li>
<li>С 8 по 15 байт занимает обозначение производителя VENDOR IDENTIFICATION.</li>
<li>С 16 по 31 байт занимает обозначение изделия PRODUCT IDENTIFICATION.</li>
<li>С 32 по 35 байт &mdash; версия изделия PRODUCT REVISION LEVEL.</li>
</ul>
<p>Остальное или не используется, или не интересно, потому что не нужно.</p>
<p>Как видно, строки обозначения производителя, изделия и версии могут оканчиваться нулевым символом, а могут и нет, таким образом, для некоторых устройств можно прочитать всю строку оптом, попросив только указатель на массив символов, начиная с 8 байта, однако на других устройствах надо читать все отдельно, при этом, стоит тридцать шестой байт обнулить, а то мало ли что там будет валяться и может прилипнуть к строке версии изделия.</p>
<p>Вот пример того, что вывел текущий код под Windows 7:</p>
<div class="highlight"><pre>pDeviceInterfaceDetailData-&gt;DevicePath: \\?\ide#cdromtsstcorp_cddvdw_sh-224bb________________sb00____#5&amp;135419d0&amp;0&amp;1.0.0#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
CreateFile done! 
PDT = 5
RMB = 1
ver. SPC = 0
vendor = TSSTcorpCDDVDW SH-224BB SB00
product = CDDVDW SH-224BB SB00
ver = SB00

pDeviceInterfaceDetailData-&gt;DevicePath: \\?\storage#volume#_??_usbstor#disk&amp;ven_generic&amp;prod_flash_disk&amp;rev_8.07#15e1289b&amp;0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
CreateFile done! 
PDT = 0
RMB = 1
ver. SPC = 4
vendor = Generic Flash Disk      8.07
product = Flash Disk      8.07
ver = 8.07

pDeviceInterfaceDetailData-&gt;DevicePath: \\?\storage#volume#_??_usbstor#disk&amp;ven_lufa&amp;prod_dataflash_disk&amp;rev_0.00#955373038393518170f0&amp;0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
CreateFile done! 
PDT = 0
RMB = 1
ver. SPC = 0
vendor = LUFA
product = Dataflash Disk
ver = 0.00
--- This is my device! ---
</pre></div>


<p>Получилась работоспособная версия, которая находит нужную плату среди подключенных устройств. Это будет коммит с тегом v0.2.</p>
<p>Теперь пссле строчки <code>_tprintf(_T("--- This is my device! ---\n"));</code> можно добавлять код, работающий с макетной платой. Добавлю для начала попытку записи и чтения. А так как ReadFile &mdash; функция довольно сложная, выполняющая не только собственно чтение, полагаю, она не заработает. Поэтому сделаю опять через DeviceIoControl:</p>
<div class="highlight"><pre>                    <span class="c1">// ----- работа с устройством -----</span>
                    <span class="n">BOOL</span> <span class="n">result</span><span class="p">;</span>
                    <span class="n">UCHAR</span> <span class="n">q</span><span class="p">[</span><span class="mi">512</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
                    <span class="n">DWORD</span> <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">q1</span> <span class="o">=</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myspti</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_st</span><span class="p">));</span>

                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SCSI_PASS_THROUGH_DIRECT</span><span class="p">);</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">PathId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">TargetId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">CdbLength</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">DataIn</span> <span class="o">=</span> <span class="n">SCSI_IOCTL_DATA_OUT</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">SenseInfoLength</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">DataTransferLength</span> <span class="o">=</span> <span class="n">q1</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">TimeOutValue</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">DataBuffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">SenseInfoOffset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SCSI_PASS_THROUGH_DIRECT</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD</span><span class="p">);</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x2a</span><span class="p">;</span> <span class="c1">//SCSIOP_WRITE;</span>

                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>

                    <span class="n">ULONG</span> <span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_st</span><span class="p">);</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span>
                            <span class="n">IOCTL_SCSI_PASS_THROUGH_DIRECT</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">myspti</span><span class="p">,</span>
                            <span class="n">length</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">myspti</span><span class="p">,</span>
                            <span class="n">length</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">q2</span><span class="p">,</span>
                            <span class="n">FALSE</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">OutFormatMsg</span><span class="p">(</span><span class="s">&quot;Write Error DevIoCtl&quot;</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">_tprintf</span><span class="p">(</span><span class="s">&quot;Write done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                        <span class="n">_tprintf</span><span class="p">(</span><span class="s">&quot;len = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">q2</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="n">q2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SCSI_PASS_THROUGH_DIRECT</span><span class="p">);</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">PathId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">TargetId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">CdbLength</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">DataIn</span> <span class="o">=</span> <span class="n">SCSI_IOCTL_DATA_IN</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">SenseInfoLength</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">DataTransferLength</span> <span class="o">=</span> <span class="n">q1</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">TimeOutValue</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">DataBuffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">SenseInfoOffset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SCSI_PASS_THROUGH_DIRECT</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD</span><span class="p">);</span>

                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x28</span><span class="p">;</span> <span class="c1">//SCSIOP_READ;</span>

                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                    <span class="n">myspti</span><span class="p">.</span><span class="n">t_spti</span><span class="p">.</span><span class="n">Cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>

                    <span class="n">result</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span>
                            <span class="n">IOCTL_SCSI_PASS_THROUGH_DIRECT</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">myspti</span><span class="p">,</span>
                            <span class="n">q1</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">myspti</span><span class="p">,</span>
                            <span class="n">q1</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">q2</span><span class="p">,</span>
                            <span class="n">FALSE</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">OutFormatMsg</span><span class="p">(</span><span class="s">&quot;Read Error DevIoCtl&quot;</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">_tprintf</span><span class="p">(</span><span class="s">&quot;data_2 = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                        <span class="n">_tprintf</span><span class="p">(</span><span class="s">&quot;len = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">q2</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="c1">// --------------------------------</span>
</pre></div>


<p>Нулевой байт CDB, как обычно, код команды; первый байт поделен на поля, но в них все равно должны быть везде нули; в байтах со второго по пятый для команд записи и чтения передается logical block assress &mdash; логический адрес первого блока данных на устройстве; шестой байт зарезервирован; в седьмом и восьмом байтах &mdash; размер посылки в логических блоках, старшим вперед. Пока неважно, что в этих адресах, все равно обмен еще не сможет сработать.</p>
<p>В q будет буфер, q1 и q2 &mdash; размер данных и количество реально переданых.</p>
<p>DeviceIoControl выполняется без ошибок (в Windows XP), но читается в первом байте буфера единица, которая была туда записана в коде, то есть, операция чтения не перезаписала ее. Да и длина данных почему-то равна 80. То есть, обмен не работает. Этого и следовало ожидать, потому что код платы его еще не поддерживает. Я даже немного удивлен, что ошибок не возникло.</p>
<p>Впрочем, при проверке в Windows 7 запись не работает:</p>
<div class="highlight"><pre>Write Error DevIoCtl: Неверная функция.


data_2 = 1
len = 80
</pre></div>


<p>Пора коммитить код и переходить к реализации обмена со стороны контроллера.</p>
      <br/>	
      <footer>
          <div>
            <div>Теги:</div>
            <div class="taglist">
              <ul class="tags">
                <li><a href="http://romeogolf.github.io/tag/usb-polygon.html" class="tag">usb-polygon</a></li>
              </ul>
            </div>
          </div>
        <br/>
        <div class="comments">
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_identifier = "usb-polygon-6.html";
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = 'http://romeogolf.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
          </script>
          <noscript>
            <div>Для чтения и написания комментариев требуется включить JavaScript.</div>
	  </noscript>
        </div>
      </footer>
    </article>
  </section>
    </div> <!-- content -->
    
  </div> <!-- layout -->

  <div class="footer">
    &copy; 2016 RomeoGolf


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72333148-1', 'auto');
  ga('send', 'pageview');

</script>

<!--    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-72333148-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script> -->
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter35090040 = new Ya.Metrika({
                    id:35090040,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35090040" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </div> <!-- footer -->

</body>
</html>